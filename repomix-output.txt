This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: docs/src/wallets
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded

Additional Info:
----------------

================================================================
Directory Structure
================================================================
docs/
  src/
    wallets/
      access.md
      checking-balances-and-coins.md
      encrypting-and-storing.md
      index.md
      mnemonic-wallet.md
      private-keys.md
      signing.md
      test-wallets.md

================================================================
Files
================================================================

================
File: docs/src/wallets/access.md
================
# Wallet Access

<!-- This section should explain the difference between the different types of wallets -->
<!-- wallet_types:example:start -->
The kinds of operations we can perform with a `Wallet` instance depend on
whether or not we have access to the wallet's private key.

In order to differentiate between `Wallet` instances that know their private key
and those that do not, we use the `WalletUnlocked` and `Wallet` types
respectively.
<!-- wallet_types:example:end -->

## Wallet States

<!-- This section should explain the unlocked wallet type -->
<!-- wallet_unlocked:example:start -->
The `WalletUnlocked` type represents a wallet whose private key is known and
stored internally in memory. A wallet must be of type `WalletUnlocked` in order
to perform operations that involve signing messages or
transactions.
<!-- wallet_unlocked:example:end -->
You can learn more about signing [here](./signing.md).

<!-- This section should explain the locked wallet type -->
<!-- wallet_locked:example:start -->
The `Wallet` type represents a wallet whose private key is *not* known or stored
in memory. Instead, `Wallet` only knows its public address. A `Wallet` cannot be
used to sign transactions, however it may still perform a whole suite of useful
operations including listing transactions, assets, querying balances, and so on.
<!-- wallet_locked:example:end -->

Note that the `WalletUnlocked` type provides a `Deref` implementation targeting
its inner `Wallet` type. This means that all methods available on the `Wallet`
type are also available on the `WalletUnlocked` type. In other words,
`WalletUnlocked` can be thought of as a thin wrapper around `Wallet` that
provides greater access via its private key.

## Transitioning States

A `Wallet` instance can be unlocked by providing the private key:

```rust,ignore
let wallet_unlocked = wallet_locked.unlock(private_key);
```

A `WalletUnlocked` instance can be locked using the `lock` method:

```rust,ignore
let wallet_locked = wallet_unlocked.lock();
```

Most wallet constructors that create or generate a new wallet are provided on
the `WalletUnlocked` type. Consider locking the wallet with the `lock` method after the new private
key has been handled in order to reduce the scope in which the wallet's private
key is stored in memory.

## Design Guidelines

When designing APIs that accept a wallet as an input, we should think carefully
about the kind of access that we require. API developers should aim to minimise
their usage of `WalletUnlocked` in order to ensure private keys are stored in
memory no longer than necessary to reduce the surface area for attacks and
vulnerabilities in downstream libraries and applications.

================
File: docs/src/wallets/checking-balances-and-coins.md
================
# Checking balances and coins

<!-- This section should explain getting the balance of a wallet -->
<!-- balance:example:start -->
In the Fuel network, each UTXO corresponds to a unique _coin_, and said _coin_ has a corresponding _amount_ (the same way a dollar bill has either 10$ or 5$ face value). So, when you want to query the balance for a given asset ID, you want to query the sum of the amount in each unspent coin. This querying is done very easily with a wallet:
<!-- balance:example:end -->

```rust,ignore
{{#include ../../../examples/wallets/src/lib.rs:get_asset_balance}}
```

<!-- This section should explain getting all of the balances of a wallet -->
<!-- balances:example:start -->
If you want to query all the balances (i.e., get the balance for each asset ID in that wallet), you can use the `get_balances` method:
<!-- balances:example:end -->

```rust,ignore
{{#include ../../../examples/wallets/src/lib.rs:get_balances}}
```

<!-- This section should explain the return type for `get_balances` -->
<!-- balances_return:example:start -->
The return type is a `HashMap`, where the key is the _asset ID's_ hex string, and the value is the corresponding balance. For example, we can get the base asset balance with:
<!-- balances_return:example:end -->

```rust,ignore
{{#include ../../../examples/wallets/src/lib.rs:get_balance_hashmap}}
```

================
File: docs/src/wallets/encrypting-and-storing.md
================
# Encrypting and storing wallets

## Creating a wallet and storing an encrypted JSON wallet on disk

You can also manage a wallet using [JSON wallets](https://cryptobook.nakov.com/symmetric-key-ciphers/ethereum-wallet-encryption) that are securely encrypted and stored on the disk. This makes it easier to manage multiple wallets, especially for testing purposes.

You can create a random wallet and, at the same time, encrypt and store it. Then, later, you can recover the wallet if you know the master password:

```rust,ignore
{{#include ../../../examples/wallets/src/lib.rs:create_and_restore_json_wallet}}
```

## Encrypting and storing a wallet created from a mnemonic or private key

If you have already created a wallet using a mnemonic phrase or a private key, you can also encrypt it and save it to disk:

```rust,ignore
{{#include ../../../examples/wallets/src/lib.rs:create_and_store_mnemonic_wallet}}
```

================
File: docs/src/wallets/index.md
================
# Managing wallets

<!-- This section should explain in general how you can use a wallet in the SDK -->
<!-- wallets:example:start -->
You can use wallets for many important things, for instance:

1. Checking your balance
2. Transferring coins to a destination address or contract
3. Signing messages and transactions
4. Paying for network fees when sending transactions or deploying smart contracts
<!-- wallets:example:end -->

The SDK gives you many different ways to create and access wallets. Let's explore these different approaches in the following sub-chapters.

<!-- This section should provide best security practices for using wallets in the SDK -->
<!-- security:example:start -->
> **Note:** Keep in mind that you should never share your private/secret key. And in the case of wallets that were derived from a mnemonic phrase, never share your mnemonic phrase. If you're planning on storing the wallet on disk, do not store the plain private/secret key and do not store the plain mnemonic phrase. Instead, use `Wallet::encrypt` to encrypt its content first before saving it to disk.
<!-- security:example:end -->

================
File: docs/src/wallets/mnemonic-wallet.md
================
# Creating a wallet from mnemonic phrases

A mnemonic phrase is a cryptographically-generated sequence of words that's used to derive a private key. For instance: `"oblige salon price punch saddle immune slogan rare snap desert retire surprise";` would generate the address `0xdf9d0e6c6c5f5da6e82e5e1a77974af6642bdb450a10c43f0c6910a212600185`.

In addition to that, we also support [Hierarchical Deterministic Wallets](https://www.ledger.com/academy/crypto/what-are-hierarchical-deterministic-hd-wallets) and [derivation paths](https://thebitcoinmanual.com/articles/btc-derivation-path/). You may recognize the string `"m/44'/60'/0'/0/0"` from somewhere; that's a derivation path. In simple terms, it's a way to derive many wallets from a single root wallet.

The SDK gives you two wallets from mnemonic instantiation methods: one that takes a derivation path (`Wallet::new_from_mnemonic_phrase_with_path`) and one that uses the default derivation path, in case you don't want or don't need to configure that (`Wallet::new_from_mnemonic_phrase`).

Here's how you can create wallets with both mnemonic phrases and derivation paths:

```rust,ignore
{{#include ../../../examples/wallets/src/lib.rs:create_wallet_from_mnemonic}}
```

================
File: docs/src/wallets/private-keys.md
================
# Creating a wallet from a private key

A new wallet with a randomly generated private key can be created by supplying `Option<Provider>`.

```rust,ignore
{{#include ../../../examples/wallets/src/lib.rs:create_random_wallet}}
```

Alternatively, you can create a wallet from a predefined `SecretKey`.

```rust,ignore
{{#include ../../../examples/wallets/src/lib.rs:create_wallet_from_secret_key}}
```

> Note: if `None` is supplied instead of a provider, any transaction related to the wallet will result
> in an error until a provider is linked with `set_provider()`. The optional parameter
> enables defining owners (wallet addresses) of genesis coins before a provider is launched.

================
File: docs/src/wallets/signing.md
================
# Signing

Once you've instantiated your wallet in an unlocked state using one of the previously discussed methods, you can sign a message with `wallet.sign`. Below is a full example of how to sign and recover a message.

```rust,ignore
{{#include ../../../packages/fuels-accounts/src/account.rs:sign_message}}
```

## Adding `Signers` to a transaction builder

Every signed resource in the inputs needs to have a witness index that points to a valid witness. Changing the witness index inside an input will change the transaction ID. This means that we need to set all witness indexes before finally signing the transaction. Previously, the user had to make sure that the witness indexes and the order of the witnesses are correct. To automate this process, the SDK will keep track of the signers in the transaction builder and resolve the final transaction automatically. This is done by storing signers until the final transaction is built.

Below is a full example of how to create a transaction builder and add signers to it.

> Note: When you add a `Signer` to a transaction builder, the signer is stored inside it and the transaction will not be resolved until you call `build()`!

```rust,ignore
{{#include ../../../packages/fuels-accounts/src/account.rs:sign_tb}}
```

## Signing a built transaction

If you have a built transaction and want to add a signature, you can use the `sign_with` method.

```rust,ignore
{{#include ../../../e2e/tests/contracts.rs:tx_sign_with}}
```

================
File: docs/src/wallets/test-wallets.md
================
# Setting up test wallets

You'll often want to create one or more test wallets when testing your contracts. Here's how to do it.

## Setting up multiple test wallets

<!-- This section should explain setting up multiple test wallets -->
<!-- test_wallets:example:start -->
If you need multiple test wallets, they can be set up using the `launch_custom_provider_and_get_wallets` method.
<!-- test_wallets:example:end -->

```rust,ignore
{{#include ../../../examples/wallets/src/lib.rs:multiple_wallets_helper}}
```

<!-- This section should explain how to customize test wallets -->
<!-- custom_test_wallets:example:start -->
You can customize your test wallets via `WalletsConfig`.
<!-- custom_test_wallets:example:end -->

```rust,ignore
{{#include ../../../examples/wallets/src/lib.rs:setup_5_wallets}}
```

<!-- This section should explain that test wallets are deterministic -->
<!-- deterministic:example:start -->
>**Note** Wallets generated with `launch_provider_and_get_wallet` or `launch_custom_provider_and_get_wallets`
will have deterministic addresses.
<!-- deterministic:example:end -->

## Setting up a test wallet with multiple random assets

You can create a test wallet containing multiple assets (including the base asset to pay for gas).

```rust,ignore
{{#include ../../../examples/wallets/src/lib.rs:multiple_assets_wallet}}
```

- coins: `Vec<(UtxoId, Coin)>` has `num_assets` * `coins_per_assets` coins (UTXOs)
- asset_ids: `Vec<AssetId>` contains the `num_assets` randomly generated `AssetId`s (always includes the base asset)

## Setting up a test wallet with multiple custom assets

You can also create assets with specific `AssetId`s, coin amounts, and number of coins.

```rust,ignore
{{#include ../../../examples/wallets/src/lib.rs:custom_assets_wallet}}
```

This can also be achieved directly with the `WalletsConfig`.

```rust,ignore
{{#include ../../../examples/wallets/src/lib.rs:custom_assets_wallet_short}}
```

>**Note** In this case, you need to manually add the base asset and the corresponding number of
>coins and coin amount

## Setting up assets

The Fuel blockchain holds many different assets; you can create your asset with its unique `AssetId` or create random assets for testing purposes.

You can use only one asset to pay for transaction fees and gas: the base asset, whose `AssetId` is `0x000...0`, a 32-byte zeroed value.

For testing purposes, you can configure coins and amounts for assets. You can use `setup_multiple_assets_coins`:

```rust,ignore
{{#include ../../../examples/wallets/src/lib.rs:multiple_assets_coins}}
```

>**Note** If setting up multiple assets, one of these assets will always be the base asset.

If you want to create coins only with the base asset, then you can use:

```rust,ignore
{{#include ../../../examples/providers/src/lib.rs:setup_single_asset}}
```

>**Note** Choosing a large number of coins and assets for `setup_multiple_assets_coins` or `setup_single_asset_coins` can lead to considerable runtime for these methods. This will be improved in the future but for now, we recommend using up to **1_000_000** coins, or **1000** coins and assets simultaneously.



================================================================
End of Codebase
================================================================
