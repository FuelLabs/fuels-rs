use crate::{Opcode, Transaction, REG_ONE};
use anyhow::bail;
use fuel_types::AssetId;
use fuels_core::constants::{
    BASE_ASSET_ID, DEFAULT_BYTE_PRICE, DEFAULT_GAS_LIMIT, DEFAULT_GAS_PRICE, DEFAULT_MATURITY,
    DEFAULT_SPENDABLE_COIN_AMOUNT,
};
use fuels_core::tx::{Input, Output};
use fuels_signers::provider::Provider;
use fuels_signers::{LocalWallet, Signer};
use rand::Rng;
use std::future::Future;
use std::sync::Arc;
use std::time::Duration;

/// Can be used to generate `amount` number of blocks. A block is generated by
/// submitting a no-op script for execution. Transactions are submitted one
/// after the other. A new transaction won't be submitted until a increase of
/// block height has been noticed.
///
/// # Arguments
///
/// * `wallet`: A `Wallet` that must contain a provider and spendable coins.
/// * `amount`: By how much to increase the block height.
///
/// returns: Result<(), Error>
pub async fn add_blocks(wallet: &LocalWallet, amount: usize) -> anyhow::Result<()> {
    let provider = wallet.get_provider()?;
    for _ in 0..amount {
        let height_before_transaction = provider.latest_block_height().await?;

        let transaction = no_op_signed_transaction(wallet).await?;

        provider.send_transaction(&transaction).await?;

        if !check_if_block_height_increased(provider, height_before_transaction).await? {
            bail!("Couldn't confirm a block generation via no-op script -- the block height ({}) stayed the same!", height_before_transaction);
        }
    }
    Ok(())
}

async fn no_op_signed_transaction(wallet: &LocalWallet) -> anyhow::Result<Transaction> {
    let inputs = wallet
        .get_asset_inputs_for_amount(BASE_ASSET_ID, DEFAULT_SPENDABLE_COIN_AMOUNT, 0)
        .await?;

    let outputs = vec![Output::change(wallet.address(), 0, AssetId::default())];

    let mut transaction = generate_no_op_script(inputs, outputs);

    wallet.sign_transaction(&mut transaction).await?;

    Ok(transaction)
}

async fn check_if_block_height_increased(
    provider: &Provider,
    height_to_compare_with: u64,
) -> anyhow::Result<bool> {
    let shared_provider = Arc::new(provider.clone());

    let has_block_height_increased = || {
        let prov = Arc::clone(&shared_provider);
        async move {
            let current_block_height = prov.latest_block_height().await?;
            Ok(current_block_height > height_to_compare_with)
        }
    };

    let height_increased =
        retry_until(has_block_height_increased, 5, Duration::from_millis(100)).await?;

    Ok(height_increased)
}

async fn retry_until<Fut>(
    condition: impl Fn() -> Fut,
    max_attempts: usize,
    between_attempts: Duration,
) -> anyhow::Result<bool>
where
    Fut: Future<Output = anyhow::Result<bool>>,
{
    for _ in 0..max_attempts {
        if condition().await? {
            return Ok(true);
        }
        tokio::time::sleep(between_attempts).await;
    }
    Ok(false)
}

fn generate_no_op_script(inputs: Vec<Input>, outputs: Vec<Output>) -> Transaction {
    let random_data = rand::thread_rng().gen::<[u8; 32]>();
    Transaction::Script {
        gas_price: DEFAULT_GAS_PRICE,
        gas_limit: DEFAULT_GAS_LIMIT,
        byte_price: DEFAULT_BYTE_PRICE,
        maturity: DEFAULT_MATURITY,
        receipts_root: Default::default(),
        script: Opcode::RET(REG_ONE).to_bytes().to_vec(),
        script_data: random_data.to_vec(),
        inputs,
        outputs,
        witnesses: vec![],
        metadata: None,
    }
}
