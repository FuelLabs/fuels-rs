# [allow (clippy :: too_many_arguments)]
#[no_implicit_prelude]
pub mod abigen_bindings {
    # [allow (clippy :: too_many_arguments)]
    # [no_implicit_prelude]
    pub mod my_predicate_mod {
        use :: std :: { clone :: Clone , convert :: { Into , TryFrom , From } , format , iter :: IntoIterator , iter :: Iterator , marker :: Sized , panic , vec , string :: ToString , } ;
        # [cfg_attr (not (target_arch = "wasm32") , :: async_trait :: async_trait)]
        impl :: fuels :: signers :: Signer for myPredicate {
            type Error = :: fuels :: types :: errors :: Error ;
            fn sign_message < S : :: std :: marker :: Send + :: std :: marker :: Sync + :: std :: convert :: AsRef < [u8] >> (& self , message : S ,) -> :: fuels :: types :: errors :: Result < () >
            { ::std::result::Result::Ok(()) }
            fn sign_transaction < Tx : :: fuels :: tx :: Cacheable + :: fuels :: tx :: UniqueIdentifier + :: fuels :: tx :: field :: Witnesses + :: std :: marker :: Send > (& self , message : & mut Tx ,) -> :: fuels :: types :: errors :: Result < () >
            { OK(())}
            fn address (& self) -> & :: fuels :: prelude :: Bech32Address ; fn add_fee_resources < 'a_t , Tx : :: fuels :: tx :: Chargeable + :: fuels :: tx :: field :: Inputs + :: fuels :: tx :: field :: Outputs + :: std :: marker :: Send , > (& 'a_t self , tx : & 'a_t mut Tx , previous_base_amount : u64 , witness_index : u8 ,) -> :: fuels :: types :: errors :: Result < () > ; fn get_provider (& self) -> :: std :: option :: Option < :: fuels :: prelude :: Provider > { self . provider () . clone () } } # [derive (Debug)] pub struct myPredicate { address : :: fuels :: types :: bech32 :: Bech32Address , code : :: std :: vec :: Vec < u8 > , data : :: fuels :: core :: abi_encoder :: UnresolvedBytes , provider : :: std :: option :: Option < :: fuels :: prelude :: Provider > } impl myPredicate { pub fn new (code : :: std :: vec :: Vec < u8 >) -> Self { let address : :: fuels :: types :: Address = (* :: fuels :: tx :: Contract :: root_from_code (& code)) . into () ; Self { address : address . clone () . into () , code , data : :: fuels :: core :: abi_encoder :: UnresolvedBytes :: new () , provider : :: std :: option :: Option :: None } } pub fn load_from (file_path : & str) -> :: fuels :: types :: errors :: Result < Self > { :: std :: result :: Result :: Ok (Self :: new (:: std :: fs :: read (file_path) ?)) } pub fn address (& self) -> & :: fuels :: types :: bech32 :: Bech32Address { & self . address } pub fn code (& self) -> :: std :: vec :: Vec < u8 > { self . code . clone () } pub fn provider (& self) -> :: std :: option :: Option < :: fuels :: prelude :: Provider > { self . provider . clone () } pub fn set_provider (& mut self , provider : :: std :: option :: Option < :: fuels :: prelude :: Provider >) { self . provider = provider } pub fn data (& self) -> :: fuels :: core :: abi_encoder :: UnresolvedBytes { self . data . clone () } pub async fn receive (& self , from : & :: fuels :: signers :: wallet :: WalletUnlocked , amount : u64 , asset_id : :: fuels :: types :: AssetId , tx_parameters : :: std :: option :: Option < :: fuels :: core :: parameters :: TxParameters >) -> :: fuels :: types :: errors :: Result < (:: std :: string :: String , :: std :: vec :: Vec < :: fuels :: tx :: Receipt >) > { let tx_parameters = tx_parameters . unwrap_or_default () ; from . transfer (self . address () , amount , asset_id , tx_parameters) . await } pub async fn spend (& self , to : & :: fuels :: signers :: wallet :: WalletUnlocked , amount : u64 , asset_id : :: fuels :: types :: AssetId , tx_parameters : :: std :: option :: Option < :: fuels :: core :: parameters :: TxParameters >) -> :: fuels :: types :: errors :: Result < :: std :: vec :: Vec < :: fuels :: tx :: Receipt >> { let tx_parameters = tx_parameters . unwrap_or_default () ; to . receive_from_predicate (self . address () , self . code () , amount , asset_id , self . data () , tx_parameters ,) . await } # [doc = "Run the predicate's encode function with the provided arguments"] pub fn encode_data (& self , a : u64) -> Self { let data = :: fuels :: core :: abi_encoder :: ABIEncoder :: encode (& [:: fuels :: types :: traits :: Tokenizable :: into_token (a)]) . expect ("Cannot encode predicate data") ; Self { address : self . address . clone () , code : self . code . clone () , data , provider : self . provider . clone () } } } } } pub use abigen_bindings :: my_predicate_mod :: myPredicate ;