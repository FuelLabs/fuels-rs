This file is a merged representation of the entire codebase, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded

Additional Info:
----------------

================================================================
Directory Structure
================================================================
src/
  provider/
    cache.rs
    retry_util.rs
    retryable_client.rs
    supported_fuel_core_version.rs
    supported_versions.rs
  schema/
    schema.sdl
  signers/
    aws_kms.rs
    fake.rs
    locked.rs
    private_key.rs
  account.rs
  accounts_utils.rs
  coin_cache.rs
  keystore.rs
  lib.rs
  predicate.rs
  provider.rs
  signers.rs
  wallet.rs
Cargo.toml

================================================================
Files
================================================================

================
File: src/provider/cache.rs
================
use std::{sync::Arc, time::Duration};

use async_trait::async_trait;
use chrono::{DateTime, Utc};
use fuel_core_client::client::types::NodeInfo;
use fuel_tx::ConsensusParameters;
use fuels_core::types::errors::Result;
use tokio::sync::RwLock;

#[cfg_attr(test, mockall::automock)]
#[async_trait]
pub trait CacheableRpcs {
    async fn consensus_parameters(&self) -> Result<ConsensusParameters>;
    async fn node_info(&self) -> Result<NodeInfo>;
}

trait Clock {
    fn now(&self) -> DateTime<Utc>;
}

#[derive(Debug, Clone)]
pub struct TtlConfig {
    pub consensus_parameters: Duration,
}

impl Default for TtlConfig {
    fn default() -> Self {
        TtlConfig {
            consensus_parameters: Duration::from_secs(60),
        }
    }
}

#[derive(Debug, Clone)]
struct Dated<T> {
    value: T,
    date: DateTime<Utc>,
}

impl<T> Dated<T> {
    fn is_stale(&self, now: DateTime<Utc>, ttl: Duration) -> bool {
        self.date + ttl < now
    }
}

#[derive(Debug, Clone, Copy)]
pub struct SystemClock;
impl Clock for SystemClock {
    fn now(&self) -> DateTime<Utc> {
        Utc::now()
    }
}

#[derive(Debug, Clone)]
pub struct CachedClient<Client, Clock = SystemClock> {
    client: Client,
    ttl_config: TtlConfig,
    cached_consensus_params: Arc<RwLock<Option<Dated<ConsensusParameters>>>>,
    cached_node_info: Arc<RwLock<Option<Dated<NodeInfo>>>>,
    clock: Clock,
}

impl<Client, Clock> CachedClient<Client, Clock> {
    pub fn new(client: Client, ttl: TtlConfig, clock: Clock) -> Self {
        Self {
            client,
            ttl_config: ttl,
            cached_consensus_params: Default::default(),
            cached_node_info: Default::default(),
            clock,
        }
    }

    pub fn set_ttl(&mut self, ttl: TtlConfig) {
        self.ttl_config = ttl
    }

    pub fn inner(&self) -> &Client {
        &self.client
    }

    pub fn inner_mut(&mut self) -> &mut Client {
        &mut self.client
    }
}

impl<Client, Clk> CachedClient<Client, Clk>
where
    Client: CacheableRpcs,
{
    pub async fn clear(&self) {
        *self.cached_consensus_params.write().await = None;
    }
}

#[async_trait]
impl<Client, Clk> CacheableRpcs for CachedClient<Client, Clk>
where
    Clk: Clock + Send + Sync,
    Client: CacheableRpcs + Send + Sync,
{
    async fn consensus_parameters(&self) -> Result<ConsensusParameters> {
        {
            let read_lock = self.cached_consensus_params.read().await;
            if let Some(entry) = read_lock.as_ref() {
                if !entry.is_stale(self.clock.now(), self.ttl_config.consensus_parameters) {
                    return Ok(entry.value.clone());
                }
            }
        }

        let mut write_lock = self.cached_consensus_params.write().await;

        // because it could have been updated since we last checked
        if let Some(entry) = write_lock.as_ref() {
            if !entry.is_stale(self.clock.now(), self.ttl_config.consensus_parameters) {
                return Ok(entry.value.clone());
            }
        }

        let fresh_parameters = self.client.consensus_parameters().await?;
        *write_lock = Some(Dated {
            value: fresh_parameters.clone(),
            date: self.clock.now(),
        });

        Ok(fresh_parameters)
    }

    async fn node_info(&self) -> Result<NodeInfo> {
        // must borrow from consensus_parameters to keep the change non-breaking
        let ttl = self.ttl_config.consensus_parameters;
        {
            let read_lock = self.cached_node_info.read().await;
            if let Some(entry) = read_lock.as_ref() {
                if !entry.is_stale(self.clock.now(), ttl) {
                    return Ok(entry.value.clone());
                }
            }
        }

        let mut write_lock = self.cached_node_info.write().await;

        // because it could have been updated since we last checked
        if let Some(entry) = write_lock.as_ref() {
            if !entry.is_stale(self.clock.now(), ttl) {
                return Ok(entry.value.clone());
            }
        }

        let fresh_node_info = self.client.node_info().await?;
        *write_lock = Some(Dated {
            value: fresh_node_info.clone(),
            date: self.clock.now(),
        });

        Ok(fresh_node_info)
    }
}

#[cfg(test)]
mod tests {
    use std::sync::Mutex;

    use fuel_core_client::client::schema::{
        node_info::{IndexationFlags, TxPoolStats},
        U64,
    };
    use fuel_types::ChainId;

    use super::*;

    #[derive(Clone, Default)]
    struct TestClock {
        time: Arc<Mutex<DateTime<Utc>>>,
    }

    impl TestClock {
        fn update_time(&self, time: DateTime<Utc>) {
            *self.time.lock().unwrap() = time;
        }
    }

    impl Clock for TestClock {
        fn now(&self) -> DateTime<Utc> {
            *self.time.lock().unwrap()
        }
    }

    #[tokio::test]
    async fn initial_call_to_consensus_params_fwd_to_api() {
        // given
        let mut api = MockCacheableRpcs::new();
        api.expect_consensus_parameters()
            .once()
            .return_once(|| Ok(ConsensusParameters::default()));
        let sut = CachedClient::new(api, TtlConfig::default(), TestClock::default());

        // when
        let _consensus_params = sut.consensus_parameters().await.unwrap();

        // then
        // mock validates the call went through
    }

    #[tokio::test]
    async fn new_call_to_consensus_params_cached() {
        // given
        let mut api = MockCacheableRpcs::new();
        api.expect_consensus_parameters()
            .once()
            .return_once(|| Ok(ConsensusParameters::default()));
        let sut = CachedClient::new(
            api,
            TtlConfig {
                consensus_parameters: Duration::from_secs(10),
            },
            TestClock::default(),
        );
        let consensus_parameters = sut.consensus_parameters().await.unwrap();

        // when
        let second_call_consensus_params = sut.consensus_parameters().await.unwrap();

        // then
        // mock validates only one call
        assert_eq!(consensus_parameters, second_call_consensus_params);
    }

    #[tokio::test]
    async fn if_ttl_expired_cache_is_updated() {
        // given
        let original_consensus_params = ConsensusParameters::default();

        let changed_consensus_params = {
            let mut params = original_consensus_params.clone();
            params.set_chain_id(ChainId::new(99));
            params
        };

        let api = {
            let mut api = MockCacheableRpcs::new();
            let original_consensus_params = original_consensus_params.clone();
            let changed_consensus_params = changed_consensus_params.clone();
            api.expect_consensus_parameters()
                .once()
                .return_once(move || Ok(original_consensus_params));

            api.expect_consensus_parameters()
                .once()
                .return_once(move || Ok(changed_consensus_params));
            api
        };

        let clock = TestClock::default();
        let start_time = clock.now();

        let sut = CachedClient::new(
            api,
            TtlConfig {
                consensus_parameters: Duration::from_secs(10),
            },
            clock.clone(),
        );
        let consensus_parameters = sut.consensus_parameters().await.unwrap();

        clock.update_time(start_time + Duration::from_secs(11));
        // when
        let second_call_consensus_params = sut.consensus_parameters().await.unwrap();

        // then
        // mock validates two calls made
        assert_eq!(consensus_parameters, original_consensus_params);
        assert_eq!(second_call_consensus_params, changed_consensus_params);
    }

    #[tokio::test]
    async fn clear_cache_clears_consensus_params_cache() {
        // given
        let first_params = ConsensusParameters::default();
        let second_params = {
            let mut params = ConsensusParameters::default();
            params.set_chain_id(ChainId::new(1234));
            params
        };

        let api = {
            let mut api = MockCacheableRpcs::new();
            let first_clone = first_params.clone();
            api.expect_consensus_parameters()
                .times(1)
                .return_once(move || Ok(first_clone));

            let second_clone = second_params.clone();
            api.expect_consensus_parameters()
                .times(1)
                .return_once(move || Ok(second_clone));
            api
        };

        let clock = TestClock::default();
        let sut = CachedClient::new(api, TtlConfig::default(), clock.clone());

        let result1 = sut.consensus_parameters().await.unwrap();

        // when
        sut.clear().await;

        // then
        let result2 = sut.consensus_parameters().await.unwrap();

        assert_eq!(result1, first_params);
        assert_eq!(result2, second_params);
    }

    fn dummy_node_info() -> NodeInfo {
        NodeInfo {
            utxo_validation: true,
            vm_backtrace: false,
            max_tx: u64::MAX,
            max_gas: u64::MAX,
            max_size: u64::MAX,
            max_depth: u64::MAX,
            node_version: "0.0.1".to_string(),
            indexation: IndexationFlags {
                balances: true,
                coins_to_spend: true,
                asset_metadata: true,
            },
            tx_pool_stats: TxPoolStats {
                tx_count: U64(1),
                total_gas: U64(1),
                total_size: U64(1),
            },
        }
    }

    #[tokio::test]
    async fn initial_call_to_node_info_fwd_to_api() {
        // given
        let mut api = MockCacheableRpcs::new();
        api.expect_node_info()
            .once()
            .return_once(|| Ok(dummy_node_info()));
        let sut = CachedClient::new(api, TtlConfig::default(), TestClock::default());

        // when
        let _node_info = sut.node_info().await.unwrap();

        // then
        // The mock verifies that the API call was made.
    }

    #[tokio::test]
    async fn new_call_to_node_info_cached() {
        // given
        let mut api = MockCacheableRpcs::new();
        api.expect_node_info()
            .once()
            .return_once(|| Ok(dummy_node_info()));
        let sut = CachedClient::new(
            api,
            TtlConfig {
                consensus_parameters: Duration::from_secs(10),
            },
            TestClock::default(),
        );
        let first_node_info = sut.node_info().await.unwrap();

        // when: second call should return the cached value
        let second_node_info = sut.node_info().await.unwrap();

        // then: only one API call should have been made and the values are equal
        assert_eq!(first_node_info, second_node_info);
    }

    #[tokio::test]
    async fn if_ttl_expired_node_info_cache_is_updated() {
        // given
        let original_node_info = dummy_node_info();

        let changed_node_info = NodeInfo {
            node_version: "changed".to_string(),
            ..dummy_node_info()
        };

        let api = {
            let mut api = MockCacheableRpcs::new();
            let original_clone = original_node_info.clone();
            api.expect_node_info()
                .times(1)
                .return_once(move || Ok(original_clone));

            let changed_clone = changed_node_info.clone();
            api.expect_node_info()
                .times(1)
                .return_once(move || Ok(changed_clone));
            api
        };

        let clock = TestClock::default();
        let start_time = clock.now();

        let sut = CachedClient::new(
            api,
            TtlConfig {
                consensus_parameters: Duration::from_secs(10),
            },
            clock.clone(),
        );
        let first_call = sut.node_info().await.unwrap();

        // Advance time past the TTL.
        clock.update_time(start_time + Duration::from_secs(11));

        // when: a new API call should be triggered because the TTL expired
        let second_call = sut.node_info().await.unwrap();

        // then
        assert_eq!(first_call, original_node_info);
        assert_eq!(second_call, changed_node_info);
    }
}

================
File: src/provider/retry_util.rs
================
use std::{fmt::Debug, future::Future, num::NonZeroU32, time::Duration};

use fuels_core::types::errors::{error, Result};

/// A set of strategies to control retry intervals between attempts.
///
/// The `Backoff` enum defines different strategies for managing intervals between retry attempts.
/// Each strategy allows you to customize the waiting time before a new attempt based on the
/// number of attempts made.
///
/// # Variants
///
/// - `Linear(Duration)`: Increases the waiting time linearly with each attempt.
/// - `Exponential(Duration)`: Doubles the waiting time with each attempt.
/// - `Fixed(Duration)`: Uses a constant waiting time between attempts.
///
/// # Examples
///
/// ```rust
/// use std::time::Duration;
/// use fuels_accounts::provider::Backoff;
///
/// let linear_backoff = Backoff::Linear(Duration::from_secs(2));
/// let exponential_backoff = Backoff::Exponential(Duration::from_secs(1));
/// let fixed_backoff = Backoff::Fixed(Duration::from_secs(5));
/// ```
//ANCHOR: backoff
#[derive(Debug, Clone)]
pub enum Backoff {
    Linear(Duration),
    Exponential(Duration),
    Fixed(Duration),
}
//ANCHOR_END: backoff

impl Default for Backoff {
    fn default() -> Self {
        Backoff::Linear(Duration::from_millis(10))
    }
}

impl Backoff {
    pub fn wait_duration(&self, attempt: u32) -> Duration {
        match self {
            Backoff::Linear(base_duration) => *base_duration * (attempt + 1),
            Backoff::Exponential(base_duration) => *base_duration * 2u32.pow(attempt),
            Backoff::Fixed(interval) => *interval,
        }
    }
}

/// Configuration for controlling retry behavior.
///
/// The `RetryConfig` struct encapsulates the configuration parameters for controlling the retry behavior
/// of asynchronous actions. It includes the maximum number of attempts and the interval strategy from
/// the `Backoff` enum that determines how much time to wait between retry attempts.
///
/// # Fields
///
/// - `max_attempts`: The maximum number of attempts before giving up.
/// - `interval`: The chosen interval strategy from the `Backoff` enum.
///
/// # Examples
///
/// ```rust
/// use std::num::NonZeroUsize;
/// use std::time::Duration;
/// use fuels_accounts::provider::{Backoff, RetryConfig};
///
/// let max_attempts = 5;
/// let interval_strategy = Backoff::Exponential(Duration::from_secs(1));
///
/// let retry_config = RetryConfig::new(max_attempts, interval_strategy).unwrap();
/// ```
// ANCHOR: retry_config
#[derive(Clone, Debug)]
pub struct RetryConfig {
    max_attempts: NonZeroU32,
    interval: Backoff,
}
// ANCHOR_END: retry_config

impl RetryConfig {
    pub fn new(max_attempts: u32, interval: Backoff) -> Result<Self> {
        let max_attempts = NonZeroU32::new(max_attempts)
            .ok_or_else(|| error!(Other, "`max_attempts` must be greater than `0`"))?;

        Ok(RetryConfig {
            max_attempts,
            interval,
        })
    }
}

impl Default for RetryConfig {
    fn default() -> Self {
        Self {
            max_attempts: NonZeroU32::new(1).expect("should not fail"),
            interval: Default::default(),
        }
    }
}

/// Retries an asynchronous action with customizable retry behavior.
///
/// This function takes an asynchronous action represented by a closure `action`.
/// The action is executed repeatedly with backoff and retry logic based on the
/// provided `retry_config` and the `should_retry` condition.
///
/// The `action` closure should return a `Future` that resolves to a `Result<T, K>`,
/// where `T` represents the success type and `K` represents the error type.
///
/// # Parameters
///
/// - `action`: The asynchronous action to be retried.
/// - `retry_config`: A reference to the retry configuration.
/// - `should_retry`: A closure that determines whether to retry based on the result.
///
/// # Return
///
/// Returns `Ok(T)` if the action succeeds without requiring further retries.
/// Returns `Err(Error)` if the maximum number of attempts is reached and the action
/// still fails. If a retryable error occurs during the attempts, the error will
/// be returned if the `should_retry` condition allows further retries.
pub(crate) async fn retry<Fut, T, ShouldRetry>(
    mut action: impl FnMut() -> Fut,
    retry_config: &RetryConfig,
    should_retry: ShouldRetry,
) -> T
where
    Fut: Future<Output = T>,
    ShouldRetry: Fn(&T) -> bool,
{
    let mut last_result = None;

    for attempt in 0..retry_config.max_attempts.into() {
        let result = action().await;

        if should_retry(&result) {
            last_result = Some(result)
        } else {
            return result;
        }

        tokio::time::sleep(retry_config.interval.wait_duration(attempt)).await;
    }

    last_result.expect("should not happen")
}

#[cfg(test)]
mod tests {
    mod retry_until {
        use std::time::{Duration, Instant};

        use fuels_core::types::errors::{error, Result};
        use tokio::sync::Mutex;

        use crate::provider::{retry_util, Backoff, RetryConfig};

        #[tokio::test]
        async fn returns_last_received_response() -> Result<()> {
            // given
            let err_msgs = ["err1", "err2", "err3"];
            let number_of_attempts = Mutex::new(0usize);

            let will_always_fail = || async {
                let msg = err_msgs[*number_of_attempts.lock().await];
                *number_of_attempts.lock().await += 1;

                msg
            };

            let should_retry_fn = |_res: &_| -> bool { true };

            let retry_options = RetryConfig::new(3, Backoff::Linear(Duration::from_millis(10)))?;

            // when
            let response =
                retry_util::retry(will_always_fail, &retry_options, should_retry_fn).await;

            // then
            assert_eq!(response, "err3");

            Ok(())
        }

        #[tokio::test]
        async fn stops_retrying_when_predicate_is_satisfied() -> Result<()> {
            // given
            let values = Mutex::new(vec![1, 2, 3]);

            let will_always_fail = || async { values.lock().await.pop().unwrap() };

            let should_retry_fn = |res: &i32| *res != 2;

            let retry_options = RetryConfig::new(3, Backoff::Linear(Duration::from_millis(10)))?;

            // when
            let response =
                retry_util::retry(will_always_fail, &retry_options, should_retry_fn).await;

            // then
            assert_eq!(response, 2);

            Ok(())
        }

        #[tokio::test]
        async fn retry_respects_delay_between_attempts_fixed() -> Result<()> {
            // given
            let timestamps: Mutex<Vec<Instant>> = Mutex::new(vec![]);

            let will_fail_and_record_timestamp = || async {
                timestamps.lock().await.push(Instant::now());
                Result::<()>::Err(error!(Other, "error"))
            };

            let should_retry_fn = |_res: &_| -> bool { true };

            let retry_options = RetryConfig::new(3, Backoff::Fixed(Duration::from_millis(100)))?;

            // when
            let _ = retry_util::retry(
                will_fail_and_record_timestamp,
                &retry_options,
                should_retry_fn,
            )
            .await;

            // then
            let timestamps_vec = timestamps.lock().await.clone();

            let timestamps_spaced_out_at_least_100_mills = timestamps_vec
                .iter()
                .zip(timestamps_vec.iter().skip(1))
                .all(|(current_timestamp, the_next_timestamp)| {
                    the_next_timestamp.duration_since(*current_timestamp)
                        >= Duration::from_millis(100)
                });

            assert!(
                timestamps_spaced_out_at_least_100_mills,
                "retry did not wait for the specified time between attempts"
            );

            Ok(())
        }

        #[tokio::test]
        async fn retry_respects_delay_between_attempts_linear() -> Result<()> {
            // given
            let timestamps: Mutex<Vec<Instant>> = Mutex::new(vec![]);

            let will_fail_and_record_timestamp = || async {
                timestamps.lock().await.push(Instant::now());
                Result::<()>::Err(error!(Other, "error"))
            };

            let should_retry_fn = |_res: &_| -> bool { true };

            let retry_options = RetryConfig::new(3, Backoff::Linear(Duration::from_millis(100)))?;

            // when
            let _ = retry_util::retry(
                will_fail_and_record_timestamp,
                &retry_options,
                should_retry_fn,
            )
            .await;

            // then
            let timestamps_vec = timestamps.lock().await.clone();

            let timestamps_spaced_out_at_least_100_mills = timestamps_vec
                .iter()
                .zip(timestamps_vec.iter().skip(1))
                .enumerate()
                .all(|(attempt, (current_timestamp, the_next_timestamp))| {
                    the_next_timestamp.duration_since(*current_timestamp)
                        >= (Duration::from_millis(100) * (attempt + 1) as u32)
                });

            assert!(
                timestamps_spaced_out_at_least_100_mills,
                "retry did not wait for the specified time between attempts"
            );

            Ok(())
        }

        #[tokio::test]
        async fn retry_respects_delay_between_attempts_exponential() -> Result<()> {
            // given
            let timestamps: Mutex<Vec<Instant>> = Mutex::new(vec![]);

            let will_fail_and_record_timestamp = || async {
                timestamps.lock().await.push(Instant::now());
                Result::<()>::Err(error!(Other, "error"))
            };

            let should_retry_fn = |_res: &_| -> bool { true };

            let retry_options =
                RetryConfig::new(3, Backoff::Exponential(Duration::from_millis(100)))?;

            // when
            let _ = retry_util::retry(
                will_fail_and_record_timestamp,
                &retry_options,
                should_retry_fn,
            )
            .await;

            // then
            let timestamps_vec = timestamps.lock().await.clone();

            let timestamps_spaced_out_at_least_100_mills = timestamps_vec
                .iter()
                .zip(timestamps_vec.iter().skip(1))
                .enumerate()
                .all(|(attempt, (current_timestamp, the_next_timestamp))| {
                    the_next_timestamp.duration_since(*current_timestamp)
                        >= (Duration::from_millis(100) * (2_usize.pow((attempt) as u32)) as u32)
                });

            assert!(
                timestamps_spaced_out_at_least_100_mills,
                "retry did not wait for the specified time between attempts"
            );

            Ok(())
        }
    }
}

================
File: src/provider/retryable_client.rs
================
use std::{future::Future, io};

use async_trait::async_trait;
use custom_queries::{ContractExistsQuery, IsUserAccountQuery, IsUserAccountVariables};
use cynic::QueryBuilder;
use fuel_core_client::client::{
    pagination::{PaginatedResult, PaginationRequest},
    schema::contract::ContractByIdArgs,
    types::{
        gas_price::{EstimateGasPrice, LatestGasPrice},
        primitives::{BlockId, TransactionId},
        Balance, Blob, Block, ChainInfo, Coin, CoinType, ContractBalance, Message, MessageProof,
        NodeInfo, TransactionResponse, TransactionStatus,
    },
    FuelClient,
};
use fuel_core_types::services::executor::TransactionExecutionStatus;
use fuel_tx::{BlobId, ConsensusParameters, Transaction, TxId, UtxoId};
use fuel_types::{Address, AssetId, BlockHeight, ContractId, Nonce};
use fuels_core::types::errors::{error, Error, Result};

use super::{
    cache::CacheableRpcs,
    supported_versions::{self, VersionCompatibility},
};
use crate::provider::{retry_util, RetryConfig};

#[derive(Debug, thiserror::Error)]
pub(crate) enum RequestError {
    #[error("io error: {0}")]
    IO(String),
}

type RequestResult<T> = std::result::Result<T, RequestError>;

impl From<RequestError> for Error {
    fn from(e: RequestError) -> Self {
        Error::Provider(e.to_string())
    }
}

#[derive(Debug, Clone)]
pub(crate) struct RetryableClient {
    client: FuelClient,
    url: String,
    retry_config: RetryConfig,
    prepend_warning: Option<String>,
}

#[async_trait]
impl CacheableRpcs for RetryableClient {
    async fn consensus_parameters(&self) -> Result<ConsensusParameters> {
        Ok(self.chain_info().await?.consensus_parameters)
    }

    async fn node_info(&self) -> Result<NodeInfo> {
        Ok(self.node_info().await?)
    }
}

impl RetryableClient {
    pub(crate) async fn connect(url: impl AsRef<str>, retry_config: RetryConfig) -> Result<Self> {
        let url = url.as_ref().to_string();
        let client = FuelClient::new(&url).map_err(|e| error!(Provider, "{e}"))?;

        let node_info = client.node_info().await?;
        let warning = Self::version_compatibility_warning(&node_info)?;

        Ok(Self {
            client,
            retry_config,
            url,
            prepend_warning: warning,
        })
    }

    fn version_compatibility_warning(node_info: &NodeInfo) -> Result<Option<String>> {
        let node_version = node_info
            .node_version
            .parse::<semver::Version>()
            .map_err(|e| error!(Provider, "could not parse Fuel client version: {}", e))?;

        let VersionCompatibility {
            supported_version,
            is_major_supported,
            is_minor_supported,
            ..
        } = supported_versions::compare_node_compatibility(node_version.clone());

        let msg = if !is_major_supported || !is_minor_supported {
            Some(format!(
                "warning: the fuel node version to which this provider is connected has a semver incompatible version from the one the SDK was developed against. Connected node version: {node_version}, supported version: {supported_version}",
            ))
        } else {
            None
        };

        Ok(msg)
    }

    pub(crate) fn url(&self) -> &str {
        &self.url
    }

    pub(crate) fn set_retry_config(&mut self, retry_config: RetryConfig) {
        self.retry_config = retry_config;
    }

    async fn wrap<T, Fut>(&self, action: impl Fn() -> Fut) -> RequestResult<T>
    where
        Fut: Future<Output = io::Result<T>>,
    {
        retry_util::retry(action, &self.retry_config, |result| result.is_err())
            .await
            .map_err(|e| {
                let msg = if let Some(warning) = &self.prepend_warning {
                    format!("{warning}. {e}")
                } else {
                    e.to_string()
                };
                RequestError::IO(msg)
            })
    }

    // DELEGATION START
    pub async fn health(&self) -> RequestResult<bool> {
        self.wrap(|| self.client.health()).await
    }

    pub async fn transaction(&self, id: &TxId) -> RequestResult<Option<TransactionResponse>> {
        self.wrap(|| self.client.transaction(id)).await
    }

    pub(crate) async fn chain_info(&self) -> RequestResult<ChainInfo> {
        self.wrap(|| self.client.chain_info()).await
    }

    pub async fn await_transaction_commit(&self, id: &TxId) -> RequestResult<TransactionStatus> {
        self.wrap(|| self.client.await_transaction_commit(id)).await
    }

    pub async fn submit_and_await_commit(
        &self,
        tx: &Transaction,
    ) -> RequestResult<TransactionStatus> {
        self.wrap(|| self.client.submit_and_await_commit(tx)).await
    }

    pub async fn submit(&self, tx: &Transaction) -> RequestResult<TransactionId> {
        self.wrap(|| self.client.submit(tx)).await
    }

    pub async fn transaction_status(&self, id: &TxId) -> RequestResult<TransactionStatus> {
        self.wrap(|| self.client.transaction_status(id)).await
    }

    pub async fn node_info(&self) -> RequestResult<NodeInfo> {
        self.wrap(|| self.client.node_info()).await
    }

    pub async fn blob(&self, blob_id: BlobId) -> RequestResult<Option<Blob>> {
        self.wrap(|| self.client.blob(blob_id)).await
    }

    pub async fn blob_exists(&self, blob_id: BlobId) -> RequestResult<bool> {
        self.wrap(|| self.client.blob_exists(blob_id)).await
    }

    pub async fn latest_gas_price(&self) -> RequestResult<LatestGasPrice> {
        self.wrap(|| self.client.latest_gas_price()).await
    }

    pub async fn estimate_gas_price(&self, block_horizon: u32) -> RequestResult<EstimateGasPrice> {
        self.wrap(|| self.client.estimate_gas_price(block_horizon))
            .await
            .map(Into::into)
    }

    pub async fn estimate_predicates(&self, tx: &Transaction) -> RequestResult<Transaction> {
        self.wrap(|| async {
            let mut new_tx = tx.clone();
            self.client.estimate_predicates(&mut new_tx).await?;
            Ok(new_tx)
        })
        .await
    }

    pub async fn dry_run(
        &self,
        tx: &[Transaction],
    ) -> RequestResult<Vec<TransactionExecutionStatus>> {
        self.wrap(|| self.client.dry_run(tx)).await
    }

    pub async fn dry_run_opt(
        &self,
        tx: &[Transaction],
        utxo_validation: Option<bool>,
        gas_price: Option<u64>,
    ) -> RequestResult<Vec<TransactionExecutionStatus>> {
        self.wrap(|| self.client.dry_run_opt(tx, utxo_validation, gas_price))
            .await
    }

    pub async fn coins(
        &self,
        owner: &Address,
        asset_id: Option<&AssetId>,
        request: PaginationRequest<String>,
    ) -> RequestResult<PaginatedResult<Coin, String>> {
        self.wrap(move || self.client.coins(owner, asset_id, request.clone()))
            .await
    }

    pub async fn coins_to_spend(
        &self,
        owner: &Address,
        spend_query: Vec<(AssetId, u64, Option<u32>)>,
        excluded_ids: Option<(Vec<UtxoId>, Vec<Nonce>)>,
    ) -> RequestResult<Vec<Vec<CoinType>>> {
        self.wrap(move || {
            self.client
                .coins_to_spend(owner, spend_query.clone(), excluded_ids.clone())
        })
        .await
    }

    pub async fn balance(&self, owner: &Address, asset_id: Option<&AssetId>) -> RequestResult<u64> {
        self.wrap(|| self.client.balance(owner, asset_id)).await
    }

    pub async fn contract_balance(
        &self,
        id: &ContractId,
        asset: Option<&AssetId>,
    ) -> RequestResult<u64> {
        self.wrap(|| self.client.contract_balance(id, asset)).await
    }

    pub async fn contract_balances(
        &self,
        contract: &ContractId,
        request: PaginationRequest<String>,
    ) -> RequestResult<PaginatedResult<ContractBalance, String>> {
        self.wrap(|| self.client.contract_balances(contract, request.clone()))
            .await
    }

    pub async fn balances(
        &self,
        owner: &Address,
        request: PaginationRequest<String>,
    ) -> RequestResult<PaginatedResult<Balance, String>> {
        self.wrap(|| self.client.balances(owner, request.clone()))
            .await
    }

    pub async fn transactions(
        &self,
        request: PaginationRequest<String>,
    ) -> RequestResult<PaginatedResult<TransactionResponse, String>> {
        self.wrap(|| self.client.transactions(request.clone()))
            .await
    }

    pub async fn transactions_by_owner(
        &self,
        owner: &Address,
        request: PaginationRequest<String>,
    ) -> RequestResult<PaginatedResult<TransactionResponse, String>> {
        self.wrap(|| self.client.transactions_by_owner(owner, request.clone()))
            .await
    }

    pub async fn produce_blocks(
        &self,
        blocks_to_produce: u32,
        start_timestamp: Option<u64>,
    ) -> RequestResult<BlockHeight> {
        self.wrap(|| {
            self.client
                .produce_blocks(blocks_to_produce, start_timestamp)
        })
        .await
    }

    pub async fn block(&self, id: &BlockId) -> RequestResult<Option<Block>> {
        self.wrap(|| self.client.block(id)).await
    }

    pub async fn block_by_height(&self, height: BlockHeight) -> RequestResult<Option<Block>> {
        self.wrap(|| self.client.block_by_height(height)).await
    }

    pub async fn blocks(
        &self,
        request: PaginationRequest<String>,
    ) -> RequestResult<PaginatedResult<Block, String>> {
        self.wrap(|| self.client.blocks(request.clone())).await
    }

    pub async fn messages(
        &self,
        owner: Option<&Address>,
        request: PaginationRequest<String>,
    ) -> RequestResult<PaginatedResult<Message, String>> {
        self.wrap(|| self.client.messages(owner, request.clone()))
            .await
    }

    /// Request a merkle proof of an output message.
    pub async fn message_proof(
        &self,
        transaction_id: &TxId,
        nonce: &Nonce,
        commit_block_id: Option<&BlockId>,
        commit_block_height: Option<BlockHeight>,
    ) -> RequestResult<MessageProof> {
        self.wrap(|| {
            self.client
                .message_proof(transaction_id, nonce, commit_block_id, commit_block_height)
        })
        .await
    }

    pub async fn contract_exists(&self, contract_id: &ContractId) -> RequestResult<bool> {
        self.wrap(|| {
            let query = ContractExistsQuery::build(ContractByIdArgs {
                id: (*contract_id).into(),
            });
            self.client.query(query)
        })
        .await
        .map(|query| {
            query
                .contract
                .map(|contract| ContractId::from(contract.id) == *contract_id)
                .unwrap_or(false)
        })
    }
    // DELEGATION END

    pub async fn is_user_account(&self, address: [u8; 32]) -> Result<bool> {
        let blob_id = BlobId::from(address);
        let contract_id = ContractId::from(address);
        let transaction_id = TransactionId::from(address);

        let query = IsUserAccountQuery::build(IsUserAccountVariables {
            blob_id: blob_id.into(),
            contract_id: contract_id.into(),
            transaction_id: transaction_id.into(),
        });

        let response = self.client.query(query).await?;

        let is_resource = response.blob.is_some()
            || response.contract.is_some()
            || response.transaction.is_some();

        Ok(!is_resource)
    }
}

mod custom_queries {
    use fuel_core_client::client::schema::blob::BlobIdFragment;
    use fuel_core_client::client::schema::schema;
    use fuel_core_client::client::schema::{
        contract::{ContractByIdArgsFields, ContractIdFragment},
        tx::TransactionIdFragment,
        BlobId, ContractId, TransactionId,
    };

    #[derive(cynic::QueryVariables, Debug)]
    pub struct IsUserAccountVariables {
        pub blob_id: BlobId,
        pub contract_id: ContractId,
        pub transaction_id: TransactionId,
    }

    #[derive(cynic::QueryFragment, Debug)]
    #[cynic(
        graphql_type = "Query",
        variables = "IsUserAccountVariables",
        schema_path = "./src/schema/schema.sdl"
    )]
    pub struct IsUserAccountQuery {
        #[arguments(id: $blob_id)]
        pub blob: Option<BlobIdFragment>,
        #[arguments(id: $contract_id)]
        pub contract: Option<ContractIdFragment>,
        #[arguments(id: $transaction_id)]
        pub transaction: Option<TransactionIdFragment>,
    }

    #[derive(cynic::QueryFragment, Clone, Debug)]
    #[cynic(
        schema_path = "./src/schema/schema.sdl",
        graphql_type = "Query",
        variables = "ContractByIdArgs"
    )]
    pub struct ContractExistsQuery {
        #[arguments(id: $id)]
        pub contract: Option<ContractIdFragment>,
    }
}

================
File: src/provider/supported_fuel_core_version.rs
================
pub const SUPPORTED_FUEL_CORE_VERSION: semver::Version = semver::Version::new(0, 41, 7);

================
File: src/provider/supported_versions.rs
================
use semver::Version;

use crate::provider::supported_fuel_core_version::SUPPORTED_FUEL_CORE_VERSION;

#[derive(Debug, PartialEq, Eq)]
pub(crate) struct VersionCompatibility {
    pub(crate) supported_version: Version,
    pub(crate) is_major_supported: bool,
    pub(crate) is_minor_supported: bool,
    pub(crate) is_patch_supported: bool,
}

pub(crate) fn compare_node_compatibility(network_version: Version) -> VersionCompatibility {
    check_version_compatibility(network_version, SUPPORTED_FUEL_CORE_VERSION)
}

fn check_version_compatibility(
    actual_version: Version,
    expected_version: Version,
) -> VersionCompatibility {
    let is_major_supported = expected_version.major == actual_version.major;
    let is_minor_supported = expected_version.minor == actual_version.minor;
    let is_patch_supported = expected_version.patch == actual_version.patch;

    VersionCompatibility {
        supported_version: expected_version,
        is_major_supported,
        is_minor_supported,
        is_patch_supported,
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn should_validate_all_possible_version_mismatches() {
        let expected_version = "0.1.2".parse::<Version>().unwrap();

        assert_eq!(
            check_version_compatibility("1.1.2".parse().unwrap(), expected_version.clone()),
            VersionCompatibility {
                is_major_supported: false,
                is_minor_supported: true,
                is_patch_supported: true,
                supported_version: expected_version.clone()
            }
        );

        assert_eq!(
            check_version_compatibility("1.2.2".parse().unwrap(), expected_version.clone()),
            VersionCompatibility {
                is_major_supported: false,
                is_minor_supported: false,
                is_patch_supported: true,
                supported_version: expected_version.clone()
            }
        );

        assert_eq!(
            check_version_compatibility("1.1.3".parse().unwrap(), expected_version.clone()),
            VersionCompatibility {
                is_major_supported: false,
                is_minor_supported: true,
                is_patch_supported: false,
                supported_version: expected_version.clone()
            }
        );

        assert_eq!(
            check_version_compatibility("0.2.2".parse().unwrap(), expected_version.clone()),
            VersionCompatibility {
                is_major_supported: true,
                is_minor_supported: false,
                is_patch_supported: true,
                supported_version: expected_version.clone()
            }
        );

        assert_eq!(
            check_version_compatibility("0.2.3".parse().unwrap(), expected_version.clone()),
            VersionCompatibility {
                is_major_supported: true,
                is_minor_supported: false,
                is_patch_supported: false,
                supported_version: expected_version.clone()
            }
        );

        assert_eq!(
            check_version_compatibility("0.1.3".parse().unwrap(), expected_version.clone()),
            VersionCompatibility {
                is_major_supported: true,
                is_minor_supported: true,
                is_patch_supported: false,
                supported_version: expected_version.clone()
            }
        );

        assert_eq!(
            check_version_compatibility("0.1.2".parse().unwrap(), expected_version.clone()),
            VersionCompatibility {
                is_major_supported: true,
                is_minor_supported: true,
                is_patch_supported: true,
                supported_version: expected_version.clone()
            }
        );
    }
}

================
File: src/schema/schema.sdl
================
scalar Address

scalar AssetId

type AssetInfoDetails {
	contractId: ContractId!
	subId: SubId!
	totalSupply: U128!
}

type Balance {
	owner: Address!
	amount: U64!
	amountU128: U128!
	assetId: AssetId!
}

type BalanceConnection {
	"""
	Information to aid in pagination.
	"""
	pageInfo: PageInfo!
	"""
	A list of edges.
	"""
	edges: [BalanceEdge!]!
	"""
	A list of nodes.
	"""
	nodes: [Balance!]!
}

"""
An edge in a connection.
"""
type BalanceEdge {
	"""
	The item at the end of the edge
	"""
	node: Balance!
	"""
	A cursor for use in pagination
	"""
	cursor: String!
}

input BalanceFilterInput {
	"""
	Filter coins based on the `owner` field
	"""
	owner: Address!
}

type Blob {
	id: BlobId!
	bytecode: HexString!
}

scalar BlobId

type Block {
	version: BlockVersion!
	id: BlockId!
	height: U32!
	header: Header!
	consensus: Consensus!
	transactionIds: [TransactionId!]!
	transactions: [Transaction!]!
}

type BlockConnection {
	"""
	Information to aid in pagination.
	"""
	pageInfo: PageInfo!
	"""
	A list of edges.
	"""
	edges: [BlockEdge!]!
	"""
	A list of nodes.
	"""
	nodes: [Block!]!
}

"""
An edge in a connection.
"""
type BlockEdge {
	"""
	The item at the end of the edge
	"""
	node: Block!
	"""
	A cursor for use in pagination
	"""
	cursor: String!
}

scalar BlockId

enum BlockVersion {
	V1
}


"""
Breakpoint, defined as a tuple of contract ID and relative PC offset inside it
"""
input Breakpoint {
	contract: ContractId!
	pc: U64!
}

scalar Bytes32

type ChainInfo {
	name: String!
	latestBlock: Block!
	daHeight: U64!
	consensusParameters: ConsensusParameters!
	gasCosts: GasCosts!
}

type ChangeOutput {
	to: Address!
	amount: U64!
	assetId: AssetId!
}

type Coin {
	utxoId: UtxoId!
	owner: Address!
	amount: U64!
	assetId: AssetId!
	"""
	TxPointer - the height of the block this coin was created in
	"""
	blockCreated: U32!
	"""
	TxPointer - the index of the transaction that created this coin
	"""
	txCreatedIdx: U16!
}

type CoinConnection {
	"""
	Information to aid in pagination.
	"""
	pageInfo: PageInfo!
	"""
	A list of edges.
	"""
	edges: [CoinEdge!]!
	"""
	A list of nodes.
	"""
	nodes: [Coin!]!
}

"""
An edge in a connection.
"""
type CoinEdge {
	"""
	The item at the end of the edge
	"""
	node: Coin!
	"""
	A cursor for use in pagination
	"""
	cursor: String!
}

input CoinFilterInput {
	"""
	Returns coins owned by the `owner`.
	"""
	owner: Address!
	"""
	Returns coins only with `asset_id`.
	"""
	assetId: AssetId
}

type CoinOutput {
	to: Address!
	amount: U64!
	assetId: AssetId!
}

"""
The schema analog of the [`coins::CoinType`].
"""
union CoinType = Coin | MessageCoin

union Consensus = Genesis | PoAConsensus

type ConsensusParameters {
	version: ConsensusParametersVersion!
	txParams: TxParameters!
	predicateParams: PredicateParameters!
	scriptParams: ScriptParameters!
	contractParams: ContractParameters!
	feeParams: FeeParameters!
	baseAssetId: AssetId!
	blockGasLimit: U64!
	blockTransactionSizeLimit: U64!
	chainId: U64!
	gasCosts: GasCosts!
	privilegedAddress: Address!
}

type ConsensusParametersPurpose {
	witnessIndex: U16!
	checksum: Bytes32!
}

enum ConsensusParametersVersion {
	V1
}

type Contract {
	id: ContractId!
	bytecode: HexString!
	salt: Salt!
}

type ContractBalance {
	contract: ContractId!
	amount: U64!
	assetId: AssetId!
}

type ContractBalanceConnection {
	"""
	Information to aid in pagination.
	"""
	pageInfo: PageInfo!
	"""
	A list of edges.
	"""
	edges: [ContractBalanceEdge!]!
	"""
	A list of nodes.
	"""
	nodes: [ContractBalance!]!
}

"""
An edge in a connection.
"""
type ContractBalanceEdge {
	"""
	The item at the end of the edge
	"""
	node: ContractBalance!
	"""
	A cursor for use in pagination
	"""
	cursor: String!
}

input ContractBalanceFilterInput {
	"""
	Filter assets based on the `contractId` field
	"""
	contract: ContractId!
}

type ContractCreated {
	contract: ContractId!
	stateRoot: Bytes32!
}

scalar ContractId

type ContractOutput {
	inputIndex: U16!
	balanceRoot: Bytes32!
	stateRoot: Bytes32!
}

type ContractParameters {
	version: ContractParametersVersion!
	contractMaxSize: U64!
	maxStorageSlots: U64!
}

enum ContractParametersVersion {
	V1
}

type DaCompressedBlock {
	bytes: HexString!
}

union DependentCost = LightOperation | HeavyOperation

type DryRunFailureStatus {
	programState: ProgramState
	reason: String!
	receipts: [Receipt!]!
	totalGas: U64!
	totalFee: U64!
}

type DryRunSuccessStatus {
	programState: ProgramState
	receipts: [Receipt!]!
	totalGas: U64!
	totalFee: U64!
}

type DryRunTransactionExecutionStatus {
	id: TransactionId!
	status: DryRunTransactionStatus!
	receipts: [Receipt!]!
}

union DryRunTransactionStatus = DryRunSuccessStatus | DryRunFailureStatus

type EstimateGasPrice {
	gasPrice: U64!
}

input ExcludeInput {
	"""
	Utxos to exclude from the selection.
	"""
	utxos: [UtxoId!]!
	"""
	Messages to exclude from the selection.
	"""
	messages: [Nonce!]!
}

type FailureStatus {
	transactionId: TransactionId!
	blockHeight: U32!
	block: Block!
	transaction: Transaction!
	time: Tai64Timestamp!
	reason: String!
	programState: ProgramState
	receipts: [Receipt!]!
	totalGas: U64!
	totalFee: U64!
}

type FeeParameters {
	version: FeeParametersVersion!
	gasPriceFactor: U64!
	gasPerByte: U64!
}

enum FeeParametersVersion {
	V1
}


type GasCosts {
	version: GasCostsVersion!
	add: U64!
	addi: U64!
	aloc: U64!
	and: U64!
	andi: U64!
	bal: U64!
	bhei: U64!
	bhsh: U64!
	burn: U64!
	cb: U64!
	cfei: U64!
	cfsi: U64!
	div: U64!
	divi: U64!
	ecr1: U64!
	eck1: U64!
	ed19: U64!
	eq: U64!
	exp: U64!
	expi: U64!
	flag: U64!
	gm: U64!
	gt: U64!
	gtf: U64!
	ji: U64!
	jmp: U64!
	jne: U64!
	jnei: U64!
	jnzi: U64!
	jmpf: U64!
	jmpb: U64!
	jnzf: U64!
	jnzb: U64!
	jnef: U64!
	jneb: U64!
	lb: U64!
	log: U64!
	lt: U64!
	lw: U64!
	mint: U64!
	mlog: U64!
	modOp: U64!
	modi: U64!
	moveOp: U64!
	movi: U64!
	mroo: U64!
	mul: U64!
	muli: U64!
	mldv: U64!
	noop: U64!
	not: U64!
	or: U64!
	ori: U64!
	poph: U64!
	popl: U64!
	pshh: U64!
	pshl: U64!
	ret: U64!
	rvrt: U64!
	sb: U64!
	sll: U64!
	slli: U64!
	srl: U64!
	srli: U64!
	srw: U64!
	sub: U64!
	subi: U64!
	sw: U64!
	sww: U64!
	time: U64!
	tr: U64!
	tro: U64!
	wdcm: U64!
	wqcm: U64!
	wdop: U64!
	wqop: U64!
	wdml: U64!
	wqml: U64!
	wddv: U64!
	wqdv: U64!
	wdmd: U64!
	wqmd: U64!
	wdam: U64!
	wqam: U64!
	wdmm: U64!
	wqmm: U64!
	xor: U64!
	xori: U64!
	ecop: U64
	alocDependentCost: DependentCost!
	bldd: DependentCost
	bsiz: DependentCost
	cfe: DependentCost!
	cfeiDependentCost: DependentCost!
	call: DependentCost!
	ccp: DependentCost!
	croo: DependentCost!
	csiz: DependentCost!
	ed19DependentCost: DependentCost!
	k256: DependentCost!
	ldc: DependentCost!
	logd: DependentCost!
	mcl: DependentCost!
	mcli: DependentCost!
	mcp: DependentCost!
	mcpi: DependentCost!
	meq: DependentCost!
	retd: DependentCost!
	s256: DependentCost!
	scwq: DependentCost!
	smo: DependentCost!
	srwq: DependentCost!
	swwq: DependentCost!
	epar: DependentCost
	contractRoot: DependentCost!
	stateRoot: DependentCost!
	vmInitialization: DependentCost!
	newStoragePerByte: U64!
}

enum GasCostsVersion {
	V1
}

type Genesis {
	"""
	The chain configs define what consensus type to use, what settlement layer to use,
	rules of block validity, etc.
	"""
	chainConfigHash: Bytes32!
	"""
	The Binary Merkle Tree root of all genesis coins.
	"""
	coinsRoot: Bytes32!
	"""
	The Binary Merkle Tree root of state, balances, contracts code hash of each contract.
	"""
	contractsRoot: Bytes32!
	"""
	The Binary Merkle Tree root of all genesis messages.
	"""
	messagesRoot: Bytes32!
	"""
	The Binary Merkle Tree root of all processed transaction ids.
	"""
	transactionsRoot: Bytes32!
}

type Header {
	"""
	Version of the header
	"""
	version: HeaderVersion!
	"""
	Hash of the header
	"""
	id: BlockId!
	"""
	The layer 1 height of messages and events to include since the last layer 1 block number.
	"""
	daHeight: U64!
	"""
	The version of the consensus parameters used to create this block.
	"""
	consensusParametersVersion: U32!
	"""
	The version of the state transition bytecode used to create this block.
	"""
	stateTransitionBytecodeVersion: U32!
	"""
	Number of transactions in this block.
	"""
	transactionsCount: U16!
	"""
	Number of message receipts in this block.
	"""
	messageReceiptCount: U32!
	"""
	Merkle root of transactions.
	"""
	transactionsRoot: Bytes32!
	"""
	Merkle root of message receipts in this block.
	"""
	messageOutboxRoot: Bytes32!
	"""
	Merkle root of inbox events in this block.
	"""
	eventInboxRoot: Bytes32!
	"""
	Fuel block height.
	"""
	height: U32!
	"""
	Merkle root of all previous block header hashes.
	"""
	prevRoot: Bytes32!
	"""
	The block producer time.
	"""
	time: Tai64Timestamp!
	"""
	Hash of the application header.
	"""
	applicationHash: Bytes32!
}

enum HeaderVersion {
	V1
}

type HeavyOperation {
	base: U64!
	gasPerUnit: U64!
}

scalar HexString


type IndexationFlags {
	"""
	Is balances indexation enabled
	"""
	balances: Boolean!
	"""
	Is coins to spend indexation enabled
	"""
	coinsToSpend: Boolean!
	"""
	Is asset metadata indexation enabled
	"""
	assetMetadata: Boolean!
}

union Input = InputCoin | InputContract | InputMessage

type InputCoin {
	utxoId: UtxoId!
	owner: Address!
	amount: U64!
	assetId: AssetId!
	txPointer: TxPointer!
	witnessIndex: Int!
	predicateGasUsed: U64!
	predicate: HexString!
	predicateData: HexString!
}

type InputContract {
	utxoId: UtxoId!
	balanceRoot: Bytes32!
	stateRoot: Bytes32!
	txPointer: TxPointer!
	contractId: ContractId!
}

type InputMessage {
	sender: Address!
	recipient: Address!
	amount: U64!
	nonce: Nonce!
	witnessIndex: U16!
	predicateGasUsed: U64!
	data: HexString!
	predicate: HexString!
	predicateData: HexString!
}


type LatestGasPrice {
	gasPrice: U64!
	blockHeight: U32!
}

type LightOperation {
	base: U64!
	unitsPerGas: U64!
}

type MerkleProof {
	proofSet: [Bytes32!]!
	proofIndex: U64!
}

type Message {
	amount: U64!
	sender: Address!
	recipient: Address!
	nonce: Nonce!
	data: HexString!
	daHeight: U64!
}

type MessageCoin {
	sender: Address!
	recipient: Address!
	nonce: Nonce!
	amount: U64!
	assetId: AssetId!
	daHeight: U64!
}

type MessageConnection {
	"""
	Information to aid in pagination.
	"""
	pageInfo: PageInfo!
	"""
	A list of edges.
	"""
	edges: [MessageEdge!]!
	"""
	A list of nodes.
	"""
	nodes: [Message!]!
}

"""
An edge in a connection.
"""
type MessageEdge {
	"""
	The item at the end of the edge
	"""
	node: Message!
	"""
	A cursor for use in pagination
	"""
	cursor: String!
}

type MessageProof {
	messageProof: MerkleProof!
	blockProof: MerkleProof!
	messageBlockHeader: Header!
	commitBlockHeader: Header!
	sender: Address!
	recipient: Address!
	nonce: Nonce!
	amount: U64!
	data: HexString!
}

enum MessageState {
	UNSPENT
	SPENT
	NOT_FOUND
}

type MessageStatus {
	state: MessageState!
}

type Mutation {
	"""
	Initialize a new debugger session, returning its ID.
	A new VM instance is spawned for each session.
	The session is run in a separate database transaction,
	on top of the most recent node state.
	"""
	startSession: ID!
	"""
	End debugger session.
	"""
	endSession(id: ID!): Boolean!
	"""
	Reset the VM instance to the initial state.
	"""
	reset(id: ID!): Boolean!
	"""
	Execute a single fuel-asm instruction.
	"""
	execute(id: ID!, op: String!): Boolean!
	"""
	Set single-stepping mode for the VM instance.
	"""
	setSingleStepping(id: ID!, enable: Boolean!): Boolean!
	"""
	Set a breakpoint for a VM instance.
	"""
	setBreakpoint(id: ID!, breakpoint: Breakpoint!): Boolean!
	"""
	Run a single transaction in given session until it
	hits a breakpoint or completes.
	"""
	startTx(id: ID!, txJson: String!): RunResult!
	"""
	Resume execution of the VM instance after a breakpoint.
	Runs until the next breakpoint or until the transaction completes.
	"""
	continueTx(id: ID!): RunResult!
	"""
	Execute a dry-run of multiple transactions using a fork of current state, no changes are committed.
	"""
	dryRun(txs: [HexString!]!, utxoValidation: Boolean, gasPrice: U64): [DryRunTransactionExecutionStatus!]!
	"""
	Submits transaction to the `TxPool`.
	
	Returns submitted transaction if the transaction is included in the `TxPool` without problems.
	"""
	submit(tx: HexString!): Transaction!
	"""
	Sequentially produces `blocks_to_produce` blocks. The first block starts with
	`start_timestamp`. If the block production in the [`crate::service::Config`] is
	`Trigger::Interval { block_time }`, produces blocks with `block_time ` intervals between
	them. The `start_timestamp` is the timestamp in seconds.
	"""
	produceBlocks(startTimestamp: Tai64Timestamp, blocksToProduce: U32!): U32!
}

type NodeInfo {
	utxoValidation: Boolean!
	vmBacktrace: Boolean!
	maxTx: U64!
	maxGas: U64!
	maxSize: U64!
	maxDepth: U64!
	nodeVersion: String!
	indexation: IndexationFlags!
	txPoolStats: TxPoolStats!
	peers: [PeerInfo!]!
}

scalar Nonce

union Output = CoinOutput | ContractOutput | ChangeOutput | VariableOutput | ContractCreated

"""
A separate `Breakpoint` type to be used as an output, as a single
type cannot act as both input and output type in async-graphql
"""
type OutputBreakpoint {
	contract: ContractId!
	pc: U64!
}

"""
Information about pagination in a connection
"""
type PageInfo {
	"""
	When paginating backwards, are there more items?
	"""
	hasPreviousPage: Boolean!
	"""
	When paginating forwards, are there more items?
	"""
	hasNextPage: Boolean!
	"""
	When paginating backwards, the cursor to continue.
	"""
	startCursor: String
	"""
	When paginating forwards, the cursor to continue.
	"""
	endCursor: String
}

type PeerInfo {
	"""
	The libp2p peer id
	"""
	id: String!
	"""
	The advertised multi-addrs that can be used to connect to this peer
	"""
	addresses: [String!]!
	"""
	The self-reported version of the client the peer is using
	"""
	clientVersion: String
	"""
	The last reported height of the peer
	"""
	blockHeight: U32
	"""
	The last heartbeat from this peer in unix epoch time ms
	"""
	lastHeartbeatMs: U64!
	"""
	The internal fuel p2p reputation of this peer
	"""
	appScore: Float!
}

type PoAConsensus {
	"""
	Gets the signature of the block produced by `PoA` consensus.
	"""
	signature: Signature!
}

type Policies {
	tip: U64
	witnessLimit: U64
	maturity: U32
	maxFee: U64
}

type PredicateParameters {
	version: PredicateParametersVersion!
	maxPredicateLength: U64!
	maxPredicateDataLength: U64!
	maxGasPerPredicate: U64!
	maxMessageDataLength: U64!
}

enum PredicateParametersVersion {
	V1
}

type ProgramState {
	returnType: ReturnType!
	data: HexString!
}

type Query {
	assetDetails(
		"""
		ID of the Asset
		"""
		id: AssetId!
	): AssetInfoDetails!
	"""
	Read register value by index.
	"""
	register(id: ID!, register: U32!): U64!
	"""
	Read read a range of memory bytes.
	"""
	memory(id: ID!, start: U32!, size: U32!): String!
	balance(
		"""
		address of the owner
		"""
		owner: Address!,
		"""
		asset_id of the coin
		"""
		assetId: AssetId!
	): Balance!
	balances(filter: BalanceFilterInput!, first: Int, after: String, last: Int, before: String): BalanceConnection!
	blob(
		"""
		ID of the Blob
		"""
		id: BlobId!
	): Blob
	block(
		"""
		ID of the block
		"""
		id: BlockId,
		"""
		Height of the block
		"""
		height: U32
	): Block
	blocks(first: Int, after: String, last: Int, before: String): BlockConnection!
	chain: ChainInfo!
	transaction(
		"""
		The ID of the transaction
		"""
		id: TransactionId!
	): Transaction
	transactions(first: Int, after: String, last: Int, before: String): TransactionConnection!
	transactionsByOwner(owner: Address!, first: Int, after: String, last: Int, before: String): TransactionConnection!
	"""
	Estimate the predicate gas for the provided transaction
	"""
	estimatePredicates(tx: HexString!): Transaction!
	"""
	Returns all possible receipts for test purposes.
	"""
	allReceipts: [Receipt!]!
	"""
	Returns true when the GraphQL API is serving requests.
	"""
	health: Boolean!
	"""
	Gets the coin by `utxo_id`.
	"""
	coin(
		"""
		The ID of the coin
		"""
		utxoId: UtxoId!
	): Coin
	"""
	Gets all unspent coins of some `owner` maybe filtered with by `asset_id` per page.
	"""
	coins(filter: CoinFilterInput!, first: Int, after: String, last: Int, before: String): CoinConnection!
	"""
	For each `query_per_asset`, get some spendable coins(of asset specified by the query) owned by
	`owner` that add up at least the query amount. The returned coins can be spent.
	The number of coins is optimized to prevent dust accumulation.
	
	The query supports excluding and maximum the number of coins.
	
	Returns:
	The list of spendable coins per asset from the query. The length of the result is
	the same as the length of `query_per_asset`. The ordering of assets and `query_per_asset`
	is the same.
	"""
	coinsToSpend(
		"""
		The `Address` of the coins owner.
		"""
		owner: Address!,
		"""
		The list of requested assets` coins with asset ids, `target` amount the user wants to reach, and the `max` number of coins in the selection. Several entries with the same asset id are not allowed. The result can't contain more coins than `max_inputs`.
		"""
		queryPerAsset: [SpendQueryElementInput!]!,
		"""
		The excluded coins from the selection.
		"""
		excludedIds: ExcludeInput
	): [[CoinType!]!]!
	daCompressedBlock(
		"""
		Height of the block
		"""
		height: U32!
	): DaCompressedBlock
	contract(
		"""
		ID of the Contract
		"""
		id: ContractId!
	): Contract
	contractBalance(contract: ContractId!, asset: AssetId!): ContractBalance!
	contractBalances(filter: ContractBalanceFilterInput!, first: Int, after: String, last: Int, before: String): ContractBalanceConnection!
	nodeInfo: NodeInfo!
	latestGasPrice: LatestGasPrice!
	estimateGasPrice(
		"""
		Number of blocks into the future to estimate the gas price for
		"""
		blockHorizon: U32
	): EstimateGasPrice!
	message(
		"""
		The Nonce of the message
		"""
		nonce: Nonce!
	): Message
	messages(
		"""
		address of the owner
		"""
		owner: Address,		first: Int,		after: String,		last: Int,		before: String
	): MessageConnection!
	messageProof(transactionId: TransactionId!, nonce: Nonce!, commitBlockId: BlockId, commitBlockHeight: U32): MessageProof!
	messageStatus(nonce: Nonce!): MessageStatus!
	relayedTransactionStatus(
		"""
		The id of the relayed tx
		"""
		id: RelayedTransactionId!
	): RelayedTransactionStatus
	consensusParameters(version: Int!): ConsensusParameters!
	stateTransitionBytecodeByVersion(version: Int!): StateTransitionBytecode
	stateTransitionBytecodeByRoot(root: HexString!): StateTransitionBytecode!
}

type Receipt {
	id: ContractId
	pc: U64
	is: U64
	to: ContractId
	toAddress: Address
	amount: U64
	assetId: AssetId
	gas: U64
	param1: U64
	param2: U64
	val: U64
	ptr: U64
	digest: Bytes32
	reason: U64
	ra: U64
	rb: U64
	rc: U64
	rd: U64
	len: U64
	receiptType: ReceiptType!
	result: U64
	gasUsed: U64
	data: HexString
	sender: Address
	recipient: Address
	nonce: Nonce
	"""
	Set in the case of a Panic receipt to indicate a missing contract input id
	"""
	contractId: ContractId
	subId: Bytes32
}

enum ReceiptType {
	CALL
	RETURN
	RETURN_DATA
	PANIC
	REVERT
	LOG
	LOG_DATA
	TRANSFER
	TRANSFER_OUT
	SCRIPT_RESULT
	MESSAGE_OUT
	MINT
	BURN
}

type RelayedTransactionFailed {
	blockHeight: U32!
	failure: String!
}

scalar RelayedTransactionId

union RelayedTransactionStatus = RelayedTransactionFailed

enum ReturnType {
	RETURN
	RETURN_DATA
	REVERT
}

type RunResult {
	state: RunState!
	breakpoint: OutputBreakpoint
	jsonReceipts: [String!]!
}

enum RunState {
	"""
	All breakpoints have been processed, and the program has terminated
	"""
	COMPLETED
	"""
	Stopped on a breakpoint
	"""
	BREAKPOINT
}

scalar Salt

type ScriptParameters {
	version: ScriptParametersVersion!
	maxScriptLength: U64!
	maxScriptDataLength: U64!
}

enum ScriptParametersVersion {
	V1
}

scalar Signature

input SpendQueryElementInput {
	"""
	Identifier of the asset to spend.
	"""
	assetId: AssetId!
	"""
	Target amount for the query.
	"""
	amount: U64!
	"""
	The maximum number of currencies for selection.
	"""
	max: U32
}

type SqueezedOutStatus {
	reason: String!
}

type StateTransitionBytecode {
	root: HexString!
	bytecode: UploadedBytecode!
}

type StateTransitionPurpose {
	root: Bytes32!
}


scalar SubId

type SubmittedStatus {
	time: Tai64Timestamp!
}

type Subscription {
	"""
	Returns a stream of status updates for the given transaction id.
	If the current status is [`TransactionStatus::Success`], [`TransactionStatus::SqueezedOut`]
	or [`TransactionStatus::Failed`] the stream will return that and end immediately.
	If the current status is [`TransactionStatus::Submitted`] this will be returned
	and the stream will wait for a future update.
	
	This stream will wait forever so it's advised to use within a timeout.
	
	It is possible for the stream to miss an update if it is polled slower
	then the updates arrive. In such a case the stream will close without
	a status. If this occurs the stream can simply be restarted to return
	the latest status.
	"""
	statusChange(
		"""
		The ID of the transaction
		"""
		id: TransactionId!
	): TransactionStatus!
	"""
	Submits transaction to the `TxPool` and await either confirmation or failure.
	"""
	submitAndAwait(tx: HexString!): TransactionStatus!
	"""
	Submits the transaction to the `TxPool` and returns a stream of events.
	Compared to the `submitAndAwait`, the stream also contains `
	SubmittedStatus` as an intermediate state.
	"""
	submitAndAwaitStatus(tx: HexString!): TransactionStatus!
}

type SuccessStatus {
	transactionId: TransactionId!
	blockHeight: U32!
	block: Block!
	transaction: Transaction!
	time: Tai64Timestamp!
	programState: ProgramState
	receipts: [Receipt!]!
	totalGas: U64!
	totalFee: U64!
}

scalar Tai64Timestamp

type Transaction {
	id: TransactionId!
	inputAssetIds: [AssetId!]
	inputContracts: [ContractId!]
	inputContract: InputContract
	policies: Policies
	scriptGasLimit: U64
	maturity: U32
	mintAmount: U64
	mintAssetId: AssetId
	mintGasPrice: U64
	txPointer: TxPointer
	isScript: Boolean!
	isCreate: Boolean!
	isMint: Boolean!
	isUpgrade: Boolean!
	isUpload: Boolean!
	isBlob: Boolean!
	inputs: [Input!]
	outputs: [Output!]!
	outputContract: ContractOutput
	witnesses: [HexString!]
	receiptsRoot: Bytes32
	status: TransactionStatus
	script: HexString
	scriptData: HexString
	bytecodeWitnessIndex: U16
	blobId: BlobId
	salt: Salt
	storageSlots: [HexString!]
	bytecodeRoot: Bytes32
	subsectionIndex: U16
	subsectionsNumber: U16
	proofSet: [Bytes32!]
	upgradePurpose: UpgradePurpose
	"""
	Return the transaction bytes using canonical encoding
	"""
	rawPayload: HexString!
}

type TransactionConnection {
	"""
	Information to aid in pagination.
	"""
	pageInfo: PageInfo!
	"""
	A list of edges.
	"""
	edges: [TransactionEdge!]!
	"""
	A list of nodes.
	"""
	nodes: [Transaction!]!
}

"""
An edge in a connection.
"""
type TransactionEdge {
	"""
	The item at the end of the edge
	"""
	node: Transaction!
	"""
	A cursor for use in pagination
	"""
	cursor: String!
}

scalar TransactionId

union TransactionStatus = SubmittedStatus | SuccessStatus | SqueezedOutStatus | FailureStatus

type TxParameters {
	version: TxParametersVersion!
	maxInputs: U16!
	maxOutputs: U16!
	maxWitnesses: U32!
	maxGasPerTx: U64!
	maxSize: U64!
	maxBytecodeSubsections: U16!
}

enum TxParametersVersion {
	V1
}

scalar TxPointer

type TxPoolStats {
	"""
	The number of transactions in the pool
	"""
	txCount: U64!
	"""
	The total size of the transactions in the pool
	"""
	totalSize: U64!
	"""
	The total gas of the transactions in the pool
	"""
	totalGas: U64!
}

scalar U128

scalar U16

scalar U32

scalar U64

union UpgradePurpose = ConsensusParametersPurpose | StateTransitionPurpose

type UploadedBytecode {
	"""
	Combined bytecode of all uploaded subsections.
	"""
	bytecode: HexString!
	"""
	Number of uploaded subsections (if incomplete).
	"""
	uploadedSubsectionsNumber: Int
	"""
	Indicates if the bytecode upload is complete.
	"""
	completed: Boolean!
}

scalar UtxoId

type VariableOutput {
	to: Address!
	amount: U64!
	assetId: AssetId!
}

directive @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT
directive @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT
schema {
	query: Query
	mutation: Mutation
	subscription: Subscription
}

================
File: src/signers/aws_kms.rs
================
pub use aws_config;
pub use aws_sdk_kms;
use aws_sdk_kms::{
    primitives::Blob,
    types::{KeySpec, MessageType, SigningAlgorithmSpec},
    Client,
};
use fuel_crypto::{Message, PublicKey, Signature};
use fuels_core::{
    traits::{AddressResolver, Signer},
    types::{
        bech32::{Bech32Address, FUEL_BECH32_HRP},
        errors::{Error, Result},
    },
};
use k256::{
    ecdsa::{RecoveryId, Signature as K256Signature, VerifyingKey},
    pkcs8::DecodePublicKey,
    PublicKey as K256PublicKey,
};

const AWS_KMS_ERROR_PREFIX: &str = "AWS KMS Error";
const EXPECTED_KEY_SPEC: KeySpec = KeySpec::EccSecgP256K1;

#[derive(Clone, Debug)]
pub struct AwsKmsSigner {
    key_id: String,
    client: Client,
    public_key_der: Vec<u8>,
    fuel_address: Bech32Address,
}

impl AwsKmsSigner {
    pub fn key_id(&self) -> &String {
        &self.key_id
    }

    pub fn public_key(&self) -> &Vec<u8> {
        &self.public_key_der
    }

    pub fn fuel_address(&self) -> &Bech32Address {
        &self.fuel_address
    }

    /// Creates a new KmsKey from an AWS KMS key ID
    pub async fn new(key_id: String, client: &Client) -> Result<Self> {
        Self::validate_key_spec(client, &key_id).await?;
        let public_key = Self::retrieve_public_key(client, &key_id).await?;
        let fuel_address = Self::derive_fuel_address(&public_key)?;

        Ok(Self {
            key_id,
            client: client.clone(),
            public_key_der: public_key,
            fuel_address,
        })
    }

    /// Validates that the KMS key is of the expected type
    async fn validate_key_spec(client: &Client, key_id: &str) -> Result<()> {
        let response = client
            .get_public_key()
            .key_id(key_id)
            .send()
            .await
            .map_err(format_kms_error)?;

        let key_spec = response.key_spec;

        match key_spec {
            Some(EXPECTED_KEY_SPEC) => Ok(()),
            other => Err(Error::Other(format!(
                "{AWS_KMS_ERROR_PREFIX}: Invalid key type {other:?}, expected {EXPECTED_KEY_SPEC:?}"
            ))),
        }
    }

    /// Retrieves the public key from AWS KMS
    async fn retrieve_public_key(client: &Client, key_id: &str) -> Result<Vec<u8>> {
        let response = client
            .get_public_key()
            .key_id(key_id)
            .send()
            .await
            .map_err(format_kms_error)?;

        response
            .public_key()
            .map(|blob| blob.as_ref().to_vec())
            .ok_or_else(|| {
                Error::Other(format!("{AWS_KMS_ERROR_PREFIX}: Empty public key response"))
            })
    }

    /// Derives a Fuel address from a public key in DER format
    fn derive_fuel_address(public_key: &[u8]) -> Result<Bech32Address> {
        let k256_key = K256PublicKey::from_public_key_der(public_key)
            .map_err(|_| Error::Other(format!("{AWS_KMS_ERROR_PREFIX}: Invalid DER encoding")))?;

        let fuel_public_key = PublicKey::from(k256_key);
        Ok(Bech32Address::new(FUEL_BECH32_HRP, fuel_public_key.hash()))
    }

    /// Signs a message using the AWS KMS key
    async fn sign_message(&self, message: Message) -> Result<Signature> {
        let signature_der = self.request_kms_signature(message).await?;
        let (sig, recovery_id) = self.normalize_signature(&signature_der, message)?;

        Ok(self.convert_to_fuel_signature(sig, recovery_id))
    }

    /// Requests a signature from AWS KMS
    async fn request_kms_signature(&self, message: Message) -> Result<Vec<u8>> {
        let response = self
            .client
            .sign()
            .key_id(&self.key_id)
            .signing_algorithm(SigningAlgorithmSpec::EcdsaSha256)
            .message_type(MessageType::Digest)
            .message(Blob::new(message.as_ref().to_vec()))
            .send()
            .await
            .map_err(|err| {
                Error::Other(format!("{AWS_KMS_ERROR_PREFIX}: Signing failed - {err}"))
            })?;

        response
            .signature
            .map(|blob| blob.into_inner())
            .ok_or_else(|| {
                Error::Other(format!("{AWS_KMS_ERROR_PREFIX}: Empty signature response"))
            })
    }

    /// Normalizes a DER signature and determines the recovery ID
    fn normalize_signature(
        &self,
        signature_der: &[u8],
        message: Message,
    ) -> Result<(K256Signature, RecoveryId)> {
        let signature = K256Signature::from_der(signature_der)
            .map_err(|_| Error::Other(format!("{AWS_KMS_ERROR_PREFIX}: Invalid DER signature")))?;

        // Ensure the signature is in normalized form (low-S value)
        let normalized_sig = signature.normalize_s().unwrap_or(signature);
        let recovery_id = self.determine_recovery_id(&normalized_sig, message)?;

        Ok((normalized_sig, recovery_id))
    }

    /// Determines the correct recovery ID for the signature
    fn determine_recovery_id(&self, sig: &K256Signature, message: Message) -> Result<RecoveryId> {
        let recid_even = RecoveryId::new(false, false);
        let recid_odd = RecoveryId::new(true, false);

        // Get the expected public key
        let expected_pubkey = K256PublicKey::from_public_key_der(&self.public_key_der)
            .map_err(|_| {
                Error::Other(format!("{AWS_KMS_ERROR_PREFIX}: Invalid cached public key"))
            })?
            .into();

        // Try recovery with each recovery ID
        let recovered_even = VerifyingKey::recover_from_prehash(&*message, sig, recid_even);
        let recovered_odd = VerifyingKey::recover_from_prehash(&*message, sig, recid_odd);

        if recovered_even
            .map(|r| r == expected_pubkey)
            .unwrap_or(false)
        {
            Ok(recid_even)
        } else if recovered_odd.map(|r| r == expected_pubkey).unwrap_or(false) {
            Ok(recid_odd)
        } else {
            Err(Error::Other(format!(
                "{AWS_KMS_ERROR_PREFIX}: Invalid signature (could not recover correct public key)"
            )))
        }
    }

    /// Converts a k256 signature to a Fuel signature format
    fn convert_to_fuel_signature(
        &self,
        signature: K256Signature,
        recovery_id: RecoveryId,
    ) -> Signature {
        let recovery_byte = recovery_id.is_y_odd() as u8;
        let mut bytes: [u8; 64] = signature.to_bytes().into();
        bytes[32] = (recovery_byte << 7) | (bytes[32] & 0x7F);
        Signature::from_bytes(bytes)
    }

    pub fn address(&self) -> &Bech32Address {
        &self.fuel_address
    }
}

#[async_trait::async_trait]
impl Signer for AwsKmsSigner {
    async fn sign(&self, message: Message) -> Result<Signature> {
        self.sign_message(message).await
    }
}

impl AddressResolver for AwsKmsSigner {
    fn address(&self) -> &Bech32Address {
        self.fuel_address()
    }
}

fn format_kms_error(err: impl std::fmt::Display) -> Error {
    Error::Other(format!("{AWS_KMS_ERROR_PREFIX}: {err}"))
}

================
File: src/signers/fake.rs
================
use async_trait::async_trait;
use fuel_crypto::{Message, Signature};
use fuels_core::{
    traits::{AddressResolver, Signer},
    types::{bech32::Bech32Address, errors::Result},
};

use super::private_key::PrivateKeySigner;

#[derive(Clone, Debug, PartialEq, Eq)]
pub struct FakeSigner {
    address: Bech32Address,
}

impl From<PrivateKeySigner> for FakeSigner {
    fn from(signer: PrivateKeySigner) -> Self {
        Self {
            address: signer.address().clone(),
        }
    }
}

impl FakeSigner {
    pub fn new(address: Bech32Address) -> Self {
        Self { address }
    }
}

#[async_trait]
impl Signer for FakeSigner {
    async fn sign(&self, _message: Message) -> Result<Signature> {
        Ok(Signature::default())
    }
}

impl AddressResolver for FakeSigner {
    fn address(&self) -> &Bech32Address {
        &self.address
    }
}

================
File: src/signers/locked.rs
================
use fuels_core::{traits::AddressResolver, types::bech32::Bech32Address};

#[derive(Clone, Debug, PartialEq, Eq)]
pub struct Locked {
    address: Bech32Address,
}

impl Locked {
    pub fn new(address: Bech32Address) -> Self {
        Self { address }
    }
}

impl AddressResolver for Locked {
    fn address(&self) -> &Bech32Address {
        &self.address
    }
}

================
File: src/signers/private_key.rs
================
use async_trait::async_trait;
use fuel_crypto::{Message, PublicKey, SecretKey, Signature};
use fuels_core::{
    traits::{AddressResolver, Signer},
    types::{
        bech32::{Bech32Address, FUEL_BECH32_HRP},
        errors::Result,
    },
};
use rand::{CryptoRng, Rng, RngCore};
use zeroize::{Zeroize, ZeroizeOnDrop};

/// Generates a random mnemonic phrase given a random number generator and the number of words to
/// generate, `count`.
pub fn generate_mnemonic_phrase<R: Rng>(rng: &mut R, count: usize) -> Result<String> {
    Ok(fuel_crypto::generate_mnemonic_phrase(rng, count)?)
}

#[derive(Clone, Zeroize, ZeroizeOnDrop)]
pub struct PrivateKeySigner {
    private_key: SecretKey,
    #[zeroize(skip)]
    address: Bech32Address,
}

impl std::fmt::Debug for PrivateKeySigner {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("PrivateKeySigner")
            .field("private_key", &"REDACTED")
            .field("address", &self.address)
            .finish()
    }
}

impl PrivateKeySigner {
    pub fn new(private_key: SecretKey) -> Self {
        let public = PublicKey::from(&private_key);
        let hashed = public.hash();
        let address = Bech32Address::new(FUEL_BECH32_HRP, hashed);

        Self {
            private_key,
            address,
        }
    }

    pub fn random(rng: &mut (impl CryptoRng + RngCore)) -> Self {
        Self::new(SecretKey::random(rng))
    }

    pub fn address(&self) -> &Bech32Address {
        &self.address
    }
}

#[async_trait]
impl Signer for PrivateKeySigner {
    async fn sign(&self, message: Message) -> Result<Signature> {
        let sig = Signature::sign(&self.private_key, &message);

        Ok(sig)
    }
}

impl AddressResolver for PrivateKeySigner {
    fn address(&self) -> &Bech32Address {
        &self.address
    }
}
#[cfg(test)]
mod tests {
    use std::str::FromStr;

    use rand::{rngs::StdRng, SeedableRng};

    use super::*;
    use crate::signers::DEFAULT_DERIVATION_PATH;

    #[tokio::test]
    async fn mnemonic_generation() -> Result<()> {
        let mnemonic = generate_mnemonic_phrase(&mut rand::thread_rng(), 12)?;
        let _wallet = PrivateKeySigner::new(SecretKey::new_from_mnemonic_phrase_with_path(
            &mnemonic,
            DEFAULT_DERIVATION_PATH,
        )?);

        Ok(())
    }

    #[tokio::test]
    async fn sign_and_verify() -> Result<()> {
        // ANCHOR: sign_message
        let mut rng = StdRng::seed_from_u64(2322u64);
        let mut secret_seed = [0u8; 32];
        rng.fill_bytes(&mut secret_seed);

        let secret = secret_seed.as_slice().try_into()?;

        // Create a signer using the private key created above.
        let signer = PrivateKeySigner::new(secret);

        let message = Message::new("my message".as_bytes());
        let signature = signer.sign(message).await?;

        // Check if signature is what we expect it to be
        assert_eq!(signature, Signature::from_str("0x8eeb238db1adea4152644f1cd827b552dfa9ab3f4939718bb45ca476d167c6512a656f4d4c7356bfb9561b14448c230c6e7e4bd781df5ee9e5999faa6495163d")?);

        // Recover address that signed the message
        let recovered_address = signature.recover(&message)?;

        assert_eq!(signer.address().hash(), recovered_address.hash());

        // Verify signature
        signature.verify(&recovered_address, &message)?;
        // ANCHOR_END: sign_message

        Ok(())
    }
}

================
File: src/account.rs
================
use std::collections::HashMap;

use async_trait::async_trait;
use fuel_core_client::client::pagination::{PaginatedResult, PaginationRequest};
use fuel_tx::{Output, TxId, TxPointer, UtxoId};
use fuel_types::{AssetId, Bytes32, ContractId, Nonce};
use fuels_core::types::{
    bech32::{Bech32Address, Bech32ContractId},
    coin::Coin,
    coin_type::CoinType,
    coin_type_id::CoinTypeId,
    errors::Result,
    input::Input,
    message::Message,
    transaction::{Transaction, TxPolicies},
    transaction_builders::{BuildableTransaction, ScriptTransactionBuilder, TransactionBuilder},
    transaction_response::TransactionResponse,
    tx_response::TxResponse,
    tx_status::Success,
};

use crate::{
    accounts_utils::{
        add_base_change_if_needed, available_base_assets_and_amount, calculate_missing_base_amount,
        extract_message_nonce, split_into_utxo_ids_and_nonces,
    },
    provider::{Provider, ResourceFilter},
};

#[derive(Clone, Debug)]
pub struct WithdrawToBaseResponse {
    pub tx_status: Success,
    pub tx_id: TxId,
    pub nonce: Nonce,
}

#[cfg_attr(not(target_arch = "wasm32"), async_trait)]
pub trait ViewOnlyAccount: Send + Sync {
    fn address(&self) -> &Bech32Address;

    fn try_provider(&self) -> Result<&Provider>;

    async fn get_transactions(
        &self,
        request: PaginationRequest<String>,
    ) -> Result<PaginatedResult<TransactionResponse, String>> {
        Ok(self
            .try_provider()?
            .get_transactions_by_owner(self.address(), request)
            .await?)
    }

    /// Gets all unspent coins of asset `asset_id` owned by the account.
    async fn get_coins(&self, asset_id: AssetId) -> Result<Vec<Coin>> {
        Ok(self
            .try_provider()?
            .get_coins(self.address(), asset_id)
            .await?)
    }

    /// Get the balance of all spendable coins `asset_id` for address `address`. This is different
    /// from getting coins because we are just returning a number (the sum of UTXOs amount) instead
    /// of the UTXOs.
    async fn get_asset_balance(&self, asset_id: &AssetId) -> Result<u64> {
        self.try_provider()?
            .get_asset_balance(self.address(), *asset_id)
            .await
    }

    /// Gets all unspent messages owned by the account.
    async fn get_messages(&self) -> Result<Vec<Message>> {
        Ok(self.try_provider()?.get_messages(self.address()).await?)
    }

    /// Get all the spendable balances of all assets for the account. This is different from getting
    /// the coins because we are only returning the sum of UTXOs coins amount and not the UTXOs
    /// coins themselves.
    async fn get_balances(&self) -> Result<HashMap<String, u128>> {
        self.try_provider()?.get_balances(self.address()).await
    }

    /// Get some spendable resources (coins and messages) of asset `asset_id` owned by the account
    /// that add up at least to amount `amount`. The returned coins (UTXOs) are actual coins that
    /// can be spent. The number of UXTOs is optimized to prevent dust accumulation.
    async fn get_spendable_resources(
        &self,
        asset_id: AssetId,
        amount: u64,
        excluded_coins: Option<Vec<CoinTypeId>>,
    ) -> Result<Vec<CoinType>> {
        let (excluded_utxos, excluded_message_nonces) =
            split_into_utxo_ids_and_nonces(excluded_coins);

        let filter = ResourceFilter {
            from: self.address().clone(),
            asset_id: Some(asset_id),
            amount,
            excluded_utxos,
            excluded_message_nonces,
        };

        self.try_provider()?.get_spendable_resources(filter).await
    }

    /// Returns a vector containing the output coin and change output given an asset and amount
    fn get_asset_outputs_for_amount(
        &self,
        to: &Bech32Address,
        asset_id: AssetId,
        amount: u64,
    ) -> Vec<Output> {
        vec![
            Output::coin(to.into(), amount, asset_id),
            // Note that the change will be computed by the node.
            // Here we only have to tell the node who will own the change and its asset ID.
            Output::change(self.address().into(), 0, asset_id),
        ]
    }

    /// Returns a vector consisting of `Input::Coin`s and `Input::Message`s for the given
    /// asset ID and amount.
    async fn get_asset_inputs_for_amount(
        &self,
        asset_id: AssetId,
        amount: u64,
        excluded_coins: Option<Vec<CoinTypeId>>,
    ) -> Result<Vec<Input>>;

    /// Add base asset inputs to the transaction to cover the estimated fee
    /// and add a change output for the base asset if needed.
    /// Requires contract inputs to be at the start of the transactions inputs vec
    /// so that their indexes are retained
    async fn adjust_for_fee<Tb: TransactionBuilder + Sync>(
        &self,
        tb: &mut Tb,
        used_base_amount: u64,
    ) -> Result<()> {
        let provider = self.try_provider()?;
        let consensus_parameters = provider.consensus_parameters().await?;
        let (base_assets, base_amount) =
            available_base_assets_and_amount(tb, consensus_parameters.base_asset_id());
        let missing_base_amount =
            calculate_missing_base_amount(tb, base_amount, used_base_amount, provider).await?;

        if missing_base_amount > 0 {
            let new_base_inputs = self
                .get_asset_inputs_for_amount(
                    *consensus_parameters.base_asset_id(),
                    missing_base_amount,
                    Some(base_assets),
                )
                .await
                // if there query fails do nothing
                .unwrap_or_default();

            tb.inputs_mut().extend(new_base_inputs);
        };

        add_base_change_if_needed(tb, self.address(), consensus_parameters.base_asset_id());

        Ok(())
    }
}

#[cfg_attr(not(target_arch = "wasm32"), async_trait)]
pub trait Account: ViewOnlyAccount {
    // Add signatures to the builder if the underlying account is a wallet
    fn add_witnesses<Tb: TransactionBuilder>(&self, _tb: &mut Tb) -> Result<()> {
        Ok(())
    }

    /// Transfer funds from this account to another `Address`.
    /// Fails if amount for asset ID is larger than address's spendable coins.
    /// Returns the transaction ID that was sent and the list of receipts.
    async fn transfer(
        &self,
        to: &Bech32Address,
        amount: u64,
        asset_id: AssetId,
        tx_policies: TxPolicies,
    ) -> Result<TxResponse> {
        let provider = self.try_provider()?;

        let inputs = self
            .get_asset_inputs_for_amount(asset_id, amount, None)
            .await?;
        let outputs = self.get_asset_outputs_for_amount(to, asset_id, amount);

        let mut tx_builder =
            ScriptTransactionBuilder::prepare_transfer(inputs, outputs, tx_policies);

        self.add_witnesses(&mut tx_builder)?;

        let consensus_parameters = provider.consensus_parameters().await?;
        let used_base_amount = if asset_id == *consensus_parameters.base_asset_id() {
            amount
        } else {
            0
        };
        self.adjust_for_fee(&mut tx_builder, used_base_amount)
            .await?;

        let tx = tx_builder.build(provider).await?;
        let tx_id = tx.id(consensus_parameters.chain_id());

        let tx_status = provider.send_transaction_and_await_commit(tx).await?;

        Ok(TxResponse {
            tx_status: tx_status.take_success_checked(None)?,
            tx_id,
        })
    }

    /// Unconditionally transfers `balance` of type `asset_id` to
    /// the contract at `to`.
    /// Fails if balance for `asset_id` is larger than this account's spendable balance.
    /// Returns the corresponding transaction ID and the list of receipts.
    ///
    /// CAUTION !!!
    ///
    /// This will transfer coins to a contract, possibly leading
    /// to the PERMANENT LOSS OF COINS if not used with care.
    async fn force_transfer_to_contract(
        &self,
        to: &Bech32ContractId,
        balance: u64,
        asset_id: AssetId,
        tx_policies: TxPolicies,
    ) -> Result<TxResponse> {
        let provider = self.try_provider()?;

        let zeroes = Bytes32::zeroed();
        let plain_contract_id: ContractId = to.into();

        let mut inputs = vec![Input::contract(
            UtxoId::new(zeroes, 0),
            zeroes,
            zeroes,
            TxPointer::default(),
            plain_contract_id,
        )];

        inputs.extend(
            self.get_asset_inputs_for_amount(asset_id, balance, None)
                .await?,
        );

        let outputs = vec![
            Output::contract(0, zeroes, zeroes),
            Output::change(self.address().into(), 0, asset_id),
        ];

        // Build transaction and sign it
        let mut tb = ScriptTransactionBuilder::prepare_contract_transfer(
            plain_contract_id,
            balance,
            asset_id,
            inputs,
            outputs,
            tx_policies,
        );

        self.add_witnesses(&mut tb)?;
        self.adjust_for_fee(&mut tb, balance).await?;

        let tx = tb.build(provider).await?;

        let consensus_parameters = provider.consensus_parameters().await?;
        let tx_id = tx.id(consensus_parameters.chain_id());

        let tx_status = provider.send_transaction_and_await_commit(tx).await?;

        Ok(TxResponse {
            tx_status: tx_status.take_success_checked(None)?,
            tx_id,
        })
    }

    /// Withdraws an amount of the base asset to
    /// an address on the base chain.
    /// Returns the transaction ID, message ID and the list of receipts.
    async fn withdraw_to_base_layer(
        &self,
        to: &Bech32Address,
        amount: u64,
        tx_policies: TxPolicies,
    ) -> Result<WithdrawToBaseResponse> {
        let provider = self.try_provider()?;
        let consensus_parameters = provider.consensus_parameters().await?;

        let inputs = self
            .get_asset_inputs_for_amount(*consensus_parameters.base_asset_id(), amount, None)
            .await?;

        let mut tb = ScriptTransactionBuilder::prepare_message_to_output(
            to.into(),
            amount,
            inputs,
            tx_policies,
            *consensus_parameters.base_asset_id(),
        );

        self.add_witnesses(&mut tb)?;
        self.adjust_for_fee(&mut tb, amount).await?;

        let tx = tb.build(provider).await?;
        let tx_id = tx.id(consensus_parameters.chain_id());

        let tx_status = provider.send_transaction_and_await_commit(tx).await?;
        let success = tx_status.take_success_checked(None)?;

        let nonce = extract_message_nonce(&success.receipts)
            .expect("MessageId could not be retrieved from tx receipts.");

        Ok(WithdrawToBaseResponse {
            tx_status: success,
            tx_id,
            nonce,
        })
    }
}

#[cfg(test)]
mod tests {
    use std::str::FromStr;

    use fuel_crypto::{Message, SecretKey, Signature};
    use fuel_tx::{Address, ConsensusParameters, Output, Transaction as FuelTransaction};
    use fuels_core::{
        traits::Signer,
        types::{transaction::Transaction, DryRun, DryRunner},
    };

    use super::*;
    use crate::signers::private_key::PrivateKeySigner;

    #[derive(Default)]
    struct MockDryRunner {
        c_param: ConsensusParameters,
    }

    #[cfg_attr(not(target_arch = "wasm32"), async_trait)]
    impl DryRunner for MockDryRunner {
        async fn dry_run(&self, _: FuelTransaction) -> Result<DryRun> {
            Ok(DryRun {
                succeeded: true,
                script_gas: 0,
                variable_outputs: 0,
            })
        }

        async fn consensus_parameters(&self) -> Result<ConsensusParameters> {
            Ok(self.c_param.clone())
        }

        async fn estimate_gas_price(&self, _block_header: u32) -> Result<u64> {
            Ok(0)
        }

        async fn estimate_predicates(
            &self,
            _: &FuelTransaction,
            _: Option<u32>,
        ) -> Result<FuelTransaction> {
            unimplemented!()
        }
    }

    #[tokio::test]
    async fn sign_tx_and_verify() -> std::result::Result<(), Box<dyn std::error::Error>> {
        // ANCHOR: sign_tb
        let secret = SecretKey::from_str(
            "5f70feeff1f229e4a95e1056e8b4d80d0b24b565674860cc213bdb07127ce1b1",
        )?;
        let signer = PrivateKeySigner::new(secret);

        // Set up a transaction
        let mut tb = {
            let input_coin = Input::ResourceSigned {
                resource: CoinType::Coin(Coin {
                    amount: 10000000,
                    owner: signer.address().clone(),
                    ..Default::default()
                }),
            };

            let output_coin = Output::coin(
                Address::from_str(
                    "0xc7862855b418ba8f58878db434b21053a61a2025209889cc115989e8040ff077",
                )?,
                1,
                Default::default(),
            );
            let change = Output::change(signer.address().into(), 0, Default::default());

            ScriptTransactionBuilder::prepare_transfer(
                vec![input_coin],
                vec![output_coin, change],
                Default::default(),
            )
        };

        // Add `Signer` to the transaction builder
        tb.add_signer(signer.clone())?;
        // ANCHOR_END: sign_tb

        let tx = tb.build(MockDryRunner::default()).await?; // Resolve signatures and add corresponding witness indexes

        // Extract the signature from the tx witnesses
        let bytes = <[u8; Signature::LEN]>::try_from(tx.witnesses().first().unwrap().as_ref())?;
        let tx_signature = Signature::from_bytes(bytes);

        // Sign the transaction manually
        let message = Message::from_bytes(*tx.id(0.into()));
        let signature = signer.sign(message).await?;

        // Check if the signatures are the same
        assert_eq!(signature, tx_signature);

        // Check if the signature is what we expect it to be
        assert_eq!(signature, Signature::from_str("faa616776a1c336ef6257f7cb0cb5cd932180e2d15faba5f17481dae1cbcaf314d94617bd900216a6680bccb1ea62438e4ca93b0d5733d33788ef9d79cc24e9f")?);

        // Recover the address that signed the transaction
        let recovered_address = signature.recover(&message)?;

        assert_eq!(signer.address().hash(), recovered_address.hash());

        // Verify signature
        signature.verify(&recovered_address, &message)?;

        Ok(())
    }
}

================
File: src/accounts_utils.rs
================
use fuel_tx::{AssetId, Output, Receipt, UtxoId};
use fuel_types::Nonce;
use fuels_core::types::{
    bech32::Bech32Address,
    coin::Coin,
    coin_type::CoinType,
    coin_type_id::CoinTypeId,
    errors::{error, Error, Result},
    input::Input,
    transaction_builders::TransactionBuilder,
};
use itertools::{Either, Itertools};

use crate::provider::Provider;

pub fn extract_message_nonce(receipts: &[Receipt]) -> Option<Nonce> {
    receipts.iter().find_map(|m| m.nonce()).copied()
}

pub async fn calculate_missing_base_amount(
    tb: &impl TransactionBuilder,
    available_base_amount: u64,
    reserved_base_amount: u64,
    provider: &Provider,
) -> Result<u64> {
    let max_fee = tb.estimate_max_fee(provider).await?;

    let total_used = max_fee + reserved_base_amount;
    let missing_amount = if total_used > available_base_amount {
        total_used - available_base_amount
    } else if !is_consuming_utxos(tb) {
        // A tx needs to have at least 1 spendable input
        // Enforce a minimum required amount on the base asset if no other inputs are present
        1
    } else {
        0
    };

    Ok(missing_amount)
}

pub fn available_base_assets_and_amount(
    tb: &impl TransactionBuilder,
    base_asset_id: &AssetId,
) -> (Vec<CoinTypeId>, u64) {
    let mut sum = 0;
    let iter =
        tb.inputs()
            .iter()
            .filter_map(|input| match input {
                Input::ResourceSigned { resource, .. }
                | Input::ResourcePredicate { resource, .. } => match resource {
                    CoinType::Coin(Coin {
                        amount, asset_id, ..
                    }) if asset_id == base_asset_id => {
                        sum += amount;
                        resource.id()
                    }
                    CoinType::Message(message) => {
                        if message.data.is_empty() {
                            sum += message.amount;

                            resource.id()
                        } else {
                            None
                        }
                    }
                    _ => None,
                },
                _ => None,
            })
            .collect_vec();

    (iter, sum)
}

pub fn split_into_utxo_ids_and_nonces(
    excluded_coins: Option<Vec<CoinTypeId>>,
) -> (Vec<UtxoId>, Vec<Nonce>) {
    excluded_coins
        .map(|excluded_coins| {
            excluded_coins
                .iter()
                .partition_map(|coin_id| match coin_id {
                    CoinTypeId::UtxoId(utxo_id) => Either::Left(*utxo_id),
                    CoinTypeId::Nonce(nonce) => Either::Right(*nonce),
                })
        })
        .unwrap_or_default()
}

fn is_consuming_utxos(tb: &impl TransactionBuilder) -> bool {
    tb.inputs()
        .iter()
        .any(|input| !matches!(input, Input::Contract { .. }))
}

pub fn add_base_change_if_needed(
    tb: &mut impl TransactionBuilder,
    address: &Bech32Address,
    base_asset_id: &AssetId,
) {
    let is_base_change_present = tb.outputs().iter().any(|output| {
        matches!(output , Output::Change { asset_id , .. }
                                        if asset_id == base_asset_id)
    });

    if !is_base_change_present {
        tb.outputs_mut()
            .push(Output::change(address.into(), 0, *base_asset_id));
    }
}

pub(crate) fn try_provider_error() -> Error {
    error!(
        Other,
        "no provider available. Make sure to use `set_provider`"
    )
}

================
File: src/coin_cache.rs
================
use std::{
    collections::{HashMap, HashSet},
    hash::{Hash, Hasher},
};

use fuel_types::AssetId;
use fuels_core::types::{bech32::Bech32Address, coin_type_id::CoinTypeId};
use tokio::time::{Duration, Instant};

type CoinCacheKey = (Bech32Address, AssetId);

#[derive(Debug)]
pub(crate) struct CoinsCache {
    ttl: Duration,
    items: HashMap<CoinCacheKey, HashSet<CoinCacheItem>>,
}

impl Default for CoinsCache {
    fn default() -> Self {
        Self::new(Duration::from_secs(30))
    }
}

impl CoinsCache {
    pub fn new(ttl: Duration) -> Self {
        Self {
            ttl,
            items: HashMap::default(),
        }
    }

    pub fn insert_multiple(
        &mut self,
        coin_ids: impl IntoIterator<Item = (CoinCacheKey, Vec<CoinTypeId>)>,
    ) {
        for (key, ids) in coin_ids {
            let new_items = ids.into_iter().map(CoinCacheItem::new);

            let items = self.items.entry(key.clone()).or_default();
            items.extend(new_items);
        }
    }

    pub fn get_active(&mut self, key: &CoinCacheKey) -> HashSet<CoinTypeId> {
        self.remove_expired_entries(key);

        self.items
            .get(key)
            .cloned()
            .unwrap_or_default()
            .into_iter()
            .map(|item| item.id)
            .collect()
    }

    pub fn remove_items(
        &mut self,
        inputs: impl IntoIterator<Item = (CoinCacheKey, Vec<CoinTypeId>)>,
    ) {
        for (key, ids) in inputs {
            for id in ids {
                self.remove(&key, id);
            }
        }
    }

    fn remove(&mut self, key: &CoinCacheKey, id: CoinTypeId) {
        if let Some(ids) = self.items.get_mut(key) {
            let item = CoinCacheItem::new(id);
            ids.remove(&item);
        }
    }

    fn remove_expired_entries(&mut self, key: &CoinCacheKey) {
        if let Some(entry) = self.items.get_mut(key) {
            entry.retain(|item| item.is_valid(self.ttl));
        }
    }
}

#[derive(Eq, Debug, Clone)]
struct CoinCacheItem {
    created_at: Instant,
    pub id: CoinTypeId,
}

impl PartialEq for CoinCacheItem {
    fn eq(&self, other: &Self) -> bool {
        self.id.eq(&other.id)
    }
}

impl Hash for CoinCacheItem {
    fn hash<H: Hasher>(&self, state: &mut H) {
        self.id.hash(state);
    }
}

impl CoinCacheItem {
    pub fn new(id: CoinTypeId) -> Self {
        Self {
            created_at: Instant::now(),
            id,
        }
    }

    pub fn is_valid(&self, ttl: Duration) -> bool {
        self.created_at + ttl > Instant::now()
    }
}

#[cfg(test)]
mod tests {
    use fuel_tx::UtxoId;
    use fuel_types::{Bytes32, Nonce};

    use super::*;

    fn get_items() -> (CoinTypeId, CoinTypeId) {
        let utxo_id = UtxoId::new(Bytes32::from([1u8; 32]), 0);
        let nonce = Nonce::new([2u8; 32]);

        (CoinTypeId::UtxoId(utxo_id), CoinTypeId::Nonce(nonce))
    }

    #[test]
    fn test_insert_and_get_active() {
        let mut cache = CoinsCache::new(Duration::from_secs(60));

        let key: CoinCacheKey = Default::default();
        let (item1, item2) = get_items();
        let items = HashMap::from([(key.clone(), vec![item1.clone(), item2.clone()])]);

        cache.insert_multiple(items);

        let active_coins = cache.get_active(&key);

        assert_eq!(active_coins.len(), 2);
        assert!(active_coins.contains(&item1));
        assert!(active_coins.contains(&item2));
    }

    #[tokio::test]
    async fn test_insert_and_expire_items() {
        let mut cache = CoinsCache::new(Duration::from_secs(10));

        let key = CoinCacheKey::default();
        let (item1, _) = get_items();
        let items = HashMap::from([(key.clone(), vec![item1.clone()])]);

        cache.insert_multiple(items);

        // Advance time by more than the cache's TTL
        tokio::time::pause();
        tokio::time::advance(Duration::from_secs(12)).await;

        let (_, item2) = get_items();
        let items = HashMap::from([(key.clone(), vec![item2.clone()])]);
        cache.insert_multiple(items);

        let active_coins = cache.get_active(&key);

        assert_eq!(active_coins.len(), 1);
        assert!(!active_coins.contains(&item1));
        assert!(active_coins.contains(&item2));
    }

    #[test]
    fn test_get_active_no_items() {
        let mut cache = CoinsCache::new(Duration::from_secs(60));

        let key = Default::default();
        let active_coins = cache.get_active(&key);

        assert!(active_coins.is_empty());
    }

    #[test]
    fn test_remove_items() {
        let mut cache = CoinsCache::new(Duration::from_secs(60));

        let key: CoinCacheKey = Default::default();
        let (item1, item2) = get_items();

        let items_to_insert = [(key.clone(), vec![item1.clone(), item2.clone()])];
        cache.insert_multiple(items_to_insert.iter().cloned());

        let items_to_remove = [(key.clone(), vec![item1.clone()])];
        cache.remove_items(items_to_remove.iter().cloned());

        let active_coins = cache.get_active(&key);

        assert_eq!(active_coins.len(), 1);
        assert!(!active_coins.contains(&item1));
        assert!(active_coins.contains(&item2));
    }
}

================
File: src/keystore.rs
================
use std::path::{Path, PathBuf};

use fuel_crypto::SecretKey;
use fuels_core::{error, types::errors::Result};
use rand::{CryptoRng, Rng};
use zeroize::{Zeroize, ZeroizeOnDrop};

#[derive(Debug, Clone, Zeroize, ZeroizeOnDrop)]
pub struct KeySaved {
    key: SecretKey,
    #[zeroize(skip)]
    uuid: String,
}

impl KeySaved {
    pub fn key(&self) -> &SecretKey {
        &self.key
    }

    pub fn uuid(&self) -> &str {
        &self.uuid
    }
}

/// A Keystore encapsulates operations for key management such as creation, loading,
/// and saving of keys into a specified directory.
pub struct Keystore {
    dir: PathBuf,
}

impl Keystore {
    /// Creates a new Keystore instance with the provided directory.
    pub fn new<P: AsRef<Path>>(dir: P) -> Self {
        Self {
            dir: dir.as_ref().to_path_buf(),
        }
    }

    /// Creates a new key, encrypts it with the given password, and stores it in the keystore.
    pub fn new_key<R, S>(&self, rng: &mut R, password: S) -> Result<KeySaved>
    where
        R: Rng + CryptoRng,
        S: AsRef<[u8]>,
    {
        let (secret, uuid) =
            eth_keystore::new(&self.dir, rng, password, None).map_err(|e| error!(Other, "{e}"))?;
        let key = SecretKey::try_from(secret.as_slice()).expect("should have correct size");
        Ok(KeySaved { key, uuid })
    }

    /// Loads and decrypts a key from the keystore using the given UUID and password.
    pub fn load_key<S>(&self, uuid: &str, password: S) -> Result<SecretKey>
    where
        S: AsRef<[u8]>,
    {
        let key_path = self.dir.join(uuid);
        let secret =
            eth_keystore::decrypt_key(key_path, password).map_err(|e| error!(Other, "{e}"))?;
        let secret_key = SecretKey::try_from(secret.as_slice())
            .expect("Decrypted key should have a correct size");
        Ok(secret_key)
    }

    /// Encrypts the provided key with the given password and saves it to the keystore.
    /// Returns the generated UUID for the stored key.
    pub fn save_key<R, S>(&self, key: SecretKey, password: S, mut rng: R) -> Result<String>
    where
        R: Rng + CryptoRng,
        S: AsRef<[u8]>,
    {
        // Note: `*key` is used if SecretKey implements Deref to an inner type.
        eth_keystore::encrypt_key(&self.dir, &mut rng, *key, password, None)
            .map_err(|e| error!(Other, "{e}"))
    }
}

#[cfg(test)]
mod tests {
    use fuel_crypto::Message;
    use fuels_core::traits::Signer;
    use rand::thread_rng;
    use tempfile::tempdir;

    use super::*;
    use crate::signers::private_key::PrivateKeySigner;

    #[tokio::test]
    async fn encrypted_json_keystore() -> Result<()> {
        let dir = tempdir()?;
        let keystore = Keystore::new(dir.path());
        let mut rng = rand::thread_rng();

        // Create a key to be stored in the keystore.
        let key_saved = keystore.new_key(&mut rng, "password")?;
        let signer = PrivateKeySigner::new(*key_saved.key());

        // Sign a message using the above key.
        let message = Message::new("Hello there!".as_bytes());
        let signature = signer.sign(message).await?;

        // Read from the encrypted JSON keystore and decrypt it.
        let recovered_key = keystore.load_key(key_saved.uuid(), "password")?;
        let signer2 = PrivateKeySigner::new(recovered_key);

        // Sign the same message as before and assert that the signature is the same.
        let signature2 = signer2.sign(message).await?;
        assert_eq!(signature, signature2);

        // Remove the keystore file.
        let key_path = keystore.dir.join(key_saved.uuid());
        assert!(std::fs::remove_file(key_path).is_ok());
        Ok(())
    }

    #[tokio::test]
    async fn wallet_from_mnemonic_phrase() -> Result<()> {
        let phrase =
            "oblige salon price punch saddle immune slogan rare snap desert retire surprise";

        // Create first key from mnemonic phrase.
        let key = SecretKey::new_from_mnemonic_phrase_with_path(phrase, "m/44'/60'/0'/0/0")?;
        let signer = PrivateKeySigner::new(key);

        let expected_plain_address =
            "df9d0e6c6c5f5da6e82e5e1a77974af6642bdb450a10c43f0c6910a212600185";
        let expected_address = "fuel1m7wsumrvtaw6d6pwtcd809627ejzhk69pggvg0cvdyg2yynqqxzseuzply";

        assert_eq!(signer.address().hash().to_string(), expected_plain_address);
        assert_eq!(signer.address().to_string(), expected_address);

        // Create a second key from the same phrase.
        let key = SecretKey::new_from_mnemonic_phrase_with_path(phrase, "m/44'/60'/1'/0/0")?;
        let signer2 = PrivateKeySigner::new(key);

        let expected_second_plain_address =
            "261191b0164a24fd0fd51566ec5e5b0b9ba8fb2d42dc9cf7dbbd6f23d2742759";
        let expected_second_address =
            "fuel1ycgervqkfgj06r74z4nwchjmpwd637edgtwfea7mh4hj85n5yavszjk4cc";

        assert_eq!(
            signer2.address().hash().to_string(),
            expected_second_plain_address
        );
        assert_eq!(signer2.address().to_string(), expected_second_address);

        Ok(())
    }

    #[tokio::test]
    async fn encrypt_and_store_keys_from_mnemonic() -> Result<()> {
        let dir = tempdir()?;
        let keystore = Keystore::new(dir.path());
        let phrase =
            "oblige salon price punch saddle immune slogan rare snap desert retire surprise";

        // Create a key from the mnemonic phrase.
        let key = SecretKey::new_from_mnemonic_phrase_with_path(phrase, "m/44'/60'/0'/0/0")?;
        let uuid = keystore.save_key(key, "password", thread_rng())?;

        let recovered_key = keystore.load_key(&uuid, "password")?;
        assert_eq!(key, recovered_key);

        // Remove the keystore file.
        let key_path = keystore.dir.join(&uuid);
        assert!(std::fs::remove_file(key_path).is_ok());
        Ok(())
    }
}

================
File: src/lib.rs
================
#[cfg(feature = "std")]
mod account;
#[cfg(feature = "std")]
mod accounts_utils;
#[cfg(all(feature = "std", feature = "keystore"))]
pub mod keystore;
#[cfg(feature = "std")]
pub mod provider;
#[cfg(feature = "std")]
pub mod wallet;

#[cfg(feature = "std")]
pub use account::*;

#[cfg(feature = "coin-cache")]
mod coin_cache;

pub mod predicate;
pub mod signers;
#[cfg(test)]
mod test {
    #[test]
    fn sdl_is_the_same_as_from_fuel() {
        let file_sdl = include_str!("./schema/schema.sdl");

        let core_sdl = String::from_utf8(fuel_core_client::SCHEMA_SDL.to_vec()).unwrap();

        assert_eq!(file_sdl, &core_sdl);
    }
}

================
File: src/predicate.rs
================
use std::{fmt::Debug, fs};

#[cfg(feature = "std")]
use fuels_core::types::{coin_type_id::CoinTypeId, input::Input, AssetId};
use fuels_core::{
    error,
    types::{bech32::Bech32Address, errors::Result},
    Configurables,
};

#[cfg(feature = "std")]
use crate::accounts_utils::try_provider_error;
#[cfg(feature = "std")]
use crate::{provider::Provider, Account, ViewOnlyAccount};

#[derive(Debug, Clone)]
pub struct Predicate {
    address: Bech32Address,
    code: Vec<u8>,
    data: Vec<u8>,
    #[cfg(feature = "std")]
    provider: Option<Provider>,
}

impl Predicate {
    pub fn address(&self) -> &Bech32Address {
        &self.address
    }

    pub fn code(&self) -> &[u8] {
        &self.code
    }

    pub fn data(&self) -> &[u8] {
        &self.data
    }

    pub fn calculate_address(code: &[u8]) -> Bech32Address {
        fuel_tx::Input::predicate_owner(code).into()
    }

    pub fn load_from(file_path: &str) -> Result<Self> {
        let code = fs::read(file_path).map_err(|e| {
            error!(
                IO,
                "could not read predicate binary {file_path:?}. Reason: {e}"
            )
        })?;
        Ok(Self::from_code(code))
    }

    pub fn from_code(code: Vec<u8>) -> Self {
        Self {
            address: Self::calculate_address(&code),
            code,
            data: Default::default(),
            #[cfg(feature = "std")]
            provider: None,
        }
    }

    pub fn with_data(mut self, data: Vec<u8>) -> Self {
        self.data = data;
        self
    }

    pub fn with_code(self, code: Vec<u8>) -> Self {
        let address = Self::calculate_address(&code);
        Self {
            code,
            address,
            ..self
        }
    }

    pub fn with_configurables(mut self, configurables: impl Into<Configurables>) -> Self {
        let configurables: Configurables = configurables.into();
        configurables.update_constants_in(&mut self.code);
        let address = Self::calculate_address(&self.code);
        self.address = address;
        self
    }
}

#[cfg(feature = "std")]
impl Predicate {
    pub fn provider(&self) -> Option<&Provider> {
        self.provider.as_ref()
    }

    pub fn set_provider(&mut self, provider: Provider) {
        self.provider = Some(provider);
    }

    pub fn with_provider(self, provider: Provider) -> Self {
        Self {
            provider: Some(provider),
            ..self
        }
    }
}

#[cfg(feature = "std")]
#[cfg_attr(not(target_arch = "wasm32"), async_trait::async_trait)]
impl ViewOnlyAccount for Predicate {
    fn address(&self) -> &Bech32Address {
        self.address()
    }

    fn try_provider(&self) -> Result<&Provider> {
        self.provider.as_ref().ok_or_else(try_provider_error)
    }

    async fn get_asset_inputs_for_amount(
        &self,
        asset_id: AssetId,
        amount: u64,
        excluded_coins: Option<Vec<CoinTypeId>>,
    ) -> Result<Vec<Input>> {
        Ok(self
            .get_spendable_resources(asset_id, amount, excluded_coins)
            .await?
            .into_iter()
            .map(|resource| {
                Input::resource_predicate(resource, self.code.clone(), self.data.clone())
            })
            .collect::<Vec<Input>>())
    }
}

#[cfg(feature = "std")]
impl Account for Predicate {}

================
File: src/provider.rs
================
#[cfg(feature = "coin-cache")]
use std::sync::Arc;
use std::{collections::HashMap, fmt::Debug, net::SocketAddr};

mod cache;
mod retry_util;
mod retryable_client;
mod supported_fuel_core_version;
mod supported_versions;

use crate::provider::cache::CacheableRpcs;
pub use cache::TtlConfig;
use cache::{CachedClient, SystemClock};
use chrono::{DateTime, Utc};
use fuel_core_client::client::{
    pagination::{PageDirection, PaginatedResult, PaginationRequest},
    types::{
        balance::Balance,
        contract::ContractBalance,
        gas_price::{EstimateGasPrice, LatestGasPrice},
    },
};
use fuel_core_types::services::executor::TransactionExecutionResult;
use fuel_tx::{
    AssetId, ConsensusParameters, Receipt, Transaction as FuelTransaction, TxId, UtxoId,
};
use fuel_types::{Address, BlockHeight, Bytes32, Nonce};
#[cfg(feature = "coin-cache")]
use fuels_core::types::coin_type_id::CoinTypeId;
use fuels_core::{
    constants::{DEFAULT_GAS_ESTIMATION_BLOCK_HORIZON, DEFAULT_GAS_ESTIMATION_TOLERANCE},
    types::{
        bech32::{Bech32Address, Bech32ContractId},
        block::{Block, Header},
        chain_info::ChainInfo,
        coin::Coin,
        coin_type::CoinType,
        errors::Result,
        message::Message,
        message_proof::MessageProof,
        node_info::NodeInfo,
        transaction::{Transaction, Transactions},
        transaction_builders::{Blob, BlobId},
        transaction_response::TransactionResponse,
        tx_status::TxStatus,
        DryRun, DryRunner,
    },
};
pub use retry_util::{Backoff, RetryConfig};
pub use supported_fuel_core_version::SUPPORTED_FUEL_CORE_VERSION;
use tai64::Tai64;
#[cfg(feature = "coin-cache")]
use tokio::sync::Mutex;

#[cfg(feature = "coin-cache")]
use crate::coin_cache::CoinsCache;
use crate::provider::retryable_client::RetryableClient;

const NUM_RESULTS_PER_REQUEST: i32 = 100;

#[derive(Debug, Clone, PartialEq)]
// ANCHOR: transaction_cost
pub struct TransactionCost {
    pub gas_price: u64,
    pub metered_bytes_size: u64,
    pub total_fee: u64,
    pub script_gas: u64,
    pub total_gas: u64,
}
// ANCHOR_END: transaction_cost

pub(crate) struct ResourceQueries {
    utxos: Vec<UtxoId>,
    messages: Vec<Nonce>,
    asset_id: Option<AssetId>,
    amount: u64,
}

impl ResourceQueries {
    pub fn exclusion_query(&self) -> Option<(Vec<UtxoId>, Vec<Nonce>)> {
        if self.utxos.is_empty() && self.messages.is_empty() {
            return None;
        }

        Some((self.utxos.clone(), self.messages.clone()))
    }

    pub fn spend_query(&self, base_asset_id: AssetId) -> Vec<(AssetId, u64, Option<u32>)> {
        vec![(self.asset_id.unwrap_or(base_asset_id), self.amount, None)]
    }
}

#[derive(Default)]
// ANCHOR: resource_filter
pub struct ResourceFilter {
    pub from: Bech32Address,
    pub asset_id: Option<AssetId>,
    pub amount: u64,
    pub excluded_utxos: Vec<UtxoId>,
    pub excluded_message_nonces: Vec<Nonce>,
}
// ANCHOR_END: resource_filter

impl ResourceFilter {
    pub fn owner(&self) -> Address {
        (&self.from).into()
    }

    pub(crate) fn resource_queries(&self) -> ResourceQueries {
        ResourceQueries {
            utxos: self.excluded_utxos.clone(),
            messages: self.excluded_message_nonces.clone(),
            asset_id: self.asset_id,
            amount: self.amount,
        }
    }
}

/// Encapsulates common client operations in the SDK.
/// Note that you may also use `client`, which is an instance
/// of `FuelClient`, directly, which provides a broader API.
#[derive(Debug, Clone)]
pub struct Provider {
    cached_client: CachedClient<RetryableClient>,
    #[cfg(feature = "coin-cache")]
    coins_cache: Arc<Mutex<CoinsCache>>,
}

impl Provider {
    pub async fn from(addr: impl Into<SocketAddr>) -> Result<Self> {
        let addr = addr.into();
        Self::connect(format!("http://{addr}")).await
    }

    pub fn set_cache_ttl(&mut self, ttl: TtlConfig) {
        self.cached_client.set_ttl(ttl);
    }

    pub async fn clear_cache(&self) {
        self.cached_client.clear().await;
    }

    pub async fn healthy(&self) -> Result<bool> {
        Ok(self.uncached_client().health().await?)
    }

    /// Connects to an existing node at the given address.
    pub async fn connect(url: impl AsRef<str>) -> Result<Provider> {
        let client = CachedClient::new(
            RetryableClient::connect(&url, Default::default()).await?,
            TtlConfig::default(),
            SystemClock,
        );

        Ok(Self {
            cached_client: client,
            #[cfg(feature = "coin-cache")]
            coins_cache: Default::default(),
        })
    }

    pub fn url(&self) -> &str {
        self.uncached_client().url()
    }

    pub async fn blob(&self, blob_id: BlobId) -> Result<Option<Blob>> {
        Ok(self
            .uncached_client()
            .blob(blob_id.into())
            .await?
            .map(|blob| Blob::new(blob.bytecode)))
    }

    pub async fn blob_exists(&self, blob_id: BlobId) -> Result<bool> {
        Ok(self.uncached_client().blob_exists(blob_id.into()).await?)
    }

    /// Sends a transaction to the underlying Provider's client.
    pub async fn send_transaction_and_await_commit<T: Transaction>(
        &self,
        tx: T,
    ) -> Result<TxStatus> {
        #[cfg(feature = "coin-cache")]
        let base_asset_id = *self.consensus_parameters().await?.base_asset_id();

        #[cfg(feature = "coin-cache")]
        self.check_inputs_already_in_cache(&tx.used_coins(&base_asset_id))
            .await?;

        let tx = self.prepare_transaction_for_sending(tx).await?;
        let tx_status = self
            .uncached_client()
            .submit_and_await_commit(&tx.clone().into())
            .await?
            .into();

        #[cfg(feature = "coin-cache")]
        if matches!(
            tx_status,
            TxStatus::SqueezedOut { .. } | TxStatus::Revert { .. }
        ) {
            self.coins_cache
                .lock()
                .await
                .remove_items(tx.used_coins(&base_asset_id))
        }

        Ok(tx_status)
    }

    async fn prepare_transaction_for_sending<T: Transaction>(&self, mut tx: T) -> Result<T> {
        let consensus_parameters = self.consensus_parameters().await?;
        tx.precompute(&consensus_parameters.chain_id())?;

        let chain_info = self.chain_info().await?;
        let Header {
            height: latest_block_height,
            state_transition_bytecode_version: latest_chain_executor_version,
            ..
        } = chain_info.latest_block.header;

        if tx.is_using_predicates() {
            tx.estimate_predicates(self, Some(latest_chain_executor_version))
                .await?;
            tx.clone()
                .validate_predicates(&consensus_parameters, latest_block_height)?;
        }

        Ok(tx)
    }

    pub async fn send_transaction<T: Transaction>(&self, tx: T) -> Result<TxId> {
        let tx = self.prepare_transaction_for_sending(tx).await?;
        self.submit(tx).await
    }

    pub async fn await_transaction_commit<T: Transaction>(&self, id: TxId) -> Result<TxStatus> {
        Ok(self
            .uncached_client()
            .await_transaction_commit(&id)
            .await?
            .into())
    }

    #[cfg(not(feature = "coin-cache"))]
    async fn submit<T: Transaction>(&self, tx: T) -> Result<TxId> {
        Ok(self.uncached_client().submit(&tx.into()).await?)
    }

    #[cfg(feature = "coin-cache")]
    async fn find_in_cache<'a>(
        &self,
        coin_ids: impl IntoIterator<Item = (&'a (Bech32Address, AssetId), &'a Vec<CoinTypeId>)>,
    ) -> Option<((Bech32Address, AssetId), CoinTypeId)> {
        let mut locked_cache = self.coins_cache.lock().await;

        for (key, ids) in coin_ids {
            let items = locked_cache.get_active(key);

            if items.is_empty() {
                continue;
            }

            for id in ids {
                if items.contains(id) {
                    return Some((key.clone(), id.clone()));
                }
            }
        }

        None
    }

    #[cfg(feature = "coin-cache")]
    async fn check_inputs_already_in_cache<'a>(
        &self,
        coin_ids: impl IntoIterator<Item = (&'a (Bech32Address, AssetId), &'a Vec<CoinTypeId>)>,
    ) -> Result<()> {
        use fuels_core::types::errors::{transaction, Error};

        if let Some(((addr, asset_id), coin_type_id)) = self.find_in_cache(coin_ids).await {
            let msg = match coin_type_id {
                CoinTypeId::UtxoId(utxo_id) => format!("coin with utxo_id: `{utxo_id:x}`"),
                CoinTypeId::Nonce(nonce) => format!("message with nonce: `{nonce}`"),
            };
            Err(Error::Transaction(transaction::Reason::Validation(
                format!("{msg} was submitted recently in a transaction - attempting to spend it again will result in an error. Wallet address: `{addr}`, asset id: `{asset_id}`"),
            )))
        } else {
            Ok(())
        }
    }

    #[cfg(feature = "coin-cache")]
    async fn submit<T: Transaction>(&self, tx: T) -> Result<TxId> {
        let consensus_parameters = self.consensus_parameters().await?;
        let base_asset_id = consensus_parameters.base_asset_id();

        let used_utxos = tx.used_coins(base_asset_id);
        self.check_inputs_already_in_cache(&used_utxos).await?;

        let tx_id = self.uncached_client().submit(&tx.into()).await?;
        self.coins_cache.lock().await.insert_multiple(used_utxos);

        Ok(tx_id)
    }

    pub async fn tx_status(&self, tx_id: &TxId) -> Result<TxStatus> {
        Ok(self
            .uncached_client()
            .transaction_status(tx_id)
            .await?
            .into())
    }

    pub async fn chain_info(&self) -> Result<ChainInfo> {
        Ok(self.uncached_client().chain_info().await?.into())
    }

    pub async fn consensus_parameters(&self) -> Result<ConsensusParameters> {
        self.cached_client.consensus_parameters().await
    }

    pub async fn node_info(&self) -> Result<NodeInfo> {
        Ok(self.cached_client.node_info().await?.into())
    }

    pub async fn latest_gas_price(&self) -> Result<LatestGasPrice> {
        Ok(self.uncached_client().latest_gas_price().await?)
    }

    pub async fn estimate_gas_price(&self, block_horizon: u32) -> Result<EstimateGasPrice> {
        Ok(self
            .uncached_client()
            .estimate_gas_price(block_horizon)
            .await?)
    }

    pub async fn dry_run(&self, tx: impl Transaction) -> Result<TxStatus> {
        let [tx_status] = self
            .uncached_client()
            .dry_run(Transactions::new().insert(tx).as_slice())
            .await?
            .into_iter()
            .map(Into::into)
            .collect::<Vec<_>>()
            .try_into()
            .expect("should have only one element");

        Ok(tx_status)
    }

    pub async fn dry_run_multiple(
        &self,
        transactions: Transactions,
    ) -> Result<Vec<(TxId, TxStatus)>> {
        Ok(self
            .uncached_client()
            .dry_run(transactions.as_slice())
            .await?
            .into_iter()
            .map(|execution_status| (execution_status.id, execution_status.into()))
            .collect())
    }

    pub async fn dry_run_opt(
        &self,
        tx: impl Transaction,
        utxo_validation: bool,
        gas_price: Option<u64>,
    ) -> Result<TxStatus> {
        let [tx_status] = self
            .uncached_client()
            .dry_run_opt(
                Transactions::new().insert(tx).as_slice(),
                Some(utxo_validation),
                gas_price,
            )
            .await?
            .into_iter()
            .map(Into::into)
            .collect::<Vec<_>>()
            .try_into()
            .expect("should have only one element");

        Ok(tx_status)
    }

    pub async fn dry_run_opt_multiple(
        &self,
        transactions: Transactions,
        utxo_validation: bool,
        gas_price: Option<u64>,
    ) -> Result<Vec<(TxId, TxStatus)>> {
        Ok(self
            .uncached_client()
            .dry_run_opt(transactions.as_slice(), Some(utxo_validation), gas_price)
            .await?
            .into_iter()
            .map(|execution_status| (execution_status.id, execution_status.into()))
            .collect())
    }

    /// Gets all unspent coins owned by address `from`, with asset ID `asset_id`.
    pub async fn get_coins(&self, from: &Bech32Address, asset_id: AssetId) -> Result<Vec<Coin>> {
        let mut coins: Vec<Coin> = vec![];
        let mut cursor = None;

        loop {
            let response = self
                .uncached_client()
                .coins(
                    &from.into(),
                    Some(&asset_id),
                    PaginationRequest {
                        cursor: cursor.clone(),
                        results: NUM_RESULTS_PER_REQUEST,
                        direction: PageDirection::Forward,
                    },
                )
                .await?;

            if response.results.is_empty() {
                break;
            }

            coins.extend(response.results.into_iter().map(Into::into));
            cursor = response.cursor;
        }

        Ok(coins)
    }

    async fn request_coins_to_spend(&self, filter: ResourceFilter) -> Result<Vec<CoinType>> {
        let queries = filter.resource_queries();

        let consensus_parameters = self.consensus_parameters().await?;
        let base_asset_id = *consensus_parameters.base_asset_id();

        let res = self
            .uncached_client()
            .coins_to_spend(
                &filter.owner(),
                queries.spend_query(base_asset_id),
                queries.exclusion_query(),
            )
            .await?
            .into_iter()
            .flatten()
            .map(CoinType::from)
            .collect();

        Ok(res)
    }

    /// Get some spendable coins of asset `asset_id` for address `from` that add up at least to
    /// amount `amount`. The returned coins (UTXOs) are actual coins that can be spent. The number
    /// of coins (UXTOs) is optimized to prevent dust accumulation.
    #[cfg(not(feature = "coin-cache"))]
    pub async fn get_spendable_resources(&self, filter: ResourceFilter) -> Result<Vec<CoinType>> {
        self.request_coins_to_spend(filter).await
    }

    /// Get some spendable coins of asset `asset_id` for address `from` that add up at least to
    /// amount `amount`. The returned coins (UTXOs) are actual coins that can be spent. The number
    /// of coins (UXTOs) is optimized to prevent dust accumulation.
    /// Coins that were recently submitted inside a tx will be ignored from the results.
    #[cfg(feature = "coin-cache")]
    pub async fn get_spendable_resources(
        &self,
        mut filter: ResourceFilter,
    ) -> Result<Vec<CoinType>> {
        self.extend_filter_with_cached(&mut filter).await?;

        self.request_coins_to_spend(filter).await
    }

    #[cfg(feature = "coin-cache")]
    async fn extend_filter_with_cached(&self, filter: &mut ResourceFilter) -> Result<()> {
        let consensus_parameters = self.consensus_parameters().await?;
        let mut cache = self.coins_cache.lock().await;
        let asset_id = filter
            .asset_id
            .unwrap_or(*consensus_parameters.base_asset_id());
        let used_coins = cache.get_active(&(filter.from.clone(), asset_id));

        let excluded_utxos = used_coins
            .iter()
            .filter_map(|coin_id| match coin_id {
                CoinTypeId::UtxoId(utxo_id) => Some(utxo_id),
                _ => None,
            })
            .cloned()
            .collect::<Vec<_>>();

        let excluded_message_nonces = used_coins
            .iter()
            .filter_map(|coin_id| match coin_id {
                CoinTypeId::Nonce(nonce) => Some(nonce),
                _ => None,
            })
            .cloned()
            .collect::<Vec<_>>();

        filter.excluded_utxos.extend(excluded_utxos);
        filter
            .excluded_message_nonces
            .extend(excluded_message_nonces);

        Ok(())
    }

    /// Get the balance of all spendable coins `asset_id` for address `address`. This is different
    /// from getting coins because we are just returning a number (the sum of UTXOs amount) instead
    /// of the UTXOs.
    pub async fn get_asset_balance(
        &self,
        address: &Bech32Address,
        asset_id: AssetId,
    ) -> Result<u64> {
        Ok(self
            .uncached_client()
            .balance(&address.into(), Some(&asset_id))
            .await?)
    }

    /// Get the balance of all spendable coins `asset_id` for contract with id `contract_id`.
    pub async fn get_contract_asset_balance(
        &self,
        contract_id: &Bech32ContractId,
        asset_id: AssetId,
    ) -> Result<u64> {
        Ok(self
            .uncached_client()
            .contract_balance(&contract_id.into(), Some(&asset_id))
            .await?)
    }

    /// Get all the spendable balances of all assets for address `address`. This is different from
    /// getting the coins because we are only returning the numbers (the sum of UTXOs coins amount
    /// for each asset id) and not the UTXOs coins themselves
    pub async fn get_balances(&self, address: &Bech32Address) -> Result<HashMap<String, u128>> {
        let mut balances = HashMap::new();

        let mut register_balances = |results: Vec<_>| {
            let pairs = results.into_iter().map(
                |Balance {
                     owner: _,
                     amount,
                     asset_id,
                 }| (asset_id.to_string(), amount),
            );
            balances.extend(pairs);
        };

        let indexation_flags = self.cached_client.node_info().await?.indexation;
        if indexation_flags.balances {
            let mut cursor = None;
            loop {
                let pagination = PaginationRequest {
                    cursor: cursor.clone(),
                    results: NUM_RESULTS_PER_REQUEST,
                    direction: PageDirection::Forward,
                };
                let response = self
                    .uncached_client()
                    .balances(&address.into(), pagination)
                    .await?;

                if response.results.is_empty() {
                    break;
                }

                register_balances(response.results);
                cursor = response.cursor;
            }
        } else {
            let pagination = PaginationRequest {
                cursor: None,
                results: 9999,
                direction: PageDirection::Forward,
            };
            let response = self
                .uncached_client()
                .balances(&address.into(), pagination)
                .await?;

            register_balances(response.results)
        }

        Ok(balances)
    }

    /// Get all balances of all assets for the contract with id `contract_id`.
    pub async fn get_contract_balances(
        &self,
        contract_id: &Bech32ContractId,
    ) -> Result<HashMap<AssetId, u64>> {
        let mut contract_balances = HashMap::new();
        let mut cursor = None;

        loop {
            let response = self
                .uncached_client()
                .contract_balances(
                    &contract_id.into(),
                    PaginationRequest {
                        cursor: cursor.clone(),
                        results: NUM_RESULTS_PER_REQUEST,
                        direction: PageDirection::Forward,
                    },
                )
                .await?;

            if response.results.is_empty() {
                break;
            }

            contract_balances.extend(response.results.into_iter().map(
                |ContractBalance {
                     contract: _,
                     amount,
                     asset_id,
                 }| (asset_id, amount),
            ));
            cursor = response.cursor;
        }

        Ok(contract_balances)
    }

    pub async fn get_transaction_by_id(&self, tx_id: &TxId) -> Result<Option<TransactionResponse>> {
        Ok(self
            .uncached_client()
            .transaction(tx_id)
            .await?
            .map(Into::into))
    }

    pub async fn get_transactions(
        &self,
        request: PaginationRequest<String>,
    ) -> Result<PaginatedResult<TransactionResponse, String>> {
        let pr = self.uncached_client().transactions(request).await?;

        Ok(PaginatedResult {
            cursor: pr.cursor,
            results: pr.results.into_iter().map(Into::into).collect(),
            has_next_page: pr.has_next_page,
            has_previous_page: pr.has_previous_page,
        })
    }

    // Get transaction(s) by owner
    pub async fn get_transactions_by_owner(
        &self,
        owner: &Bech32Address,
        request: PaginationRequest<String>,
    ) -> Result<PaginatedResult<TransactionResponse, String>> {
        let pr = self
            .uncached_client()
            .transactions_by_owner(&owner.into(), request)
            .await?;

        Ok(PaginatedResult {
            cursor: pr.cursor,
            results: pr.results.into_iter().map(Into::into).collect(),
            has_next_page: pr.has_next_page,
            has_previous_page: pr.has_previous_page,
        })
    }

    pub async fn latest_block_height(&self) -> Result<u32> {
        Ok(self.chain_info().await?.latest_block.header.height)
    }

    pub async fn latest_block_time(&self) -> Result<Option<DateTime<Utc>>> {
        Ok(self.chain_info().await?.latest_block.header.time)
    }

    pub async fn produce_blocks(
        &self,
        blocks_to_produce: u32,
        start_time: Option<DateTime<Utc>>,
    ) -> Result<u32> {
        let start_time = start_time.map(|time| Tai64::from_unix(time.timestamp()).0);

        Ok(self
            .uncached_client()
            .produce_blocks(blocks_to_produce, start_time)
            .await?
            .into())
    }

    pub async fn block(&self, block_id: &Bytes32) -> Result<Option<Block>> {
        Ok(self
            .uncached_client()
            .block(block_id)
            .await?
            .map(Into::into))
    }

    pub async fn block_by_height(&self, height: BlockHeight) -> Result<Option<Block>> {
        Ok(self
            .uncached_client()
            .block_by_height(height)
            .await?
            .map(Into::into))
    }

    // - Get block(s)
    pub async fn get_blocks(
        &self,
        request: PaginationRequest<String>,
    ) -> Result<PaginatedResult<Block, String>> {
        let pr = self.uncached_client().blocks(request).await?;

        Ok(PaginatedResult {
            cursor: pr.cursor,
            results: pr.results.into_iter().map(Into::into).collect(),
            has_next_page: pr.has_next_page,
            has_previous_page: pr.has_previous_page,
        })
    }

    pub async fn estimate_transaction_cost<T: Transaction>(
        &self,
        tx: T,
        tolerance: Option<f64>,
        block_horizon: Option<u32>,
    ) -> Result<TransactionCost> {
        let block_horizon = block_horizon.unwrap_or(DEFAULT_GAS_ESTIMATION_BLOCK_HORIZON);
        let tolerance = tolerance.unwrap_or(DEFAULT_GAS_ESTIMATION_TOLERANCE);

        let EstimateGasPrice { gas_price, .. } = self.estimate_gas_price(block_horizon).await?;
        let tx_status = self.dry_run_opt(tx.clone(), false, None).await?;

        let total_gas = Self::apply_tolerance(tx_status.total_gas(), tolerance);
        let total_fee = Self::apply_tolerance(tx_status.total_fee(), tolerance);

        let receipts = tx_status.take_receipts();

        Ok(TransactionCost {
            gas_price,
            metered_bytes_size: tx.metered_bytes_size() as u64,
            total_fee,
            total_gas,
            script_gas: Self::get_script_gas_used(&receipts),
        })
    }

    fn apply_tolerance(value: u64, tolerance: f64) -> u64 {
        (value as f64 * (1.0 + tolerance)).ceil() as u64
    }

    fn get_script_gas_used(receipts: &[Receipt]) -> u64 {
        receipts
            .iter()
            .rfind(|r| matches!(r, Receipt::ScriptResult { .. }))
            .map(|script_result| {
                script_result
                    .gas_used()
                    .expect("could not retrieve gas used from ScriptResult")
            })
            .unwrap_or(0)
    }

    pub async fn get_messages(&self, from: &Bech32Address) -> Result<Vec<Message>> {
        let mut messages = Vec::new();
        let mut cursor = None;

        loop {
            let response = self
                .uncached_client()
                .messages(
                    Some(&from.into()),
                    PaginationRequest {
                        cursor: cursor.clone(),
                        results: NUM_RESULTS_PER_REQUEST,
                        direction: PageDirection::Forward,
                    },
                )
                .await?;

            if response.results.is_empty() {
                break;
            }

            messages.extend(response.results.into_iter().map(Into::into));
            cursor = response.cursor;
        }

        Ok(messages)
    }

    pub async fn get_message_proof(
        &self,
        tx_id: &TxId,
        nonce: &Nonce,
        commit_block_id: Option<&Bytes32>,
        commit_block_height: Option<u32>,
    ) -> Result<MessageProof> {
        self.uncached_client()
            .message_proof(
                tx_id,
                nonce,
                commit_block_id,
                commit_block_height.map(Into::into),
            )
            .await
            .map(Into::into)
            .map_err(Into::into)
    }

    pub async fn is_user_account(&self, address: impl Into<Bytes32>) -> Result<bool> {
        self.uncached_client()
            .is_user_account(*address.into())
            .await
    }

    pub fn with_retry_config(mut self, retry_config: RetryConfig) -> Self {
        self.uncached_client_mut().set_retry_config(retry_config);

        self
    }

    pub async fn contract_exists(&self, contract_id: &Bech32ContractId) -> Result<bool> {
        Ok(self
            .uncached_client()
            .contract_exists(&contract_id.into())
            .await?)
    }

    fn uncached_client(&self) -> &RetryableClient {
        self.cached_client.inner()
    }

    fn uncached_client_mut(&mut self) -> &mut RetryableClient {
        self.cached_client.inner_mut()
    }
}

#[cfg_attr(not(target_arch = "wasm32"), async_trait::async_trait)]
impl DryRunner for Provider {
    async fn dry_run(&self, tx: FuelTransaction) -> Result<DryRun> {
        let [tx_execution_status] = self
            .uncached_client()
            .dry_run_opt(&vec![tx], Some(false), Some(0))
            .await?
            .try_into()
            .expect("should have only one element");

        let receipts = tx_execution_status.result.receipts();
        let script_gas = Self::get_script_gas_used(receipts);

        let variable_outputs = receipts
            .iter()
            .filter(
                |receipt| matches!(receipt, Receipt::TransferOut { amount, .. } if *amount != 0),
            )
            .count();

        let succeeded = matches!(
            tx_execution_status.result,
            TransactionExecutionResult::Success { .. }
        );

        let dry_run = DryRun {
            succeeded,
            script_gas,
            variable_outputs,
        };

        Ok(dry_run)
    }

    async fn estimate_gas_price(&self, block_horizon: u32) -> Result<u64> {
        Ok(self.estimate_gas_price(block_horizon).await?.gas_price)
    }

    async fn consensus_parameters(&self) -> Result<ConsensusParameters> {
        Provider::consensus_parameters(self).await
    }

    async fn estimate_predicates(
        &self,
        tx: &FuelTransaction,
        _latest_chain_executor_version: Option<u32>,
    ) -> Result<FuelTransaction> {
        Ok(self.uncached_client().estimate_predicates(tx).await?)
    }
}

================
File: src/signers.rs
================
pub const DEFAULT_DERIVATION_PATH: &str = "m/44'/1179993420'/0'/0/0";
#[cfg(feature = "signer-aws-kms")]
pub mod aws_kms;
pub mod fake;
pub mod locked;
pub mod private_key;

================
File: src/wallet.rs
================
use async_trait::async_trait;
use fuel_tx::AssetId;
use fuels_core::{
    traits::{AddressResolver, Signer},
    types::{
        bech32::Bech32Address, coin_type_id::CoinTypeId, errors::Result, input::Input,
        transaction_builders::TransactionBuilder,
    },
};
use rand::{CryptoRng, RngCore};

use crate::{
    provider::Provider,
    signers::{locked::Locked, private_key::PrivateKeySigner},
    Account, ViewOnlyAccount,
};

#[derive(Debug, Clone)]
pub struct Wallet<S = PrivateKeySigner> {
    signer: S,
    provider: Provider,
}

impl<S> Wallet<S> {
    pub fn new(signer: S, provider: Provider) -> Self {
        Self { signer, provider }
    }

    pub fn provider(&self) -> &Provider {
        &self.provider
    }

    pub fn signer(&self) -> &S {
        &self.signer
    }
}

impl Wallet<PrivateKeySigner> {
    pub fn random(rng: &mut (impl CryptoRng + RngCore), provider: Provider) -> Self {
        Self::new(PrivateKeySigner::random(rng), provider)
    }
}

impl<S> Wallet<S>
where
    S: Signer,
{
    pub fn locked(&self) -> Wallet<Locked> {
        Wallet::new(
            Locked::new(self.signer.address().clone()),
            self.provider.clone(),
        )
    }
}

#[async_trait]
impl<S> ViewOnlyAccount for Wallet<S>
where
    S: AddressResolver + Clone + Send + Sync + std::fmt::Debug,
{
    fn address(&self) -> &Bech32Address {
        self.signer.address()
    }

    fn try_provider(&self) -> Result<&Provider> {
        Ok(&self.provider)
    }

    async fn get_asset_inputs_for_amount(
        &self,
        asset_id: AssetId,
        amount: u64,
        excluded_coins: Option<Vec<CoinTypeId>>,
    ) -> Result<Vec<Input>> {
        Ok(self
            .get_spendable_resources(asset_id, amount, excluded_coins)
            .await?
            .into_iter()
            .map(Input::resource_signed)
            .collect::<Vec<Input>>())
    }
}

#[async_trait]
impl<S> Account for Wallet<S>
where
    S: Signer + Clone + Send + Sync + std::fmt::Debug + 'static,
{
    fn add_witnesses<Tb: TransactionBuilder>(&self, tb: &mut Tb) -> Result<()> {
        tb.add_signer(self.signer.clone())?;

        Ok(())
    }
}

================
File: Cargo.toml
================
[package]
name = "fuels-accounts"
version = { workspace = true }
authors = { workspace = true }
edition = { workspace = true }
homepage = { workspace = true }
license = { workspace = true }
repository = { workspace = true }
rust-version = { workspace = true }
description = "Fuel Rust SDK accounts."

[dependencies]
async-trait = { workspace = true, default-features = false }
aws-config = { workspace = true, features = [
  "behavior-version-latest",
], optional = true }
aws-sdk-kms = { workspace = true, features = ["default"], optional = true }
chrono = { workspace = true }
cynic = { workspace = true, optional = true }
elliptic-curve = { workspace = true, default-features = false }
eth-keystore = { workspace = true, optional = true }
fuel-core-client = { workspace = true, optional = true }
fuel-core-types = { workspace = true }
fuel-crypto = { workspace = true, features = ["random"] }
fuel-tx = { workspace = true }
fuel-types = { workspace = true, features = ["random"] }
fuels-core = { workspace = true, default-features = false }
itertools = { workspace = true }
k256 = { workspace = true, features = ["ecdsa-core"] }
rand = { workspace = true, default-features = false }
semver = { workspace = true }
tai64 = { workspace = true, features = ["serde"] }
thiserror = { workspace = true, default-features = false }
tokio = { workspace = true, features = ["full"], optional = true }
zeroize = { workspace = true, features = ["derive"] }

[dev-dependencies]
fuel-tx = { workspace = true, features = ["test-helpers", "random"] }
mockall = { workspace = true, default-features = false }
tempfile = { workspace = true }
tokio = { workspace = true, features = ["test-util"] }

[features]
default = ["std"]
coin-cache = ["tokio?/time"]
std = ["fuels-core/std", "dep:tokio", "fuel-core-client/default", "dep:cynic"]
test-helpers = []
signer-aws-kms = ["dep:aws-sdk-kms", "dep:aws-config"]
keystore = ["dep:eth-keystore"]



================================================================
End of Codebase
================================================================
