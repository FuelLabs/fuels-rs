use std::{
    collections::HashMap,
    fmt::{Debug, Formatter},
    iter::{repeat, repeat_with},
};

use async_trait::async_trait;
use fuel_asm::{op, GTFArgs, RegId};
use fuel_core_types::services::executor::TransactionExecutionResult;
use fuel_crypto::{Message as CryptoMessage, Signature};
use fuel_tx::{
    field::{Inputs, Outputs, Policies as PoliciesField, ScriptGasLimit, WitnessLimit, Witnesses},
    input::coin::{CoinPredicate, CoinSigned},
    policies::{Policies, PolicyType},
    Chargeable, ConsensusParameters, Create, Input as FuelInput, Output, Script, StorageSlot,
    Transaction as FuelTransaction, TransactionFee, TxId, TxPointer, UniqueIdentifier, Witness,
};
use fuel_types::{bytes::padded_len_usize, Bytes32, Salt};
use itertools::Itertools;

use crate::{
    constants::{SIGNATURE_WITNESS_SIZE, WITNESS_STATIC_SIZE, WORD_SIZE},
    traits::Signer,
    types::{
        bech32::Bech32Address,
        coin::Coin,
        coin_type::CoinType,
        errors::{error, error_transaction, Result},
        input::Input,
        message::Message,
        transaction::{
            CreateTransaction, EstimablePredicates, ScriptTransaction, Transaction, TxPolicies,
        },
        Address, AssetId, ContractId,
    },
    utils::{calculate_witnesses_size, sealed},
};

use crate::types::transaction_builders::DryRun;
use crate::types::transaction_builders::DryRunner;

pub(crate) struct ScriptDryRunner<R> {
    pub(crate) dry_runner: R,
    pub(crate) cache: HashMap<fuel_tx::Script, DryRun>,
    pub(crate) num_total_witnesses: usize,
}

impl<R> ScriptDryRunner<R> {
    pub fn new(dry_runner: R, num_total_witnesses: usize) -> Self {
        Self {
            dry_runner,
            cache: HashMap::new(),
            num_total_witnesses,
        }
    }
}

impl<R: DryRunner> ScriptDryRunner<R> {
    pub async fn run(&mut self, mut tx: fuel_tx::Script) -> Result<DryRun> {
        self.add_fake_witnesses(&mut tx);
        self.add_fake_coins(&mut tx);
        self.saturate_with_variable_outputs(&mut tx);
        self.set_script_gas_limit_to_max(&mut tx);

        self.cached_or_run(tx).await
    }

    pub(crate) fn set_script_gas_limit_to_max(&mut self, tx: &mut fuel_tx::Script) {
        let consensus_params = self.dry_runner.consensus_parameters();
        let max_gas = tx.max_gas(consensus_params.gas_costs(), consensus_params.fee_params()) + 1;
        *tx.script_gas_limit_mut() = consensus_params.tx_params().max_gas_per_tx() - max_gas;
    }

    pub(crate) fn saturate_with_variable_outputs(&mut self, tx: &mut fuel_tx::Script) {
        let consensus_params = self.dry_runner.consensus_parameters();
        let free_outputs = consensus_params
            .tx_params()
            .max_outputs()
            .saturating_sub(u16::try_from(tx.outputs().len()).unwrap_or(u16::MAX));
        tx.outputs_mut().extend(
            repeat(Output::Variable {
                amount: 0,
                to: Address::zeroed(),
                asset_id: AssetId::zeroed(),
            })
            .take(free_outputs as usize),
        );
    }

    // When dry running a tx with `utxo_validation` off, the node will not validate signatures.
    // However, the node will check if the right number of witnesses is present.
    // This function will create witnesses from a default `Signature` such that the total length matches the expected one.
    // Using a `Signature` ensures that the calculated fee includes the fee generated by the witnesses.
    pub(crate) fn add_fake_witnesses(&mut self, tx: &mut fuel_tx::Script) {
        let witness: Witness = Signature::default().as_ref().into();
        let dry_run_witnesses: Vec<_> = repeat(witness).take(self.num_total_witnesses).collect();

        *tx.witnesses_mut() = dry_run_witnesses;
    }

    pub(crate) fn add_fake_coins(&mut self, tx: &mut fuel_tx::Script) {
        let consensus_params = self.dry_runner.consensus_parameters();
        if let Some(fake_input) =
            Self::needs_fake_base_input(tx.inputs(), consensus_params.base_asset_id())
        {
            tx.inputs_mut().push(fake_input);

            // Add an empty `Witness` for the `coin_signed` we just added
            tx.witnesses_mut().push(Witness::default());
            tx.set_witness_limit(tx.witness_limit() + WITNESS_STATIC_SIZE as u64);
        }
    }

    pub(crate) fn needs_fake_base_input(
        inputs: &[FuelInput],
        base_asset_id: &AssetId,
    ) -> Option<fuel_tx::Input> {
        let has_base_asset = inputs.iter().any(|i| match i {
            FuelInput::CoinSigned(CoinSigned { asset_id, .. })
            | FuelInput::CoinPredicate(CoinPredicate { asset_id, .. })
                if asset_id == base_asset_id =>
            {
                true
            }
            FuelInput::MessageCoinSigned(_) | FuelInput::MessageCoinPredicate(_) => true,
            _ => false,
        });

        if has_base_asset {
            return None;
        }

        let unique_owners = inputs
            .iter()
            .filter_map(|input| match input {
                FuelInput::CoinSigned(CoinSigned { owner, .. })
                | FuelInput::CoinPredicate(CoinPredicate { owner, .. }) => Some(owner),
                _ => None,
            })
            .unique()
            .collect::<Vec<_>>();

        let fake_owner = if let [single_owner] = unique_owners.as_slice() {
            **single_owner
        } else {
            Default::default()
        };

        Some(FuelInput::coin_signed(
            Default::default(),
            fake_owner,
            1_000_000_000,
            Default::default(),
            TxPointer::default(),
            0,
        ))
    }

    pub(crate) async fn cached_or_run(&mut self, tx: fuel_tx::Script) -> Result<DryRun> {
        if let Some(result) = self.cache.get(&tx) {
            return Ok(*result);
        }

        let result = self.dry_runner.dry_run(tx.clone().into()).await?;
        self.cache.insert(tx, result);

        Ok(result)
    }
}
