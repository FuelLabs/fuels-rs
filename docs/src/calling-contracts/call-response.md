# Call response

You've probably noticed that you're often chaining `.call().await.unwrap()`. That's because:

1. You have to choose between `.call()` and `.simulate()` (more on this in the next section);
2. Contract calls are asynchronous, so you can choose to either `.await` it or perform concurrent tasks, making full use of Rust's async;
3. `.unwrap()` the `Result<CallResponse, Error>` returned by the contract call.

Once you unwrap the `CallResponse`, you have access to this struct:

```rust,ignore
{{#include ../../../packages/fuels-contract/src/contract.rs:call_response}}
```

Where `value` will hold the value returned by its respective contract method, represented by the exact type returned by the FuelVM, E.g., if your contract returns a FuelVM's `u64`, `value`'s `D` will be a `u64`. If it's a FuelVM's tuple `(u8,bool)`, then `D` will be a `(u8,bool)`. If it's a custom type, for instance, a Sway struct `MyStruct` containing two components, a `u64`, and a `b256`, `D` will be a struct generated at compile-time, called `MyStruct` with `u64` and a `[u8; 32]` (the equivalent of `b256` in Rust-land).

`receipts` will hold all [receipts](https://github.com/FuelLabs/fuel-specs/blob/master/specs/protocol/abi.md#receipt) generated by that specific contract call.

And lastly, `logs` will hold all logs that happened within that specific contract call.

To log out `receipts` values during testing, you have to run `test` as follows:

```sh
RUST_LOG=receipts cargo test --test harness $NAME_OF_TEST
```
