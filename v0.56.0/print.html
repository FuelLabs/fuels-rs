<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Fuel Rust SDK</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">The Fuel Rust SDK</a></li><li class="chapter-item expanded "><a href="getting-started.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li class="chapter-item expanded "><a href="connecting/index.html"><strong aria-hidden="true">2.</strong> Connecting to a Fuel node</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="connecting/external-node.html"><strong aria-hidden="true">2.1.</strong> Connecting to the Testnet or an external node</a></li><li class="chapter-item expanded "><a href="connecting/short-lived.html"><strong aria-hidden="true">2.2.</strong> Running a short-lived Fuel node with the SDK</a></li><li class="chapter-item expanded "><a href="connecting/rocksdb.html"><strong aria-hidden="true">2.3.</strong> RocksDB</a></li><li class="chapter-item expanded "><a href="connecting/querying.html"><strong aria-hidden="true">2.4.</strong> Querying the blockchain</a></li><li class="chapter-item expanded "><a href="connecting/retrying.html"><strong aria-hidden="true">2.5.</strong> Retrying upon errors</a></li></ol></li><li class="chapter-item expanded "><a href="accounts.html"><strong aria-hidden="true">3.</strong> Accounts</a></li><li class="chapter-item expanded "><a href="wallets/index.html"><strong aria-hidden="true">4.</strong> Managing wallets</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="wallets/private-keys.html"><strong aria-hidden="true">4.1.</strong> Creating a wallet from a private key</a></li><li class="chapter-item expanded "><a href="wallets/mnemonic-wallet.html"><strong aria-hidden="true">4.2.</strong> Creating a wallet from mnemonic phrases</a></li><li class="chapter-item expanded "><a href="wallets/access.html"><strong aria-hidden="true">4.3.</strong> Wallet Access</a></li><li class="chapter-item expanded "><a href="wallets/encrypting-and-storing.html"><strong aria-hidden="true">4.4.</strong> Encrypting and storing wallets</a></li><li class="chapter-item expanded "><a href="wallets/checking-balances-and-coins.html"><strong aria-hidden="true">4.5.</strong> Checking balances and coins</a></li><li class="chapter-item expanded "><a href="wallets/test-wallets.html"><strong aria-hidden="true">4.6.</strong> Setting up test wallets</a></li><li class="chapter-item expanded "><a href="wallets/signing.html"><strong aria-hidden="true">4.7.</strong> Signing</a></li></ol></li><li class="chapter-item expanded "><a href="abigen/index.html"><strong aria-hidden="true">5.</strong> Generating bindings with abigen!</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="abigen/the-json-abi-file.html"><strong aria-hidden="true">5.1.</strong> The JSON ABI file</a></li><li class="chapter-item expanded "><a href="abigen/the-abigen-macro.html"><strong aria-hidden="true">5.2.</strong> The abigen! macro</a></li></ol></li><li class="chapter-item expanded "><a href="deploying/index.html"><strong aria-hidden="true">6.</strong> Deploying contracts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="deploying/configurable-constants.html"><strong aria-hidden="true">6.1.</strong> Configurable constants</a></li><li class="chapter-item expanded "><a href="deploying/storage-slots.html"><strong aria-hidden="true">6.2.</strong> Storage slots</a></li><li class="chapter-item expanded "><a href="deploying/interacting-with-contracts.html"><strong aria-hidden="true">6.3.</strong> Interacting with contracts</a></li><li class="chapter-item expanded "><a href="deploying/the-fuelvm-binary-file.html"><strong aria-hidden="true">6.4.</strong> The FuelVM Binary file</a></li></ol></li><li class="chapter-item expanded "><a href="calling-contracts/index.html"><strong aria-hidden="true">7.</strong> Calling contracts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="calling-contracts/calls-with-different-wallets.html"><strong aria-hidden="true">7.1.</strong> Connecting wallets</a></li><li class="chapter-item expanded "><a href="calling-contracts/tx-policies.html"><strong aria-hidden="true">7.2.</strong> Transaction policies</a></li><li class="chapter-item expanded "><a href="calling-contracts/call-params.html"><strong aria-hidden="true">7.3.</strong> Call parameters</a></li><li class="chapter-item expanded "><a href="calling-contracts/custom-asset-transfer.html"><strong aria-hidden="true">7.4.</strong> Custom asset transfer</a></li><li class="chapter-item expanded "><a href="calling-contracts/call-response.html"><strong aria-hidden="true">7.5.</strong> Call response</a></li><li class="chapter-item expanded "><a href="calling-contracts/logs.html"><strong aria-hidden="true">7.6.</strong> Logs</a></li><li class="chapter-item expanded "><a href="calling-contracts/variable-outputs.html"><strong aria-hidden="true">7.7.</strong> Variable outputs and messages</a></li><li class="chapter-item expanded "><a href="calling-contracts/read-only.html"><strong aria-hidden="true">7.8.</strong> Read-only calls</a></li><li class="chapter-item expanded "><a href="calling-contracts/other-contracts.html"><strong aria-hidden="true">7.9.</strong> Calling other contracts</a></li><li class="chapter-item expanded "><a href="calling-contracts/multicalls.html"><strong aria-hidden="true">7.10.</strong> Multiple contract calls</a></li><li class="chapter-item expanded "><a href="calling-contracts/tx-dependency-estimation.html"><strong aria-hidden="true">7.11.</strong> Transaction dependency estimation</a></li><li class="chapter-item expanded "><a href="calling-contracts/cost-estimation.html"><strong aria-hidden="true">7.12.</strong> Estimating cost</a></li><li class="chapter-item expanded "><a href="calling-contracts/low-level-calls.html"><strong aria-hidden="true">7.13.</strong> Low-level calls</a></li></ol></li><li class="chapter-item expanded "><a href="running-scripts.html"><strong aria-hidden="true">8.</strong> Running scripts</a></li><li class="chapter-item expanded "><a href="predicates/index.html"><strong aria-hidden="true">9.</strong> Predicates</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="predicates/send-spend-predicate.html"><strong aria-hidden="true">9.1.</strong> Signatures example</a></li></ol></li><li class="chapter-item expanded "><a href="custom-transactions/index.html"><strong aria-hidden="true">10.</strong> Custom transactions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="custom-transactions/transaction-builders.html"><strong aria-hidden="true">10.1.</strong> Transaction builders</a></li><li class="chapter-item expanded "><a href="custom-transactions/custom-calls.html"><strong aria-hidden="true">10.2.</strong> Custom contract and script calls</a></li></ol></li><li class="chapter-item expanded "><a href="types/index.html"><strong aria-hidden="true">11.</strong> Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="types/bytes32.html"><strong aria-hidden="true">11.1.</strong> Bytes32</a></li><li class="chapter-item expanded "><a href="types/address.html"><strong aria-hidden="true">11.2.</strong> Address</a></li><li class="chapter-item expanded "><a href="types/contract-id.html"><strong aria-hidden="true">11.3.</strong> ContractId</a></li><li class="chapter-item expanded "><a href="types/asset-id.html"><strong aria-hidden="true">11.4.</strong> AssetId</a></li><li class="chapter-item expanded "><a href="types/bech32.html"><strong aria-hidden="true">11.5.</strong> Bech32</a></li><li class="chapter-item expanded "><a href="types/custom_types.html"><strong aria-hidden="true">11.6.</strong> Structs and enums</a></li><li class="chapter-item expanded "><a href="types/string.html"><strong aria-hidden="true">11.7.</strong> String</a></li><li class="chapter-item expanded "><a href="types/bits256.html"><strong aria-hidden="true">11.8.</strong> Bits256</a></li><li class="chapter-item expanded "><a href="types/bytes.html"><strong aria-hidden="true">11.9.</strong> Bytes</a></li><li class="chapter-item expanded "><a href="types/B512.html"><strong aria-hidden="true">11.10.</strong> B512</a></li><li class="chapter-item expanded "><a href="types/evm_address.html"><strong aria-hidden="true">11.11.</strong> EvmAddress</a></li><li class="chapter-item expanded "><a href="types/vectors.html"><strong aria-hidden="true">11.12.</strong> Vectors</a></li><li class="chapter-item expanded "><a href="types/conversion.html"><strong aria-hidden="true">11.13.</strong> Converting types</a></li></ol></li><li class="chapter-item expanded "><a href="codec/index.html"><strong aria-hidden="true">12.</strong> Codec</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="codec/encoding.html"><strong aria-hidden="true">12.1.</strong> Encoding</a></li><li class="chapter-item expanded "><a href="codec/decoding.html"><strong aria-hidden="true">12.2.</strong> Decoding</a></li></ol></li><li class="chapter-item expanded "><a href="reference.html"><strong aria-hidden="true">13.</strong> API Reference</a></li><li class="chapter-item expanded "><a href="testing/index.html"><strong aria-hidden="true">14.</strong> Testing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="testing/basics.html"><strong aria-hidden="true">14.1.</strong> Testing basics</a></li><li class="chapter-item expanded "><a href="testing/the-setup-program-test-macro.html"><strong aria-hidden="true">14.2.</strong> The setup_program_test! macro</a></li><li class="chapter-item expanded "><a href="testing/chains.html"><strong aria-hidden="true">14.3.</strong> Tweaking the blockchain</a></li></ol></li><li class="chapter-item expanded "><a href="cookbook/index.html"><strong aria-hidden="true">15.</strong> Cookbook</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="cookbook/custom-chain.html"><strong aria-hidden="true">15.1.</strong> Custom consensus parameters</a></li><li class="chapter-item expanded "><a href="cookbook/deposit-and-withdraw.html"><strong aria-hidden="true">15.2.</strong> Deposit and Withdraw</a></li><li class="chapter-item expanded "><a href="cookbook/transfer-all-assets.html"><strong aria-hidden="true">15.3.</strong> Transfer all assets</a></li></ol></li><li class="chapter-item expanded "><a href="debugging/index.html"><strong aria-hidden="true">16.</strong> Debugging</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="debugging/function-selector.html"><strong aria-hidden="true">16.1.</strong> The Function selector</a></li></ol></li><li class="chapter-item expanded "><a href="glossary.html"><strong aria-hidden="true">17.</strong> Glossary</a></li><li class="chapter-item expanded "><a href="contributing/CONTRIBUTING.html"><strong aria-hidden="true">18.</strong> Contributing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="contributing/tests-structure.html"><strong aria-hidden="true">18.1.</strong> Integration tests structure</a></li></ol></li><li class="chapter-item expanded "><a href="cli/index.html"><strong aria-hidden="true">19.</strong> Command Line Interfaces</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="cli/fuels-abi-cli.html"><strong aria-hidden="true">19.1.</strong> fuels-abi-cli</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Fuel Rust SDK</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/FuelLabs/fuels-rs" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="the-fuel-rust-sdk"><a class="header" href="#the-fuel-rust-sdk">The Fuel Rust SDK</a></h1>
<!-- This section should explain what the Fuel Rust SDK can be used for -->
<!-- fuels_rs:example:start -->
<p>The Fuel Rust SDK can be used for a variety of things, including:</p>
<ul>
<li>Compiling, deploying, and testing <a href="https://github.com/FuelLabs/sway">Sway</a> contracts</li>
<li>Using the testnet or running a local Fuel node</li>
<li>Crafting and signing transactions with hand-crafted scripts or contract calls</li>
<li>Generating type-safe Rust bindings of contract ABI methods</li>
</ul>
<!-- fuels_rs:example:end -->
<p>This book is an overview of the different things one can achieve using the Rust SDK, and how to implement them. Keep in mind that both the SDK and the documentation are works-in-progress!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<h2 id="installation-guide"><a class="header" href="#installation-guide">Installation Guide</a></h2>
<p>Please visit the Fuel <a href="https://docs.fuel.network/guides/installation">installation guide</a> to install the Fuel toolchain binaries and prerequisites.</p>
<p><code>forc</code> is Sway equivalent of Rust's <code>cargo</code>. <code>fuel-core</code> is a Fuel full node implementation.</p>
<p>There are two main ways you can use the Fuel Rust SDK:</p>
<ol>
<li>Creating a new Sway project with <code>forc</code> and running the tests</li>
<li>Creating a standalone project and importing the <code>fuels-rs</code> crate</li>
</ol>
<h2 id="creating-a-new-project-with-forc"><a class="header" href="#creating-a-new-project-with-forc">Creating a new project with Forc</a></h2>
<p>You can create a new Sway project with</p>
<pre><code class="language-shell">forc new &lt;Project name&gt;
</code></pre>
<p>Or you can initialize a project within an existing folder with</p>
<pre><code class="language-shell">forc init
</code></pre>
<h3 id="adding-a-rust-integration-test-to-the-sway-project"><a class="header" href="#adding-a-rust-integration-test-to-the-sway-project">Adding a Rust integration test to the Sway project</a></h3>
<p>Now that we have a new project, we can add a Rust integration test using a <code>cargo generate</code> template.
If <code>cargo generate</code> is not already installed, you can instal it with:</p>
<!-- This section should have the command to install cargo generate -->
<!-- cargo_gen_install:example:start -->
<pre><code class="language-shell">cargo install cargo-generate
</code></pre>
<!-- cargo_gen_install:example:end -->
<blockquote>
<p><strong>Note</strong> You can learn more about cargo generate by visiting its <a href="https://github.com/cargo-generate/cargo-generate">repository</a>.</p>
</blockquote>
<p>Let's generate the default test harness with the following command:</p>
<!-- This section should have the command to cargo generate a test harness -->
<!-- cargo_gen:example:start -->
<pre><code class="language-shell">cargo generate --init fuellabs/sway templates/sway-test-rs --name &lt;Project name&gt; --force
</code></pre>
<!-- cargo_gen:example:end -->
<!-- This section should explain the `--force` flag -->
<!-- force_flag:example:start -->
<p><code>--force</code> forces your <code>--name</code> input to retain your desired casing for the <code>{{project-name}}</code> placeholder in the template. Otherwise, <code>cargo-generate</code> automatically converts it to kebab-case. With <code>--force</code>, this means that both <code>my_fuel_project</code> and <code>my-fuel-project</code> are valid project names, depending on your needs.</p>
<!-- force_flag:example:end -->
<p>Before running test, we need to build the Sway project with:</p>
<pre><code class="language-shell">forc build
</code></pre>
<p>Afterwards, we can run the test with:</p>
<!-- This section should have the command to run a test -->
<!-- run_test:example:start -->
<pre><code class="language-shell">cargo test
</code></pre>
<!-- run_test:example:end -->
<blockquote>
<p><strong>Note</strong> If you need to capture output from the tests, use one of the following commands:</p>
</blockquote>
<!-- This section should have the command to run a test with no capture -->
<!-- run_test_nocap:example:start -->
<pre><code class="language-shell">cargo test -- --nocapture
</code></pre>
<!-- run_test_nocap:example:end -->
<h2 id="importing-the-fuel-rust-sdk"><a class="header" href="#importing-the-fuel-rust-sdk">Importing the Fuel Rust SDK</a></h2>
<p>Add these dependencies on your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">fuels = &quot;{{versions.fuels}}&quot;
</code></pre>
<blockquote>
<p><strong>Note</strong> We're using version <code>{{versions.fuels}}</code> of the SDK, which is the latest version at the time of this writing.</p>
</blockquote>
<p>And then, in your Rust file that's going to make use of the SDK:</p>
<pre><code class="language-rust ignore">use fuels::prelude::*;
</code></pre>
<h2 id="the-fuel-rust-sdk-source-code"><a class="header" href="#the-fuel-rust-sdk-source-code">The Fuel Rust SDK source code</a></h2>
<p>Another way to experience the SDK is to look at the source code. The <code>packages/fuels/tests/</code> folder is full of integration tests that go through almost all aspects of the SDK.</p>
<blockquote>
<p><strong>Note</strong> Before running the tests, we need to build all the Sway test projects. The file <code>packages/fuels/Forc.toml</code> contains a `[workspace], which members are the paths to all integration tests.
To build these tests, run the following command:</p>
</blockquote>
<pre><code class="language-shell">forc build --path packages/fuels
</code></pre>
<blockquote>
<p><code>forc</code> can also be used to clean and format the test projects. Check the <code>help</code> output for more info.</p>
</blockquote>
<p>After building the projects, we can run the tests with</p>
<pre><code class="language-shell">cargo test
</code></pre>
<p>If you need all targets and all features, you can run</p>
<pre><code class="language-shell">cargo test --all-targets --all-features
</code></pre>
<blockquote>
<p><strong>Note</strong> If you need to capture output from the tests, you can run</p>
</blockquote>
<pre><code class="language-shell">cargo test -- --nocapture
</code></pre>
<h2 id="more-in-depth-fuel-and-sway-knowledge"><a class="header" href="#more-in-depth-fuel-and-sway-knowledge">More in-depth Fuel and Sway knowledge</a></h2>
<p>Read <a href="https://docs.fuel.network/docs/sway/">The Sway Book</a> for more in-depth knowledge about Sway, the official smart contract language for the Fuel Virtual Machine.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="connecting-to-a-fuel-node"><a class="header" href="#connecting-to-a-fuel-node">Connecting to a Fuel node</a></h1>
<!-- This section should explain at a high level the main ways to connect to a node with the Rust SDK and when they are appropriate to use-->
<!-- rs_node:example:start -->
<p>At a high level, you can use the Fuel Rust SDK to build Rust-based applications that can run computations on the Fuel Virtual Machine through interactions with smart contracts written in Sway.</p>
<p>For this interaction to work, the SDK must be able to communicate with a <code>fuel-core</code> node; you have two options at your disposal:</p>
<ol>
<li>Use the testnet or run a Fuel node (using <code>fuel-core</code>) and instantiate a provider that points to that node's IP and port.</li>
<li>Use the SDK's native <code>launch_provider_and_get_wallet()</code> that runs a short-lived test Fuel node;</li>
</ol>
<p>The second option is ideal for smart contract testing, as you can quickly spin up and tear down nodes between specific test cases.</p>
<p>For application building, you should use the first option.</p>
<!-- rs_node:example:end -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="connecting-to-the-testnet-or-an-external-node"><a class="header" href="#connecting-to-the-testnet-or-an-external-node">Connecting to the Testnet or an external node</a></h1>
<p>We can interact with the <code>Testnet</code> node by using the following example.</p>
<pre><code class="language-rust ignore">        use std::str::FromStr;

        use fuels::{crypto::SecretKey, prelude::*};

        // Create a provider pointing to the testnet.
        // This example will not work as the testnet does not support the new version of fuel-core
        // yet
        let provider = Provider::connect(&quot;beta-4.fuel.network&quot;).await.unwrap();

        // Setup a private key
        let secret = SecretKey::from_str(
            &quot;a1447cd75accc6b71a976fd3401a1f6ce318d27ba660b0315ee6ac347bf39568&quot;,
        )?;

        // Create the wallet
        let wallet = WalletUnlocked::new_from_private_key(secret, Some(provider));

        // Get the wallet address. Used later with the faucet
        dbg!(wallet.address().to_string());
</code></pre>
<blockquote>
<p>For detailed information about various testnet networks and their optimal toolchain configurations for your project, please visit the following link:</p>
<p><a href="https://fuelbook.fuel.network/master/networks/networks.html">networks</a></p>
</blockquote>
<p>In the code example, we connected a new provider to the Testnet node and created a new wallet from a private key.</p>
<blockquote>
<p><strong>Note:</strong> New wallets on the Testnet will not have any assets! They can be obtained by providing the wallet address to the faucet at</p>
<p><a href="https://faucet-beta-4.fuel.network">faucet-beta-4.fuel.network</a></p>
<p>Once the assets have been transferred to the wallet, you can reuse it in other tests by providing the private key!</p>
<p>In addition to the faucet, there is a block explorer for the Testnet at</p>
<p><a href="https://fuellabs.github.io/block-explorer-v2">block-explorer</a></p>
</blockquote>
<p>If you want to connect to another node just change the URL or IP and port. For example, to connect to a local node that was created with <code>fuel-core</code> you can use:</p>
<pre><code class="language-rust ignore">        let _provider = Provider::connect(format!(&quot;127.0.0.1:{port}&quot;)).await?;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="running-a-short-lived-fuel-node-with-the-sdk"><a class="header" href="#running-a-short-lived-fuel-node-with-the-sdk">Running a short-lived Fuel node with the SDK</a></h1>
<p>You can use the SDK to spin up a local, ideally short-lived Fuel node. Then, you can instantiate a Fuel client, pointing to this node.</p>
<pre><code class="language-rust ignore">        use fuels::prelude::{FuelService, Provider};

        // Run the fuel node.
        let server = FuelService::start(Config::default()).await?;

        // Create a client that will talk to the node created above.
        let client = Provider::from(server.bound_address()).await?;
        assert!(client.healthy().await?);
</code></pre>
<p>This approach is ideal for contract testing.</p>
<p>You can also use the test helper <code>setup_test_provider()</code> for this:</p>
<pre><code class="language-rust ignore">        use fuels::prelude::*;

        // Use the test helper to setup a test provider.
        let provider = setup_test_provider(vec![], vec![], None, None).await?;

        // Create the wallet.
        let _wallet = WalletUnlocked::new_random(Some(provider));
</code></pre>
<p>You can also use <code>launch_provider_and_get_wallet()</code>, which abstracts away the <code>setup_test_provider()</code> and the wallet creation, all in one single method:</p>
<pre><code class="language-rust ignore">let wallet = launch_provider_and_get_wallet().await?;
</code></pre>
<h2 id="features"><a class="header" href="#features">Features</a></h2>
<h3 id="fuel-core-lib"><a class="header" href="#fuel-core-lib">Fuel-core lib</a></h3>
<p>The <code>fuel-core-lib</code> feature allows us to run a <code>fuel-core</code> node without installing the <code>fuel-core</code> binary on the local machine. Using the <code>fuel-core-lib</code> feature flag entails downloading all the dependencies needed to run the fuel-core node.</p>
<pre><code class="language-rust ignore">fuels = { version = &quot;0.56.0&quot;, features = [&quot;fuel-core-lib&quot;] }
</code></pre>
<h3 id="rocksdb"><a class="header" href="#rocksdb">RocksDB</a></h3>
<p>The <code>rocksdb</code> is an additional feature that, when combined with <code>fuel-core-lib</code>, provides persistent storage capabilities while using <code>fuel-core</code> as a library.</p>
<pre><code class="language-rust ignore">fuels = { version = &quot;0.56.0&quot;, features = [&quot;rocksdb&quot;] }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rocksdb-1"><a class="header" href="#rocksdb-1">RocksDB</a></h1>
<p>RocksDB enables the preservation of the blockchain's state locally, facilitating its future utilization.</p>
<p>To create or use a local database, follow these instructions:</p>
<pre><code class="language-rust ignore">        let provider_config = Config {
            database_type: DbType::RocksDb(Some(PathBuf::from(&quot;/tmp/.spider/db&quot;))),
            ..Config::default()
        };
</code></pre>
<blockquote>
<p>Note: If the specified database does not exist, a new database will be created at that path. To utilize the code snippets above, either the <code>fuel-core</code> binary must be present, or both the <code>fuel-core-lib</code> and <code>rocksdb</code> features need to be enabled.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="querying-the-blockchain"><a class="header" href="#querying-the-blockchain">Querying the blockchain</a></h1>
<p>Once you set up a provider, you can interact with the Fuel blockchain. Here are a few examples of what you can do with a provider; for a more in-depth overview of the API, check the <a href="https://docs.rs/fuels/latest/fuels/accounts/provider/struct.Provider.html">official provider API documentation</a>.</p>
<ul>
<li><a href="connecting/querying.html#set-up">Set up</a></li>
<li><a href="connecting/querying.html#get-all-coins-from-an-address">Get all coins from an address</a></li>
<li><a href="connecting/querying.html#get-spendable-resources-owned-by-an-address">Get spendable resources owned by an address</a></li>
<li><a href="connecting/querying.html#get-balances-from-an-address">Get balances from an address</a></li>
</ul>
<h2 id="set-up"><a class="header" href="#set-up">Set up</a></h2>
<p>You might need to set up a test blockchain first. You can skip this step if you're connecting to an external blockchain.</p>
<pre><code class="language-rust ignore">        use fuels::prelude::*;

        // Set up our test blockchain.

        // Create a random wallet (more on wallets later).
        let wallet = WalletUnlocked::new_random(None);

        // How many coins in our wallet.
        let number_of_coins = 1;

        // The amount/value in each coin in our wallet.
        let amount_per_coin = 3;

        let coins = setup_single_asset_coins(
            wallet.address(),
            BASE_ASSET_ID,
            number_of_coins,
            amount_per_coin,
        );

        let retry_config = RetryConfig::new(3, Backoff::Fixed(Duration::from_secs(2)))?;
        let provider = setup_test_provider(coins.clone(), vec![], None, None)
            .await?
            .with_retry_config(retry_config);
</code></pre>
<h2 id="get-all-coins-from-an-address"><a class="header" href="#get-all-coins-from-an-address">Get all coins from an address</a></h2>
<p>This method returns all unspent coins (of a given asset ID) from a wallet.</p>
<pre><code class="language-rust ignore">        let coins = provider.get_coins(wallet.address(), BASE_ASSET_ID).await?;
        assert_eq!(coins.len(), 1);
</code></pre>
<h2 id="get-spendable-resources-owned-by-an-address"><a class="header" href="#get-spendable-resources-owned-by-an-address">Get spendable resources owned by an address</a></h2>
<p>The following example shows how to fetch resources owned by an address. First, you create a  <code>ResourceFilter</code> which specifies the target address, asset ID, and amount. You can also define UTXO IDs and message IDs that should be excluded when retrieving the resources:</p>
<pre><code class="language-rust ignore">pub struct ResourceFilter {
    pub from: Bech32Address,
    pub asset_id: AssetId,
    pub amount: u64,
    pub excluded_utxos: Vec&lt;UtxoId&gt;,
    pub excluded_message_nonces: Vec&lt;Nonce&gt;,
}
</code></pre>
<p>The example uses default values for the asset ID and the exclusion lists. This resolves to the base asset ID and empty vectors for the ID lists respectively:</p>
<pre><code class="language-rust ignore">        let filter = ResourceFilter {
            from: wallet.address().clone(),
            amount: 1,
            ..Default::default()
        };
        let spendable_resources = provider.get_spendable_resources(filter).await?;
        assert_eq!(spendable_resources.len(), 1);
</code></pre>
<h2 id="get-balances-from-an-address"><a class="header" href="#get-balances-from-an-address">Get balances from an address</a></h2>
<p>Get all the spendable balances of all assets for an address. This is different from getting the coins because we only return the numbers (the sum of UTXOs coins amount for each asset ID) and not the UTXOs coins themselves.</p>
<pre><code class="language-rust ignore">        let _balances = provider.get_balances(wallet.address()).await?;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="retrying-requests"><a class="header" href="#retrying-requests">Retrying requests</a></h1>
<p>The <a href="https://docs.rs/fuels/0.47.0/fuels/accounts/provider/struct.Provider.html"><code>Provider</code></a> can be configured to retry a request upon receiving a <code>io::Error</code>.</p>
<blockquote>
<p>Note: Currently all node errors are received as <code>io::Error</code>s. So, if configured, a retry will happen even if, for example, a transaction failed to verify.</p>
</blockquote>
<p>We can configure the number of retry attempts and the retry strategy as detailed below.</p>
<h2 id="retryconfig"><a class="header" href="#retryconfig"><code>RetryConfig</code></a></h2>
<p>The retry behavior can be altered by giving a custom <code>RetryConfig</code>. It allows for configuring the maximum number of attempts and the interval strategy used.</p>
<pre><code class="language-rust  ignore">#[derive(Clone, Debug)]
pub struct RetryConfig {
    max_attempts: NonZeroU32,
    interval: Backoff,
}
</code></pre>
<pre><code class="language-rust  ignore">        let retry_config = RetryConfig::new(3, Backoff::Fixed(Duration::from_secs(2)))?;
        let provider = setup_test_provider(coins.clone(), vec![], None, None)
            .await?
            .with_retry_config(retry_config);
</code></pre>
<h2 id="interval-strategy---backoff"><a class="header" href="#interval-strategy---backoff">Interval strategy - <code>Backoff</code></a></h2>
<p><code>Backoff</code> defines different strategies for managing intervals between retry attempts.
Each strategy allows you to customize the waiting time before a new attempt based on the number of attempts made.</p>
<h3 id="variants"><a class="header" href="#variants">Variants</a></h3>
<ul>
<li><code>Linear(Duration)</code>: <code>Default</code> Increases the waiting time linearly with each attempt.</li>
<li><code>Exponential(Duration)</code>: Doubles the waiting time with each attempt.</li>
<li><code>Fixed(Duration)</code>: Uses a constant waiting time between attempts.</li>
</ul>
<pre><code class="language-rust  ignore">#[derive(Debug, Clone)]
pub enum Backoff {
    Linear(Duration),
    Exponential(Duration),
    Fixed(Duration),
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="accounts"><a class="header" href="#accounts">Accounts</a></h1>
<p>The <code>ViewOnlyAccount</code> trait provides a common interface to query balances.</p>
<p>The <code>Account</code> trait, in addition to the above, also provides a common interface to retrieve spendable resources or transfer assets. When performing actions in the SDK that lead to a transaction, you will typically need to provide an account that will be used to allocate resources required by the transaction, including transaction fees.</p>
<p>Both traits are implemented by the following types:</p>
<ul>
<li><a href="./wallets/index.html">Wallet</a></li>
<li><a href="./predicates/index.html">Predicate</a></li>
</ul>
<h2 id="transferring-assets"><a class="header" href="#transferring-assets">Transferring assets</a></h2>
<p>An account implements the following methods for transferring assets:</p>
<ul>
<li><code>transfer</code></li>
<li><code>force_transfer_to_contract</code></li>
<li><code>withdraw_to_base_layer</code></li>
</ul>
<p>The following examples are provided for a <code>Wallet</code> account. A <code>Predicate</code> account would work similarly, but you might need to set its predicate data before attempting to spend resources owned by it.</p>
<p>With <code>wallet.transfer</code> you can initiate a transaction to transfer an asset from your account to a target address.</p>
<pre><code class="language-rust ignore">        use fuels::prelude::*;

        // Setup 2 test wallets with 1 coin each
        let num_wallets = Some(2);
        let coins_per_wallet = Some(1);
        let coin_amount = Some(1);

        let wallets = launch_custom_provider_and_get_wallets(
            WalletsConfig::new(num_wallets, coins_per_wallet, coin_amount),
            None,
            None,
        )
        .await?;

        // Transfer the base asset with amount 1 from wallet 1 to wallet 2
        let asset_id = Default::default();
        let (_tx_id, _receipts) = wallets[0]
            .transfer(wallets[1].address(), 1, asset_id, TxPolicies::default())
            .await?;

        let wallet_2_final_coins = wallets[1].get_coins(BASE_ASSET_ID).await?;

        // Check that wallet 2 now has 2 coins
        assert_eq!(wallet_2_final_coins.len(), 2);

</code></pre>
<p>You can transfer assets to a contract via <code>wallet.force_transfer_to_contract</code>.</p>
<pre><code class="language-rust ignore">        // Check the current balance of the contract with id 'contract_id'
        let contract_balances = wallet
            .try_provider()?
            .get_contract_balances(&amp;contract_id)
            .await?;
        assert!(contract_balances.is_empty());

        // Transfer an amount of 300 to the contract
        let amount = 300;
        let asset_id = random_asset_id;
        let (_tx_id, _receipts) = wallet
            .force_transfer_to_contract(&amp;contract_id, amount, asset_id, TxPolicies::default())
            .await?;

        // Check that the contract now has 1 coin
        let contract_balances = wallet
            .try_provider()?
            .get_contract_balances(&amp;contract_id)
            .await?;
        assert_eq!(contract_balances.len(), 1);

        let random_asset_balance = contract_balances.get(&amp;random_asset_id).unwrap();
        assert_eq!(*random_asset_balance, 300);
</code></pre>
<p>For transferring assets to the base layer chain, you can use <code>wallet.withdraw_to_base_layer</code>.</p>
<pre><code class="language-rust ignore">        use std::str::FromStr;

        use fuels::prelude::*;

        let wallets = launch_custom_provider_and_get_wallets(
            WalletsConfig::new(Some(1), None, None),
            None,
            None,
        )
        .await?;
        let wallet = wallets.first().unwrap();

        let amount = 1000;
        let base_layer_address = Address::from_str(
            &quot;0x4710162c2e3a95a6faff05139150017c9e38e5e280432d546fae345d6ce6d8fe&quot;,
        )?;
        let base_layer_address = Bech32Address::from(base_layer_address);
        // Transfer an amount of 1000 to the specified base layer address
        let (tx_id, msg_id, _receipts) = wallet
            .withdraw_to_base_layer(&amp;base_layer_address, amount, TxPolicies::default())
            .await?;

        let _block_height = wallet.try_provider()?.produce_blocks(1, None).await?;

        // Retrieve a message proof from the provider
        let proof = wallet
            .try_provider()?
            .get_message_proof(&amp;tx_id, &amp;msg_id, None, Some(2))
            .await?
            .expect(&quot;failed to retrieve message proof&quot;);

        // Verify the amount and recipient
        assert_eq!(proof.amount, amount);
        assert_eq!(proof.recipient, base_layer_address);
</code></pre>
<p>The above example creates an <code>Address</code> from a string and converts it to a <code>Bech32Address</code>. Next, it calls <code>wallet.withdraw_to_base_layer</code> by providing the address, the amount to be transferred, and the transaction policies. Lastly, to verify that the transfer succeeded, the relevant message proof is retrieved with <code>provider.get_message_proof,</code> and the amount and the recipient are verified.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="managing-wallets"><a class="header" href="#managing-wallets">Managing wallets</a></h1>
<!-- This section should explain in general how you can use a wallet in the SDK -->
<!-- wallets:example:start -->
<p>You can use wallets for many important things, for instance:</p>
<ol>
<li>Checking your balance</li>
<li>Transferring coins to a destination address or contract</li>
<li>Signing messages and transactions</li>
<li>Paying for network fees when sending transactions or deploying smart contracts</li>
</ol>
<!-- wallets:example:end -->
<p>The SDK gives you many different ways to create and access wallets. Let's explore these different approaches in the following sub-chapters.</p>
<!-- This section should provide best security practices for using wallets in the SDK -->
<!-- security:example:start -->
<blockquote>
<p><strong>Note:</strong> Keep in mind that you should never share your private/secret key. And in the case of wallets that were derived from a mnemonic phrase, never share your mnemonic phrase. If you're planning on storing the wallet on disk, do not store the plain private/secret key and do not store the plain mnemonic phrase. Instead, use <code>Wallet::encrypt</code> to encrypt its content first before saving it to disk.</p>
</blockquote>
<!-- security:example:end -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-a-wallet-from-a-private-key"><a class="header" href="#creating-a-wallet-from-a-private-key">Creating a wallet from a private key</a></h1>
<p>A new wallet with a randomly generated private key can be created by supplying <code>Option&lt;Provider&gt;</code>.</p>
<pre><code class="language-rust ignore">        use fuels::prelude::*;

        // Use the test helper to setup a test provider.
        let provider = setup_test_provider(vec![], vec![], None, None).await?;

        // Create the wallet.
        let _wallet = WalletUnlocked::new_random(Some(provider));
</code></pre>
<p>Alternatively, you can create a wallet from a predefined <code>SecretKey</code>.</p>
<pre><code class="language-rust ignore">        use std::str::FromStr;

        use fuels::{crypto::SecretKey, prelude::*};

        // Use the test helper to setup a test provider.
        let provider = setup_test_provider(vec![], vec![], None, None).await?;

        // Setup the private key.
        let secret = SecretKey::from_str(
            &quot;5f70feeff1f229e4a95e1056e8b4d80d0b24b565674860cc213bdb07127ce1b1&quot;,
        )?;

        // Create the wallet.
        let _wallet = WalletUnlocked::new_from_private_key(secret, Some(provider));
</code></pre>
<blockquote>
<p>Note: if <code>None</code> is supplied instead of a provider, any transaction related to the wallet will result
in an error until a provider is linked with <code>set_provider()</code>. The optional parameter
enables defining owners (wallet addresses) of genesis coins before a provider is launched.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-a-wallet-from-mnemonic-phrases"><a class="header" href="#creating-a-wallet-from-mnemonic-phrases">Creating a wallet from mnemonic phrases</a></h1>
<p>A mnemonic phrase is a cryptographically-generated sequence of words that's used to derive a private key. For instance: <code>&quot;oblige salon price punch saddle immune slogan rare snap desert retire surprise&quot;;</code> would generate the address <code>0xdf9d0e6c6c5f5da6e82e5e1a77974af6642bdb450a10c43f0c6910a212600185</code>.</p>
<p>In addition to that, we also support <a href="https://www.ledger.com/academy/crypto/what-are-hierarchical-deterministic-hd-wallets">Hierarchical Deterministic Wallets</a> and <a href="https://thebitcoinmanual.com/articles/btc-derivation-path/">derivation paths</a>. You may recognize the string <code>&quot;m/44'/60'/0'/0/0&quot;</code> from somewhere; that's a derivation path. In simple terms, it's a way to derive many wallets from a single root wallet.</p>
<p>The SDK gives you two wallets from mnemonic instantiation methods: one that takes a derivation path (<code>Wallet::new_from_mnemonic_phrase_with_path</code>) and one that uses the default derivation path, in case you don't want or don't need to configure that (<code>Wallet::new_from_mnemonic_phrase</code>).</p>
<p>Here's how you can create wallets with both mnemonic phrases and derivation paths:</p>
<pre><code class="language-rust ignore">        use fuels::prelude::*;

        let phrase =
            &quot;oblige salon price punch saddle immune slogan rare snap desert retire surprise&quot;;

        // Use the test helper to setup a test provider.
        let provider = setup_test_provider(vec![], vec![], None, None).await?;

        // Create first account from mnemonic phrase.
        let _wallet = WalletUnlocked::new_from_mnemonic_phrase_with_path(
            phrase,
            Some(provider.clone()),
            &quot;m/44'/1179993420'/0'/0/0&quot;,
        )?;

        // Or with the default derivation path
        let wallet = WalletUnlocked::new_from_mnemonic_phrase(phrase, Some(provider))?;

        let expected_address = &quot;fuel17x9kg3k7hqf42396vqenukm4yf59e5k0vj4yunr4mae9zjv9pdjszy098t&quot;;

        assert_eq!(wallet.address().to_string(), expected_address);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wallet-access"><a class="header" href="#wallet-access">Wallet Access</a></h1>
<!-- This section should explain the difference between the different types of wallets -->
<!-- wallet_types:example:start -->
<p>The kinds of operations we can perform with a <code>Wallet</code> instance depend on
whether or not we have access to the wallet's private key.</p>
<p>In order to differentiate between <code>Wallet</code> instances that know their private key
and those that do not, we use the <code>WalletUnlocked</code> and <code>Wallet</code> types
respectively.</p>
<!-- wallet_types:example:end -->
<h2 id="wallet-states"><a class="header" href="#wallet-states">Wallet States</a></h2>
<!-- This section should explain the unlocked wallet type -->
<!-- wallet_unlocked:example:start -->
<p>The <code>WalletUnlocked</code> type represents a wallet whose private key is known and
stored internally in memory. A wallet must be of type <code>WalletUnlocked</code> in order
to perform operations that involve signing messages or
transactions.</p>
<!-- wallet_unlocked:example:end -->
<p>You can learn more about signing <a href="wallets/./signing.html">here</a>.</p>
<!-- This section should explain the locked wallet type -->
<!-- wallet_locked:example:start -->
<p>The <code>Wallet</code> type represents a wallet whose private key is <em>not</em> known or stored
in memory. Instead, <code>Wallet</code> only knows its public address. A <code>Wallet</code> cannot be
used to sign transactions, however it may still perform a whole suite of useful
operations including listing transactions, assets, querying balances, and so on.</p>
<!-- wallet_locked:example:end -->
<p>Note that the <code>WalletUnlocked</code> type provides a <code>Deref</code> implementation targeting
its inner <code>Wallet</code> type. This means that all methods available on the <code>Wallet</code>
type are also available on the <code>WalletUnlocked</code> type. In other words,
<code>WalletUnlocked</code> can be thought of as a thin wrapper around <code>Wallet</code> that
provides greater access via its private key.</p>
<h2 id="transitioning-states"><a class="header" href="#transitioning-states">Transitioning States</a></h2>
<p>A <code>Wallet</code> instance can be unlocked by providing the private key:</p>
<pre><code class="language-rust ignore">let wallet_unlocked = wallet_locked.unlock(private_key);
</code></pre>
<p>A <code>WalletUnlocked</code> instance can be locked using the <code>lock</code> method:</p>
<pre><code class="language-rust ignore">let wallet_locked = wallet_unlocked.lock();
</code></pre>
<p>Most wallet constructors that create or generate a new wallet are provided on
the <code>WalletUnlocked</code> type. Consider locking the wallet with the <code>lock</code> method after the new private
key has been handled in order to reduce the scope in which the wallet's private
key is stored in memory.</p>
<h2 id="design-guidelines"><a class="header" href="#design-guidelines">Design Guidelines</a></h2>
<p>When designing APIs that accept a wallet as an input, we should think carefully
about the kind of access that we require. API developers should aim to minimise
their usage of <code>WalletUnlocked</code> in order to ensure private keys are stored in
memory no longer than necessary to reduce the surface area for attacks and
vulnerabilities in downstream libraries and applications.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="encrypting-and-storing-wallets"><a class="header" href="#encrypting-and-storing-wallets">Encrypting and storing wallets</a></h1>
<h2 id="creating-a-wallet-and-storing-an-encrypted-json-wallet-on-disk"><a class="header" href="#creating-a-wallet-and-storing-an-encrypted-json-wallet-on-disk">Creating a wallet and storing an encrypted JSON wallet on disk</a></h2>
<p>You can also manage a wallet using <a href="https://cryptobook.nakov.com/symmetric-key-ciphers/ethereum-wallet-encryption">JSON wallets</a> that are securely encrypted and stored on the disk. This makes it easier to manage multiple wallets, especially for testing purposes.</p>
<p>You can create a random wallet and, at the same time, encrypt and store it. Then, later, you can recover the wallet if you know the master password:</p>
<pre><code class="language-rust ignore">        use fuels::prelude::*;

        let dir = std::env::temp_dir();
        let mut rng = rand::thread_rng();

        // Use the test helper to setup a test provider.
        let provider = setup_test_provider(vec![], vec![], None, None).await?;

        let password = &quot;my_master_password&quot;;

        // Create a wallet to be stored in the keystore.
        let (_wallet, uuid) =
            WalletUnlocked::new_from_keystore(&amp;dir, &amp;mut rng, password, Some(provider.clone()))?;

        let path = dir.join(uuid);

        let _recovered_wallet = WalletUnlocked::load_keystore(path, password, Some(provider))?;
</code></pre>
<h2 id="encrypting-and-storing-a-wallet-created-from-a-mnemonic-or-private-key"><a class="header" href="#encrypting-and-storing-a-wallet-created-from-a-mnemonic-or-private-key">Encrypting and storing a wallet created from a mnemonic or private key</a></h2>
<p>If you have already created a wallet using a mnemonic phrase or a private key, you can also encrypt it and save it to disk:</p>
<pre><code class="language-rust ignore">        use fuels::prelude::*;

        let dir = std::env::temp_dir();

        let phrase =
            &quot;oblige salon price punch saddle immune slogan rare snap desert retire surprise&quot;;

        // Use the test helper to setup a test provider.
        let provider = setup_test_provider(vec![], vec![], None, None).await?;

        // Create first account from mnemonic phrase.
        let wallet = WalletUnlocked::new_from_mnemonic_phrase(phrase, Some(provider))?;

        let password = &quot;my_master_password&quot;;

        // Encrypts and stores it on disk. Can be recovered using `Wallet::load_keystore`.
        let _uuid = wallet.encrypt(&amp;dir, password)?;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="checking-balances-and-coins"><a class="header" href="#checking-balances-and-coins">Checking balances and coins</a></h1>
<!-- This section should explain getting the balance of a wallet -->
<!-- balance:example:start -->
<p>In the Fuel network, each UTXO corresponds to a unique <em>coin</em>, and said <em>coin</em> has a corresponding <em>amount</em> (the same way a dollar bill has either 10$ or 5$ face value). So, when you want to query the balance for a given asset ID, you want to query the sum of the amount in each unspent coin. This querying is done very easily with a wallet:</p>
<!-- balance:example:end -->
<pre><code class="language-rust ignore">        let asset_id: AssetId = BASE_ASSET_ID;
        let balance: u64 = wallet.get_asset_balance(&amp;asset_id).await?;
</code></pre>
<!-- This section should explain getting all of the balances of a wallet -->
<!-- balances:example:start -->
<p>If you want to query all the balances (i.e., get the balance for each asset ID in that wallet), you can use the <code>get_balances</code> method:</p>
<!-- balances:example:end -->
<pre><code class="language-rust ignore">        let balances: HashMap&lt;String, u64&gt; = wallet.get_balances().await?;
</code></pre>
<!-- This section should explain the return type for `get_balances` -->
<!-- balances_return:example:start -->
<p>The return type is a <code>HashMap</code>, where the key is the <em>asset ID's</em> hex string, and the value is the corresponding balance. For example, we can get the base asset balance with:</p>
<!-- balances_return:example:end -->
<pre><code class="language-rust ignore">        let asset_balance = balances.get(&amp;asset_id.to_string()).unwrap();
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setting-up-test-wallets"><a class="header" href="#setting-up-test-wallets">Setting up test wallets</a></h1>
<p>You'll often want to create one or more test wallets when testing your contracts. Here's how to do it.</p>
<h2 id="setting-up-multiple-test-wallets"><a class="header" href="#setting-up-multiple-test-wallets">Setting up multiple test wallets</a></h2>
<!-- This section should explain setting up multiple test wallets -->
<!-- test_wallets:example:start -->
<p>If you need multiple test wallets, they can be set up using the <code>launch_custom_provider_and_get_wallets</code> method.</p>
<!-- test_wallets:example:end -->
<pre><code class="language-rust ignore">        use fuels::prelude::*;
        // This helper will launch a local node and provide 10 test wallets linked to it.
        // The initial balance defaults to 1 coin per wallet with an amount of 1_000_000_000
        let wallets =
            launch_custom_provider_and_get_wallets(WalletsConfig::default(), None, None).await?;
</code></pre>
<!-- This section should explain how to customize test wallets -->
<!-- custom_test_wallets:example:start -->
<p>You can customize your test wallets via <code>WalletsConfig</code>.</p>
<!-- custom_test_wallets:example:end -->
<pre><code class="language-rust ignore">        let num_wallets = 5;
        let coins_per_wallet = 3;
        let amount_per_coin = 100;

        let config = WalletsConfig::new(
            Some(num_wallets),
            Some(coins_per_wallet),
            Some(amount_per_coin),
        );
        // Launches a local node and provides test wallets as specified by the config
        let wallets = launch_custom_provider_and_get_wallets(config, None, None).await?;
</code></pre>
<!-- This section should explain that test wallets are deterministic -->
<!-- deterministic:example:start -->
<blockquote>
<p><strong>Note</strong> Wallets generated with <code>launch_provider_and_get_wallet</code> or <code>launch_custom_provider_and_get_wallets</code>
will have deterministic addresses.</p>
</blockquote>
<!-- deterministic:example:end -->
<h2 id="setting-up-a-test-wallet-with-multiple-random-assets"><a class="header" href="#setting-up-a-test-wallet-with-multiple-random-assets">Setting up a test wallet with multiple random assets</a></h2>
<p>You can create a test wallet containing multiple assets (including the base asset to pay for gas).</p>
<pre><code class="language-rust ignore">        use fuels::prelude::*;
        let mut wallet = WalletUnlocked::new_random(None);
        let num_assets = 5; // 5 different assets
        let coins_per_asset = 10; // Per asset id, 10 coins in the wallet
        let amount_per_coin = 15; // For each coin (UTXO) of the asset, amount of 15

        let (coins, asset_ids) = setup_multiple_assets_coins(
            wallet.address(),
            num_assets,
            coins_per_asset,
            amount_per_coin,
        );
        let provider = setup_test_provider(coins.clone(), vec![], None, None).await?;
        wallet.set_provider(provider);
</code></pre>
<ul>
<li>coins: <code>Vec&lt;(UtxoId, Coin)&gt;</code> has <code>num_assets</code> * <code>coins_per_assets</code> coins (UTXOs)</li>
<li>asset_ids: <code>Vec&lt;AssetId&gt;</code> contains the <code>num_assets</code> randomly generated <code>AssetId</code>s (always includes the base asset)</li>
</ul>
<h2 id="setting-up-a-test-wallet-with-multiple-custom-assets"><a class="header" href="#setting-up-a-test-wallet-with-multiple-custom-assets">Setting up a test wallet with multiple custom assets</a></h2>
<p>You can also create assets with specific <code>AssetId</code>s, coin amounts, and number of coins.</p>
<pre><code class="language-rust ignore">        use fuels::prelude::*;
        use rand::Fill;

        let mut wallet = WalletUnlocked::new_random(None);
        let mut rng = rand::thread_rng();

        let asset_base = AssetConfig {
            id: BASE_ASSET_ID,
            num_coins: 2,
            coin_amount: 4,
        };

        let mut asset_id_1 = AssetId::zeroed();
        asset_id_1.try_fill(&amp;mut rng)?;
        let asset_1 = AssetConfig {
            id: asset_id_1,
            num_coins: 6,
            coin_amount: 8,
        };

        let mut asset_id_2 = AssetId::zeroed();
        asset_id_2.try_fill(&amp;mut rng)?;
        let asset_2 = AssetConfig {
            id: asset_id_2,
            num_coins: 10,
            coin_amount: 12,
        };

        let assets = vec![asset_base, asset_1, asset_2];

        let coins = setup_custom_assets_coins(wallet.address(), &amp;assets);
        let provider = setup_test_provider(coins, vec![], None, None).await?;
        wallet.set_provider(provider);
</code></pre>
<p>This can also be achieved directly with the <code>WalletsConfig</code>.</p>
<pre><code class="language-rust ignore">        let num_wallets = 1;
        let wallet_config = WalletsConfig::new_multiple_assets(num_wallets, assets);
        let wallets = launch_custom_provider_and_get_wallets(wallet_config, None, None).await?;
</code></pre>
<blockquote>
<p><strong>Note</strong> In this case, you need to manually add the base asset and the corresponding number of
coins and coin amount</p>
</blockquote>
<h2 id="setting-up-assets"><a class="header" href="#setting-up-assets">Setting up assets</a></h2>
<p>The Fuel blockchain holds many different assets; you can create your asset with its unique <code>AssetId</code> or create random assets for testing purposes.</p>
<p>You can use only one asset to pay for transaction fees and gas: the base asset, whose <code>AssetId</code> is <code>0x000...0</code>, a 32-byte zeroed value.</p>
<p>For testing purposes, you can configure coins and amounts for assets. You can use <code>setup_multiple_assets_coins</code>:</p>
<pre><code class="language-rust ignore">        use fuels::prelude::*;
        let mut wallet = WalletUnlocked::new_random(None);
        let num_assets = 5; // 5 different assets
        let coins_per_asset = 10; // Per asset id, 10 coins in the wallet
        let amount_per_coin = 15; // For each coin (UTXO) of the asset, amount of 15

        let (coins, asset_ids) = setup_multiple_assets_coins(
            wallet.address(),
            num_assets,
            coins_per_asset,
            amount_per_coin,
        );
</code></pre>
<blockquote>
<p><strong>Note</strong> If setting up multiple assets, one of these assets will always be the base asset.</p>
</blockquote>
<p>If you want to create coins only with the base asset, then you can use:</p>
<pre><code class="language-rust ignore">        let wallet = WalletUnlocked::new_random(None);

        // How many coins in our wallet.
        let number_of_coins = 1;

        // The amount/value in each coin in our wallet.
        let amount_per_coin = 3;

        let coins = setup_single_asset_coins(
            wallet.address(),
            BASE_ASSET_ID,
            number_of_coins,
            amount_per_coin,
        );
</code></pre>
<blockquote>
<p><strong>Note</strong> Choosing a large number of coins and assets for <code>setup_multiple_assets_coins</code> or <code>setup_single_asset_coins</code> can lead to considerable runtime for these methods. This will be improved in the future but for now, we recommend using up to <strong>1_000_000</strong> coins, or <strong>1000</strong> coins and assets simultaneously.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="signing"><a class="header" href="#signing">Signing</a></h1>
<p>Once you've instantiated your wallet in an unlocked state using one of the previously discussed methods, you can sign a message with <code>wallet.sign</code>. Below is a full example of how to sign and recover a message.</p>
<pre><code class="language-rust ignore">        let mut rng = StdRng::seed_from_u64(2322u64);
        let mut secret_seed = [0u8; 32];
        rng.fill_bytes(&amp;mut secret_seed);

        let secret = secret_seed.as_slice().try_into()?;

        // Create a wallet using the private key created above.
        let wallet = WalletUnlocked::new_from_private_key(secret, None);

        let message = Message::new(&quot;my message&quot;.as_bytes());
        let signature = wallet.sign(message).await?;

        // Check if signature is what we expect it to be
        assert_eq!(signature, Signature::from_str(&quot;0x8eeb238db1adea4152644f1cd827b552dfa9ab3f4939718bb45ca476d167c6512a656f4d4c7356bfb9561b14448c230c6e7e4bd781df5ee9e5999faa6495163d&quot;)?);

        // Recover address that signed the message
        let recovered_address = signature.recover(&amp;message)?;

        assert_eq!(wallet.address().hash(), recovered_address.hash());

        // Verify signature
        signature.verify(&amp;recovered_address, &amp;message)?;
</code></pre>
<h2 id="adding-signers-to-a-transaction-builder"><a class="header" href="#adding-signers-to-a-transaction-builder">Adding <code>Signers</code> to a transaction builder</a></h2>
<p>Every signed resource in the inputs needs to have a witness index that points to a valid witness. Changing the witness index inside an input will change the transaction ID. This means that we need to set all witness indexes before finally signing the transaction. Previously, the user had to make sure that the witness indexes and the order of the witnesses are correct. To automate this process, the SDK will keep track of the signers in the transaction builder and resolve the final transaction automatically. This is done by storing signers until the final transaction is built.</p>
<p>Below is a full example of how to create a transaction builder and add signers to it.</p>
<blockquote>
<p>Note: When you add a <code>Signer</code> to a transaction builder, the signer is stored inside it and the transaction will not be resolved until you call <code>build()</code>!</p>
</blockquote>
<pre><code class="language-rust ignore">        let secret = SecretKey::from_str(
            &quot;5f70feeff1f229e4a95e1056e8b4d80d0b24b565674860cc213bdb07127ce1b1&quot;,
        )?;
        let wallet = WalletUnlocked::new_from_private_key(secret, None);

        // Set up a transaction
        let mut tb = {
            let input_coin = Input::ResourceSigned {
                resource: CoinType::Coin(Coin {
                    amount: 10000000,
                    owner: wallet.address().clone(),
                    ..Default::default()
                }),
            };

            let output_coin = Output::coin(
                Address::from_str(
                    &quot;0xc7862855b418ba8f58878db434b21053a61a2025209889cc115989e8040ff077&quot;,
                )?,
                1,
                Default::default(),
            );

            ScriptTransactionBuilder::prepare_transfer(
                vec![input_coin],
                vec![output_coin],
                Default::default(),
            )
        };

        // Add `Signer` to the transaction builder
        tb.add_signer(wallet.clone())?;
</code></pre>
<h2 id="signing-a-built-transaction"><a class="header" href="#signing-a-built-transaction">Signing a built transaction</a></h2>
<p>If you have a built transaction and want to add a signature, you can use the <code>sign_with</code> method.</p>
<pre><code class="language-rust ignore">    tx.sign_with(&amp;wallet, provider.chain_id()).await?;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generating-bindings-with-abigen"><a class="header" href="#generating-bindings-with-abigen">Generating bindings with abigen</a></h1>
<p>You might have noticed this snippet in the previous sections:</p>
<pre><code class="language-rust ignore">        abigen!(Contract(
            name = &quot;MyContract&quot;,
            abi = &quot;packages/fuels/tests/contracts/contract_test/out/debug/contract_test-abi.json&quot;
        ));
</code></pre>
<!-- This section should explain the purpose of the abigen -->
<!-- abigen:example:start -->
<p>The SDK lets you transform ABI methods of a smart contract, specified as JSON objects (which you can get from <a href="https://github.com/FuelLabs/sway/tree/master/forc">Forc</a>), into Rust structs and methods that are type-checked at compile time.
In order to call your contracts, scripts or predicates, you first need to generate the Rust bindings for them.</p>
<!-- abigen:example:end -->
<p>The following subsections contain more details about the <code>abigen!</code> syntax and the code generated from it.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-json-abi-file"><a class="header" href="#the-json-abi-file">The JSON ABI file</a></h1>
<!-- This section should talk about the importance of the ABI -->
<!-- abi:example:start -->
<p>Whether you want to deploy or connect to a pre-existing smart contract, the JSON ABI file is extremely important: it's what tells the SDK about the <a href="https://docs.fuel.network/guides/quickstart/building-a-smart-contract/#abi">ABI methods</a> in your smart contracts.</p>
<!-- abi:example:end -->
<p>For the same example Sway code as above:</p>
<pre><code class="language-Rust">contract;

abi MyContract {
    fn test_function() -&gt; bool;
}

impl MyContract for Contract {
    fn test_function() -&gt; bool {
        true
    }
}
</code></pre>
<p>The JSON ABI file looks like this:</p>
<pre><code class="language-json">$ cat out/debug/my-test-abi.json
[
  {
    &quot;type&quot;: &quot;function&quot;,
    &quot;inputs&quot;: [],
    &quot;name&quot;: &quot;test_function&quot;,
    &quot;outputs&quot;: [
      {
        &quot;name&quot;: &quot;&quot;,
        &quot;type&quot;: &quot;bool&quot;,
        &quot;components&quot;: null
      }
    ]
  }
]
</code></pre>
<p>The Fuel Rust SDK will take this file as input and generate equivalent methods (and custom types if applicable) that you can call from your Rust code.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="abigen"><a class="header" href="#abigen">abigen</a></h1>
<!-- This section explain the `abigen!` macro -->
<!-- abigen:example:start -->
<p><code>abigen!</code> is a procedural macro -- it generates code. It accepts inputs in the format of:</p>
<pre><code class="language-text">ProgramType(name=&quot;MyProgramType&quot;, abi=&quot;my_program-abi.json&quot;)...
</code></pre>
<p>where:</p>
<ul>
<li>
<p><code>ProgramType</code> is one of: <code>Contract</code>, <code>Script</code> or <code>Predicate</code>,</p>
</li>
<li>
<p><code>name</code> is the name that will be given to the generated bindings,</p>
</li>
<li>
<p><code>abi</code> is either a path to the JSON ABI file or its actual contents.</p>
</li>
</ul>
<!-- abigen:example:end -->
<hr />
<p>So, an <code>abigen!</code> which generates bindings for two contracts and one script looks like this:</p>
<pre><code class="language-rust ignore">        abigen!(
            Contract(name=&quot;ContractA&quot;, abi=&quot;packages/fuels/tests/bindings/sharing_types/contract_a/out/debug/contract_a-abi.json&quot;),
            Contract(name=&quot;ContractB&quot;, abi=&quot;packages/fuels/tests/bindings/sharing_types/contract_b/out/debug/contract_b-abi.json&quot;),
            Script(name=&quot;MyScript&quot;, abi=&quot;packages/fuels/tests/scripts/arguments/out/debug/arguments-abi.json&quot;),
            Predicate(name=&quot;MyPredicateEncoder&quot;, abi=&quot;packages/fuels/tests/predicates/basic_predicate/out/debug/basic_predicate-abi.json&quot;),
        );
</code></pre>
<h2 id="how-does-the-generated-code-look"><a class="header" href="#how-does-the-generated-code-look">How does the generated code look?</a></h2>
<p>A rough overview:</p>
<pre><code class="language-rust ignore">pub mod abigen_bindings {
    pub mod contract_a_mod {
        struct SomeCustomStruct{/*...*/};
        // other custom types used in the contract

        struct ContractA {/*...*/};
        impl ContractA {/*...*/};
        // ...
    }
    pub mod contract_b_mod {
        // ...
    }
    pub mod my_script_mod {
        // ...
    }
    pub mod my_predicate_mod{
        // ...
    }
    pub mod shared_types{
        // ...
    }
}

pub use contract_a_mod::{/*..*/};
pub use contract_b_mod::{/*..*/};
pub use my_predicate_mod::{/*..*/};
pub use shared_types::{/*..*/};
</code></pre>
<p>Each <code>ProgramType</code> gets its own <code>mod</code> based on the <code>name</code> given in the <code>abigen!</code>. Inside the respective mods, the custom types used by that program are generated, and the bindings through which the actual calls can be made.</p>
<p>One extra <code>mod</code> called <code>shared_types</code> is generated if <code>abigen!</code> detects that the given programs share types. Instead of each <code>mod</code> regenerating the type for itself, the type is lifted out into the <code>shared_types</code> module, generated only once, and then shared between all program bindings that use it. Reexports are added to each mod so that even if a type is deemed shared, you can still access it as though each <code>mod</code> had generated the type for itself (i.e. <code>my_contract_mod::SharedType</code>).</p>
<p>A type is deemed shared if its name and definition match up. This can happen either because you've used the same library (a custom one or a type from the <code>stdlib</code>) or because you've happened to define the exact same type.</p>
<p>Finally, <code>pub use</code> statements are inserted, so you don't have to fully qualify the generated types. To avoid conflict, only types that have unique names will get a <code>pub use</code> statement. If you find <code>rustc</code> can't find your type, it might just be that there is another generated type with the same name. To fix the issue just qualify the path by doing <code>abigen_bindings::whatever_contract_mod::TheType</code>.</p>
<blockquote>
<p><strong>Note:</strong>
It is <strong>highly</strong> encouraged that you generate all your bindings in one <code>abigen!</code> call. Doing it in this manner will allow type sharing and avoid name collisions you'd normally get when calling <code>abigen!</code> multiple times inside the same namespace. If you choose to proceed otherwise, keep in mind the generated code overview presented above and appropriately separate the <code>abigen!</code> calls into different modules to resolve the collision.</p>
</blockquote>
<h3 id="type-paths"><a class="header" href="#type-paths">Type paths</a></h3>
<p>Normally when using types from libraries in your contract, script or predicate, they'll be generated directly under the main <code>mod</code> of your program bindings, i.e. a type in a contract binding <code>MyContract</code> imported from a library <code>some_library</code> would be generated under <code>abigen_bindings::my_contract_mod::SomeLibraryType</code>.</p>
<p>This can cause problems if you happen to have two types with the same name in different libraries of your program.</p>
<p>This behavior can be changed to include the library path by compiling your Sway project with the following:</p>
<pre><code class="language-shell">forc build --json-abi-with-callpaths
</code></pre>
<p>Now the type from the previous example will be generated under <code>abigen_bindings::my_contract_mod::some_library::SomeLibraryType</code>.</p>
<p>This might only become relevant if your type isn't reexported. This can happen, as explained previously, if your type does not have a unique name across all bindings inside one <code>abigen!</code> call. You'll then need to fully qualify the access to it.</p>
<p>Including type paths will eventually become the default and the flag will be removed.</p>
<h2 id="using-the-bindings"><a class="header" href="#using-the-bindings">Using the bindings</a></h2>
<p>Let's look at a contract with two methods: <code>initialize_counter(arg: u64) -&gt; u64</code> and <code>increment_counter(arg: u64) -&gt; u64</code>, with the following JSON ABI:</p>
<pre><code class="language-json ignore">{
  &quot;types&quot;: [
    {
      &quot;typeId&quot;: 0,
      &quot;type&quot;: &quot;u64&quot;,
      &quot;components&quot;: null,
      &quot;typeParameters&quot;: null
    }
  ],
  &quot;functions&quot;: [
    {
      &quot;inputs&quot;: [
        {
          &quot;name&quot;: &quot;value&quot;,
          &quot;type&quot;: 0,
          &quot;typeArguments&quot;: null
        }
      ],
      &quot;name&quot;: &quot;initialize_counter&quot;,
      &quot;output&quot;: {
        &quot;name&quot;: &quot;&quot;,
        &quot;type&quot;: 0,
        &quot;typeArguments&quot;: null
      }
    },
    {
      &quot;inputs&quot;: [
        {
          &quot;name&quot;: &quot;value&quot;,
          &quot;type&quot;: 0,
          &quot;typeArguments&quot;: null
        }
      ],
      &quot;name&quot;: &quot;increment_counter&quot;,
      &quot;output&quot;: {
        &quot;name&quot;: &quot;&quot;,
        &quot;type&quot;: 0,
        &quot;typeArguments&quot;: null
      }
    }
  ]
}
</code></pre>
<p>By doing this:</p>
<pre><code class="language-rust ignore">            use fuels::prelude::*;
            // Replace with your own JSON abi path (relative to the root of your crate)
            abigen!(Contract(
                name = &quot;MyContractName&quot;,
                abi = &quot;examples/rust_bindings/src/abi.json&quot;
            ));
</code></pre>
<p>or this:</p>
<pre><code class="language-rust ignore">            use fuels::prelude::*;
            abigen!(Contract(
                name = &quot;MyContract&quot;,
                abi = r#&quot;
            {
                &quot;types&quot;: [
                  {
                    &quot;typeId&quot;: 0,
                    &quot;type&quot;: &quot;u64&quot;,
                    &quot;components&quot;: null,
                    &quot;typeParameters&quot;: null
                  }
                ],
                &quot;functions&quot;: [
                  {
                    &quot;inputs&quot;: [
                      {
                        &quot;name&quot;: &quot;value&quot;,
                        &quot;type&quot;: 0,
                        &quot;typeArguments&quot;: null
                      }
                    ],
                    &quot;name&quot;: &quot;initialize_counter&quot;,
                    &quot;output&quot;: {
                      &quot;name&quot;: &quot;&quot;,
                      &quot;type&quot;: 0,
                      &quot;typeArguments&quot;: null
                    }
                  },
                  {
                    &quot;inputs&quot;: [
                      {
                        &quot;name&quot;: &quot;value&quot;,
                        &quot;type&quot;: 0,
                        &quot;typeArguments&quot;: null
                      }
                    ],
                    &quot;name&quot;: &quot;increment_counter&quot;,
                    &quot;output&quot;: {
                      &quot;name&quot;: &quot;&quot;,
                      &quot;type&quot;: 0,
                      &quot;typeArguments&quot;: null
                    }
                  }
                ]
              }
            &quot;#
            ));
</code></pre>
<p>you'll generate this (shortened for brevity's sake):</p>
<pre><code class="language-rust ignore">pub mod abigen_bindings {
    pub mod my_contract_mod {
        use ::fuels::{
            accounts::{Account, ViewOnlyAccount},
            core::{
                codec,
                traits::{Parameterize, Tokenizable},
                Configurables,
            },
            programs::{
                contract::{self, ContractCallHandler},
                logs::{self, LogDecoder},
            },
            types::{bech32::Bech32ContractId, errors::Result, AssetId},
        };

        pub struct MyContract&lt;T: Account&gt; {
            contract_id: Bech32ContractId,
            account: T,
            log_decoder: LogDecoder,
        }
        impl&lt;T: Account&gt; MyContract&lt;T&gt; {
            pub fn new(
                contract_id: impl ::core::convert::Into&lt;Bech32ContractId&gt;,
                account: T,
            ) -&gt; Self {
                let contract_id: Bech32ContractId = contract_id.into();
                let log_decoder = LogDecoder::new(logs::log_formatters_lookup(
                    vec![],
                    contract_id.clone().into(),
                ));
                Self {
                    contract_id,
                    account,
                    log_decoder,
                }
            }
            pub fn contract_id(&amp;self) -&gt; &amp;Bech32ContractId {
                &amp;self.contract_id
            }
            pub fn account(&amp;self) -&gt; T {
                self.account.clone()
            }
            pub fn with_account&lt;U: Account&gt;(&amp;self, account: U) -&gt; MyContract&lt;U&gt; {
                MyContract {
                    contract_id: self.contract_id.clone(),
                    account,
                    log_decoder: self.log_decoder.clone(),
                }
            }
            pub async fn get_balances(&amp;self) -&gt; Result&lt;::std::collections::HashMap&lt;AssetId, u64&gt;&gt; {
                ViewOnlyAccount::try_provider(&amp;self.account)?
                    .get_contract_balances(&amp;self.contract_id)
                    .await
                    .map_err(::std::convert::Into::into)
            }
            pub fn methods(&amp;self) -&gt; MyContractMethods&lt;T&gt; {
                MyContractMethods {
                    contract_id: self.contract_id.clone(),
                    account: self.account.clone(),
                    log_decoder: self.log_decoder.clone(),
                }
            }
        }
        pub struct MyContractMethods&lt;T: Account&gt; {
            contract_id: Bech32ContractId,
            account: T,
            log_decoder: LogDecoder,
        }
        impl&lt;T: Account&gt; MyContractMethods&lt;T&gt; {
            #[doc = &quot;Calls the contract's `initialize_counter` function&quot;]
            pub fn initialize_counter(&amp;self, value: u64) -&gt; ContractCallHandler&lt;T, u64&gt; {
                contract::method_hash(
                    self.contract_id.clone(),
                    self.account.clone(),
                    codec::resolve_fn_selector(&quot;initialize_counter&quot;, &amp;[u64::param_type()]),
                    &amp;[Tokenizable::into_token(value)],
                    self.log_decoder.clone(),
                    false,
                    ABIEncoder::new(EncoderConfig::default()),
                )
            }
            #[doc = &quot;Calls the contract's `increment_counter` function&quot;]
            pub fn increment_counter(&amp;self, value: u64) -&gt; ContractCallHandler&lt;T, u64&gt; {
                contract::method_hash(
                    self.contract_id.clone(),
                    self.account.clone(),
                    codec::resolve_fn_selector(&quot;increment_counter&quot;, &amp;[u64::param_type()]),
                    &amp;[value.into_token()],
                    self.log_decoder.clone(),
                    false,
                    ABIEncoder::new(EncoderConfig::default()),
                )
            }
        }
        impl&lt;T: Account&gt; contract::SettableContract for MyContract&lt;T&gt; {
            fn id(&amp;self) -&gt; Bech32ContractId {
                self.contract_id.clone()
            }
            fn log_decoder(&amp;self) -&gt; LogDecoder {
                self.log_decoder.clone()
            }
        }
        #[derive(Clone, Debug, Default)]
        pub struct MyContractConfigurables {
            offsets_with_data: ::std::vec::Vec&lt;(u64, ::std::vec::Vec&lt;u8&gt;)&gt;,
        }
        impl MyContractConfigurables {
            pub fn new() -&gt; Self {
                ::std::default::Default::default()
            }
        }
        impl From&lt;MyContractConfigurables&gt; for Configurables {
            fn from(config: MyContractConfigurables) -&gt; Self {
                Configurables::new(config.offsets_with_data)
            }
        }
    }
}
pub use abigen_bindings::my_contract_mod::MyContract;
pub use abigen_bindings::my_contract_mod::MyContractConfigurables;
pub use abigen_bindings::my_contract_mod::MyContractMethods;
</code></pre>
<blockquote>
<p><strong>Note:</strong> that is all <strong>generated</strong> code. No need to write any of that. Ever. The generated code might look different from one version to another, this is just an example to give you an idea of what it looks like.</p>
</blockquote>
<p>Then, you're able to use it to call the actual methods on the deployed contract:</p>
<pre><code class="language-rust ignore">        // This will generate your contract's methods onto `MyContract`.
        // This means an instance of `MyContract` will have access to all
        // your contract's methods that are running on-chain!
        abigen!(Contract(
            name = &quot;MyContract&quot;,
            abi = &quot;packages/fuels/tests/contracts/contract_test/out/debug/contract_test-abi.json&quot;
        ));

        // This is an instance of your contract which you can use to make calls to your functions
        let contract_instance = MyContract::new(contract_id_2, wallet);

        let response = contract_instance
            .methods()
            .initialize_counter(42) // Build the ABI call
            .call() // Perform the network call
            .await?;

        assert_eq!(42, response.value);

        let response = contract_instance
            .methods()
            .increment_counter(10)
            .call()
            .await?;

        assert_eq!(52, response.value);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deploying-contracts"><a class="header" href="#deploying-contracts">Deploying contracts</a></h1>
<p>There are two main ways of working with contracts in the SDK: deploying a contract with SDK or using the SDK to interact with existing contracts.</p>
<h2 id="deploying-a-contract-binary"><a class="header" href="#deploying-a-contract-binary">Deploying a contract binary</a></h2>
<!-- This section should explain the artifacts produced by `forc build`  -->
<!-- build:example:start -->
<p>Once you've written a contract in Sway and compiled it with <code>forc build</code>, you'll have in your hands two important artifacts: the compiled binary file and the JSON ABI file.</p>
<!-- build:example:end -->
<blockquote>
<p>Note: Read <a href="https://docs.fuel.network/guides/quickstart/">here</a> for more on how to work with Sway.</p>
</blockquote>
<p>Below is how you can deploy your contracts using the SDK. For more details about each component in this process, read <a href="deploying/../abigen/the-abigen-macro.html">The abigen macro</a>, <a href="deploying/./the-fuelvm-binary-file.html">The FuelVM binary file</a>, and <a href="deploying/../abigen/the-json-abi-file.html">The JSON ABI file</a>.</p>
<!-- This section should explain how to load and deploy a contract  -->
<!-- deploy:example:start -->
<p>First, the <code>Contract::load_from</code> function is used to load a contract binary with a <code>LoadConfiguration</code>. If you are only interested in a single instance of your contract, use the default configuration: <code>LoadConfiguration::default()</code>. After the contract binary is loaded, you can use the <code>deploy()</code> method to deploy the contract to the blockchain.</p>
<!-- deploy:example:end -->
<pre><code class="language-rust ignore">        // This helper will launch a local node and provide a test wallet linked to it
        let wallet = launch_provider_and_get_wallet().await?;

        // This will load and deploy your contract binary to the chain so that its ID can
        // be used to initialize the instance
        let contract_id = Contract::load_from(
            &quot;../../packages/fuels/tests/contracts/contract_test/out/debug/contract_test.bin&quot;,
            LoadConfiguration::default(),
        )?
        .deploy(&amp;wallet, TxPolicies::default())
        .await?;

        println!(&quot;Contract deployed @ {contract_id}&quot;);
</code></pre>
<p>Alternatively, you can use <code>LoadConfiguration</code> to configure how the contract is loaded. <code>LoadConfiguration</code> let's you:</p>
<ul>
<li>Load the same contract binary with <code>Salt</code> to get a new <code>contract_id</code></li>
<li>Change the contract's storage slots</li>
<li>Update the contract's configurables
<blockquote>
<p>Note: The next section will give more information on how <code>configurables</code> can be used.</p>
</blockquote>
</li>
</ul>
<p>Additionally, you can set custom <code>TxParameters</code> when deploying the loaded contract.</p>
<pre><code class="language-rust ignore">        // Optional: Add `Salt`
        let rng = &amp;mut StdRng::seed_from_u64(2322u64);
        let salt: [u8; 32] = rng.gen();

        // Optional: Configure storage
        let key = Bytes32::from([1u8; 32]);
        let value = Bytes32::from([2u8; 32]);
        let storage_slot = StorageSlot::new(key, value);
        let storage_configuration =
            StorageConfiguration::default().add_slot_overrides([storage_slot]);
        let configuration = LoadConfiguration::default()
            .with_storage_configuration(storage_configuration)
            .with_salt(salt);

        // Optional: Configure deployment parameters
        let tx_policies = TxPolicies::default()
            .with_tip(1)
            .with_script_gas_limit(1_000_000)
            .with_maturity(0);

        let contract_id_2 = Contract::load_from(
            &quot;../../packages/fuels/tests/contracts/contract_test/out/debug/contract_test.bin&quot;,
            configuration,
        )?
        .deploy(&amp;wallet, tx_policies)
        .await?;

        println!(&quot;Contract deployed @ {contract_id_2}&quot;);
</code></pre>
<p>After the contract is deployed, you can use the contract's methods like this:</p>
<pre><code class="language-rust ignore">        // This will generate your contract's methods onto `MyContract`.
        // This means an instance of `MyContract` will have access to all
        // your contract's methods that are running on-chain!
        abigen!(Contract(
            name = &quot;MyContract&quot;,
            abi = &quot;packages/fuels/tests/contracts/contract_test/out/debug/contract_test-abi.json&quot;
        ));

        // This is an instance of your contract which you can use to make calls to your functions
        let contract_instance = MyContract::new(contract_id_2, wallet);

        let response = contract_instance
            .methods()
            .initialize_counter(42) // Build the ABI call
            .call() // Perform the network call
            .await?;

        assert_eq!(42, response.value);

        let response = contract_instance
            .methods()
            .increment_counter(10)
            .call()
            .await?;

        assert_eq!(52, response.value);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="configurable-constants"><a class="header" href="#configurable-constants">Configurable constants</a></h1>
<p>In Sway, you can define <code>configurable</code> constants which can be changed during the contract deployment in the SDK. Here is an example how the constants are defined.</p>
<pre><code class="language-rust ignore">contract;

#[allow(dead_code)]
enum EnumWithGeneric&lt;D&gt; {
    VariantOne: D,
    VariantTwo: (),
}

struct StructWithGeneric&lt;D&gt; {
    field_1: D,
    field_2: u64,
}

configurable {
    U8: u8 = 8u8,
    BOOL: bool = true,
    ARRAY: [u32; 3] = [253u32, 254u32, 255u32],
    STR_4: str[4] = __to_str_array(&quot;fuel&quot;),
    STRUCT: StructWithGeneric&lt;u8&gt; = StructWithGeneric {
        field_1: 8u8,
        field_2: 16,
    },
    ENUM: EnumWithGeneric&lt;bool&gt; = EnumWithGeneric::VariantOne(true),
}

abi TestContract {
    fn return_configurables() -&gt; (u8, bool, [u32; 3], str[4], StructWithGeneric&lt;u8&gt;, EnumWithGeneric&lt;bool&gt;);
}

impl TestContract for Contract {
    fn return_configurables() -&gt; (u8, bool, [u32; 3], str[4], StructWithGeneric&lt;u8&gt;, EnumWithGeneric&lt;bool&gt;) {
        (U8, BOOL, ARRAY, STR_4, STRUCT, ENUM)
    }
}
</code></pre>
<p>Each of the configurable constants will get a dedicated <code>with</code> method in the SDK. For example, the constant <code>STR_4</code> will get the <code>with_STR_4</code> method which accepts the same type as defined in the contract code. Below is an example where we chain several <code>with</code> methods and deploy the contract with the new constants.</p>
<pre><code class="language-rust ignore">    abigen!(Contract(
        name = &quot;MyContract&quot;,
        abi = &quot;packages/fuels/tests/contracts/configurables/out/debug/configurables-abi.json&quot;
    ));

    let wallet = launch_provider_and_get_wallet().await?;

    let new_str: SizedAsciiString&lt;4&gt; = &quot;FUEL&quot;.try_into()?;
    let new_struct = StructWithGeneric {
        field_1: 16u8,
        field_2: 32,
    };
    let new_enum = EnumWithGeneric::VariantTwo;

    let configurables = MyContractConfigurables::default()
        .with_U8(7)?
        .with_STR_4(new_str.clone())?
        .with_STRUCT(new_struct.clone())?
        .with_ENUM(new_enum.clone())?;

    let contract_id = Contract::load_from(
        &quot;tests/contracts/configurables/out/debug/configurables.bin&quot;,
        LoadConfiguration::default().with_configurables(configurables),
    )?
    .deploy(&amp;wallet, TxPolicies::default())
    .await?;

    let contract_instance = MyContract::new(contract_id, wallet.clone());
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="overriding-storage-slots"><a class="header" href="#overriding-storage-slots">Overriding storage slots</a></h1>
<p>If you use storage in your contract, the default storage values will be generated in a JSON file (e.g. <code>my_contract-storage_slots.json</code>) by the Sway compiler. These are loaded automatically for you when you load a contract binary. If you wish to override some of the defaults, you need to provide the corresponding storage slots manually:</p>
<pre><code class="language-rust ignore">            use fuels::{programs::contract::Contract, tx::StorageSlot};
            let slot_override = StorageSlot::new([1; 32].into(), [2; 32].into());
            let storage_config =
                StorageConfiguration::default().add_slot_overrides([slot_override]);

            let load_config =
                LoadConfiguration::default().with_storage_configuration(storage_config);
            let _: Result&lt;Contract&gt; = Contract::load_from(&quot;...&quot;, load_config);
</code></pre>
<p>If you don't have the slot storage file (<code>my_contract-storage_slots.json</code> example from above) for some reason, or you don't wish to load any of the default values, you can disable the auto-loading of storage slots:</p>
<pre><code class="language-rust ignore">            use fuels::programs::contract::Contract;
            let storage_config = StorageConfiguration::default().with_autoload(false);

            let load_config =
                LoadConfiguration::default().with_storage_configuration(storage_config);
            let _: Result&lt;Contract&gt; = Contract::load_from(&quot;...&quot;, load_config);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="interacting-with-contracts"><a class="header" href="#interacting-with-contracts">Interacting with contracts</a></h1>
<p>If you already have a deployed contract and want to call its methods using the SDK,  but without deploying it again, all you need is the contract ID of your deployed contract. You can skip the whole deployment setup and call <code>::new(contract_id, wallet)</code> directly. For example:</p>
<pre><code class="language-rust ignore">        abigen!(Contract(
            name = &quot;MyContract&quot;,
            // Replace with your contract ABI.json path
            abi = &quot;packages/fuels/tests/contracts/contract_test/out/debug/contract_test-abi.json&quot;
        ));
        let wallet_original = launch_provider_and_get_wallet().await?;

        let wallet = wallet_original.clone();
        // Your bech32m encoded contract ID.
        let contract_id: Bech32ContractId =
            &quot;fuel1vkm285ypjesypw7vhdlhnty3kjxxx4efckdycqh3ttna4xvmxtfs6murwy&quot;.parse()?;

        let connected_contract_instance = MyContract::new(contract_id, wallet);
        // You can now use the `connected_contract_instance` just as you did above!
</code></pre>
<p>The above example assumes that your contract ID string is encoded in the <code>bech32</code> format. You can recognize it by the human-readable-part &quot;fuel&quot; followed by the separator &quot;1&quot;. However, when using other Fuel tools, you might end up with a hex-encoded contract ID string. In that case, you can create your contract instance as follows:</p>
<pre><code class="language-rust ignore">        let contract_id: ContractId =
            &quot;0x65b6a3d081966040bbccbb7f79ac91b48c635729c59a4c02f15ae7da999b32d3&quot;.parse()?;

        let connected_contract_instance = MyContract::new(contract_id, wallet);
</code></pre>
<p>You can learn more about the Fuel SDK <code>bech32</code> types <a href="deploying/../types/bech32.html">here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-fuelvm-binary-file"><a class="header" href="#the-fuelvm-binary-file">The FuelVM binary file</a></h1>
<p>The command <code>forc build</code> compiles your Sway code and generates the bytecode: the binary code that the Fuel Virtual Machine will interpret. For instance, the smart contract below:</p>
<pre><code class="language-Rust">contract;

abi MyContract {
    fn test_function() -&gt; bool;
}

impl MyContract for Contract {
    fn test_function() -&gt; bool {
        true
    }
}
</code></pre>
<p>After <code>forc build</code>, will have a binary file that contains:</p>
<pre><code class="language-terminal">$ cat out/debug/my-test.bin
G4]]D`I]CAs@
           6]C$@!QK%
</code></pre>
<p>This seems very unreadable! But, <code>forc</code> has a nice interpreter for this bytecode: <code>forc parse-bytecode</code>, which will interpret that binary data and output the equivalent FuelVM assembly:</p>
<pre><code class="language-terminal">$ forc parse-bytecode out/debug/my-test.bin
half-word   byte   op                raw           notes
        0   0      JI(4)             90 00 00 04   jump to byte 16
        1   4      NOOP              47 00 00 00
        2   8      Undefined         00 00 00 00   data section offset lo (0)
        3   12     Undefined         00 00 00 34   data section offset hi (52)
        4   16     LW(63, 12, 1)     5d fc c0 01
        5   20     ADD(63, 63, 12)   10 ff f3 00
        6   24     LW(17, 6, 73)     5d 44 60 49
        7   28     LW(16, 63, 1)     5d 43 f0 01
        8   32     EQ(16, 17, 16)    13 41 14 00
        9   36     JNZI(16, 11)      73 40 00 0b   conditionally jump to byte 44
       10   40     RVRT(0)           36 00 00 00
       11   44     LW(16, 63, 0)     5d 43 f0 00
       12   48     RET(16)           24 40 00 00
       13   52     Undefined         00 00 00 00
       14   56     Undefined         00 00 00 01
       15   60     Undefined         00 00 00 00
       16   64     XOR(20, 27, 53)   21 51 bd 4b
</code></pre>
<p>If you want to deploy your smart contract using the SDK, this binary file is important; it's what we'll be sending to the FuelVM in a transaction.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="calling-contracts"><a class="header" href="#calling-contracts">Calling contracts</a></h1>
<p>Once you've deployed your contract, as seen in the previous sections, you'll likely want to:</p>
<ol>
<li>Call contract methods;</li>
<li>Configure call parameters and transaction policies;</li>
<li>Forward coins and gas in your contract calls;</li>
<li>Read and interpret returned values and logs.</li>
</ol>
<p>Here's an example. Suppose your Sway contract has two ABI methods called <code>initialize_counter(u64)</code> and <code>increment_counter(u64)</code>. Once you've deployed it the contract, you can call these methods like this:</p>
<pre><code class="language-rust ignore">        // This will generate your contract's methods onto `MyContract`.
        // This means an instance of `MyContract` will have access to all
        // your contract's methods that are running on-chain!
        abigen!(Contract(
            name = &quot;MyContract&quot;,
            abi = &quot;packages/fuels/tests/contracts/contract_test/out/debug/contract_test-abi.json&quot;
        ));

        // This is an instance of your contract which you can use to make calls to your functions
        let contract_instance = MyContract::new(contract_id_2, wallet);

        let response = contract_instance
            .methods()
            .initialize_counter(42) // Build the ABI call
            .call() // Perform the network call
            .await?;

        assert_eq!(42, response.value);

        let response = contract_instance
            .methods()
            .increment_counter(10)
            .call()
            .await?;

        assert_eq!(52, response.value);
</code></pre>
<p>The example above uses all the default configurations and performs a simple contract call.</p>
<p>Furthermore, if you need to separate submission from value retrieval for any reason, you can do so as follows:</p>
<pre><code class="language-rust ignore">        let response = contract_instance
            .methods()
            .initialize_counter(42)
            .submit()
            .await?;

        let value = response.response().await?.value;

</code></pre>
<p>Next, we'll see how we can further configure the many different parameters in a contract call.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="calls-with-different-wallets"><a class="header" href="#calls-with-different-wallets">Calls with different wallets</a></h1>
<!-- This section should explain how to call a contract with a certain wallet -->
<!-- wallet:example:start -->
<p>You can use the <code>with_account()</code> method on an existing contract instance as a shorthand for creating a new instance connected to the provided wallet. This lets you make contracts calls with different wallets in a chain like fashion.</p>
<!-- wallet:example:end-->
<pre><code class="language-rust ignore">        // Create contract instance with wallet_1
        let contract_instance = MyContract::new(contract_id, wallet_1.clone());

        // Perform contract call with wallet_2
        let response = contract_instance
            .with_account(wallet_2) // Connect wallet_2
            .methods() // Get contract methods
            .get_msg_amount() // Our contract method
            .call() // Perform the contract call.
            .await?; // This is an async call, `.await` for it.
</code></pre>
<blockquote>
<p><strong>Note:</strong> connecting a different wallet to an existing instance ignores its set provider in favor of the provider used to deploy the contract. If you have two wallets connected to separate providers (each communicating with a separate fuel-core), the one assigned to the deploying wallet will also be used for contract calls. This behavior is only relevant if multiple providers (i.e. fuel-core instances) are present and can otherwise be ignored.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="transaction-policies"><a class="header" href="#transaction-policies">Transaction policies</a></h1>
<!-- This section should explain what tx policies are and how to configure them -->
<!-- tx_policies:example:start -->
<p>Transaction policies are defined as follows:</p>
<pre><code class="language-rust ignore">pub struct TxPolicies {
    tip: Option&lt;u64&gt;,
    witness_limit: Option&lt;u64&gt;,
    maturity: Option&lt;u64&gt;,
    max_fee: Option&lt;u64&gt;,
    script_gas_limit: Option&lt;u64&gt;,
}
</code></pre>
<p>Where:</p>
<ol>
<li><strong>Tip</strong> - amount to pay the block producer to prioritize the transaction.</li>
<li><strong>Witness Limit</strong> - The maximum amount of witness data allowed for the transaction.</li>
<li><strong>Maturity</strong> - Block until which the transaction cannot be included.</li>
<li><strong>Max Fee</strong> - The maximum fee payable by this transaction.</li>
<li><strong>Script Gas Limit</strong> - The maximum amount of gas the transaction may consume for executing its script code.</li>
</ol>
<p>When the <strong>Script Gas Limit</strong> is not set, the Rust SDK will estimate the consumed gas in the background and set it as the limit.</p>
<p>If the <strong>Witness Limit</strong> is not set, the SDK will set it to the size of all witnesses and signatures defined in the transaction builder.</p>
<p>You can configure these parameters by creating an instance of <code>TxPolicies</code> and passing it to a chain method called <code>with_tx_policies</code>:</p>
<!-- tx_policies:example:end-->
<pre><code class="language-rust ignore">        let contract_methods = MyContract::new(contract_id.clone(), wallet.clone()).methods();

        let tx_policies = TxPolicies::default()
            .with_tip(1)
            .with_script_gas_limit(1_000_000)
            .with_maturity(0);

        let response = contract_methods
            .initialize_counter(42) // Our contract method
            .with_tx_policies(tx_policies) // Chain the tx policies
            .call() // Perform the contract call
            .await?; // This is an async call, `.await` it.
</code></pre>
<!-- This section should explain how to use the default tx policy -->
<!-- tx_policies_default:example:start -->
<p>You can also use <code>TxPolicies::default()</code> to use the default values.</p>
<!-- tx_policies_default:example:end -->
<p>This way:</p>
<pre><code class="language-rust ignore">        let response = contract_methods
            .initialize_counter(42)
            .with_tx_policies(TxPolicies::default())
            .call()
            .await?;
</code></pre>
<p>As you might have noticed, <code>TxPolicies</code> can also be specified when deploying contracts or transferring assets by passing it to the respective methods.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="call-parameters"><a class="header" href="#call-parameters">Call parameters</a></h1>
<!-- This section should explain what the call params are and how to configure them -->
<!-- call_params:example:start -->
<p>The parameters for a contract call are:</p>
<ol>
<li>Amount</li>
<li>Asset ID</li>
<li>Gas forwarded</li>
</ol>
<!-- call_params:example:end -->
<p>You can use these to forward coins to a contract. You can configure these parameters by creating an instance of <a href="https://docs.rs/fuels/latest/fuels/programs/contract/struct.CallParameters.html"><code>CallParameters</code></a> and passing it to a chain method called <code>call_params</code>.</p>
<!-- use_call_params:example:end -->
<p>For instance, suppose the following contract that uses Sway's <code>msg_amount()</code> to return the amount sent in that transaction.</p>
<pre><code class="language-rust ignore">    #[payable]
    fn get_msg_amount() -&gt; u64 {
        msg_amount()
    }
</code></pre>
<p>Then, in Rust, after setting up and deploying the above contract, you can configure the amount being sent in the transaction like this:</p>
<pre><code class="language-rust ignore">        let contract_methods = MyContract::new(contract_id, wallet.clone()).methods();

        let tx_policies = TxPolicies::default();

        // Forward 1_000_000 coin amount of base asset_id
        // this is a big number for checking that amount can be a u64
        let call_params = CallParameters::default().with_amount(1_000_000);

        let response = contract_methods
            .get_msg_amount() // Our contract method.
            .with_tx_policies(tx_policies) // Chain the tx policies.
            .call_params(call_params)? // Chain the call parameters.
            .call() // Perform the contract call.
            .await?;
</code></pre>
<!-- This section should explain why `call_params` returns a result -->
<!-- payable:example:start -->
<p><code>call_params</code> returns a result to ensure you don't forward assets to a contract method that isn't payable.</p>
<!-- payable:example:end -->
<p>In the following example, we try to forward an amount of <code>100</code> of the base asset to <code>non_payable</code>. As its name suggests, <code>non_payable</code> isn't annotated with <code>#[payable]</code> in the contract code. Passing <code>CallParameters</code> with an amount other than <code>0</code> leads to an error:</p>
<pre><code class="language-rust ignore">    let err = contract_methods
        .non_payable()
        .call_params(CallParameters::default().with_amount(100))
        .expect_err(&quot;should return error&quot;);

    assert!(matches!(err, Error::Other(s) if s.contains(&quot;assets forwarded to non-payable method&quot;)));
</code></pre>
<blockquote>
<p><strong>Note:</strong> forwarding gas to a contract call is always possible, regardless of the contract method being non-payable.</p>
</blockquote>
<p>You can also use <code>CallParameters::default()</code> to use the default values:</p>
<pre><code class="language-rust ignore">pub const DEFAULT_CALL_PARAMS_AMOUNT: u64 = 0;
// Bytes representation of the asset ID of the &quot;base&quot; asset used for gas fees.
pub const BASE_ASSET_ID: AssetId = AssetId::BASE;
</code></pre>
<p>This way:</p>
<pre><code class="language-rust ignore">        let response = contract_methods
            .initialize_counter(42)
            .call_params(CallParameters::default())?
            .call()
            .await?;
</code></pre>
<!-- This section should explain what the `gas_forwarded` parameter does -->
<!-- gas:example:start -->
<p>The <code>gas_forwarded</code> parameter defines the limit for the actual contract call as opposed to the gas limit for the whole transaction. This means that it is constrained by the transaction limit. If it is set to an amount greater than the available gas, all available gas will be forwarded.</p>
<!-- gas:example:end -->
<pre><code class="language-rust ignore">        // Set the transaction `gas_limit` to 1_000_000 and `gas_forwarded` to 4300 to specify that
        // the contract call transaction may consume up to 1_000_000 gas, while the actual call may
        // only use 4300 gas
        let tx_policies = TxPolicies::default().with_script_gas_limit(1_000_000);
        let call_params = CallParameters::default().with_gas_forwarded(4300);

        let response = contract_methods
            .get_msg_amount() // Our contract method.
            .with_tx_policies(tx_policies) // Chain the tx policies.
            .call_params(call_params)? // Chain the call parameters.
            .call() // Perform the contract call.
            .await?;
</code></pre>
<!-- This section should explain the default forwarding behavior for a call -->
<!-- forwarding:example:start -->
<p>If you don't set the call parameters or use <code>CallParameters::default()</code>, the transaction gas limit will be forwarded instead.</p>
<!-- forwarding:example:end -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-asset-transfer"><a class="header" href="#custom-asset-transfer">Custom asset transfer</a></h1>
<!-- This section should explain the `add_custom_asset()` method -->
<!-- transfer:example:start -->
<p>The SDK provides the option to transfer assets within the same transaction, when making a contract call. By using <code>add_custom_asset()</code> you specify the asset ID, the amount, and the destination address:</p>
<!-- transfer:example:end -->
<pre><code class="language-rust ignore">        let amount = 1000;
        let _ = contract_instance
            .methods()
            .initialize_counter(42)
            .add_custom_asset(BASE_ASSET_ID, amount, Some(other_wallet.address().clone()))
            .call()
            .await?;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="call-response"><a class="header" href="#call-response">Call response</a></h1>
<!-- This section should why you have to chain `.call().await.unwrap()` so often -->
<!-- chaining:example:start -->
<p>You've probably noticed that you're often chaining <code>.call().await.unwrap()</code>. That's because:</p>
<ol>
<li>You have to choose between <code>.call()</code> and <code>.simulate()</code> (more on this in the next section).</li>
<li>Contract calls are asynchronous, so you can choose to either <code>.await</code> it or perform concurrent tasks, making full use of Rust's async.</li>
<li><code>.unwrap()</code> the <code>Result&lt;FuelCallResponse, Error&gt;</code> returned by the contract call.</li>
</ol>
<!-- chaining:example:end -->
<!-- This section should preface what the `FuelCallResponse` is -->
<!-- call_resp:example:start -->
<p>Once you unwrap the <code>FuelCallResponse</code>, you have access to this struct:</p>
<!-- call_resp:example:end -->
<pre><code class="language-rust ignore">pub struct FuelCallResponse&lt;D&gt; {
    pub value: D,
    pub receipts: Vec&lt;Receipt&gt;,
    pub gas_used: u64,
    pub log_decoder: LogDecoder,
    pub tx_id: Option&lt;Bytes32&gt;,
}
</code></pre>
<!-- This section should explain the fields of the `FuelCallResponse` struct -->
<!-- call_resp_fields:example:start -->
<p>Where <code>value</code> will hold the value returned by its respective contract method, represented by the exact type returned by the FuelVM, E.g., if your contract returns a FuelVM's <code>u64</code>, <code>value</code>'s <code>D</code> will be a <code>u64</code>. If it's a FuelVM's tuple <code>(u8,bool)</code>, then <code>D</code> will be a <code>(u8,bool)</code>. If it's a custom type, for instance, a Sway struct <code>MyStruct</code> containing two components, a <code>u64</code>, and a <code>b256</code>, <code>D</code> will be a struct generated at compile-time, called <code>MyStruct</code> with <code>u64</code> and a <code>[u8; 32]</code> (the equivalent of <code>b256</code> in Rust).</p>
<ul>
<li><code>receipts</code> will hold all <a href="https://specs.fuel.network/master/protocol/abi/receipts.html">receipts</a> generated by that specific contract call.</li>
<li><code>gas_used</code> is the amount of gas it consumed by the contract call.</li>
<li><code>tx_id</code> will hold the ID of the corresponding submitted transaction.</li>
</ul>
<!-- call_resp_fields:example:end -->
<h2 id="error-handling"><a class="header" href="#error-handling">Error handling</a></h2>
<!-- This section should explain how to use the `is_ok` and `is_err` methods for a call response -->
<!-- call_resp_ok:example:start -->
<p>You can use the <code>is_ok</code> and <code>is_err</code> methods to check if a contract call <code>Result</code> is <code>Ok</code> or contains an error. These methods will return either <code>true</code> or <code>false</code>.</p>
<!-- call_resp_ok:example:end -->
<!-- This section should show an example of how to use the `is_ok` and `is_err` methods for a call response -->
<!-- call_resp_ok_code:example:start -->
<pre><code class="language-rust  ignore">let is_ok = response.is_ok();
let is_error = response.is_err();
</code></pre>
<!-- call_resp_ok_code:example:end -->
<!-- This section should explain how to use the `unwrap_err` method for a call response -->
<!-- call_resp_error:example:start -->
<p>If <code>is_err</code> returns <code>true</code>, you can use the <code>unwrap_err</code> method to unwrap the error message.</p>
<!-- call_resp_error:example:end -->
<!-- This section should show an example of how to unwrap a call response error -->
<!-- call_resp_error_code:example:start -->
<pre><code class="language-rust  ignore">if response.is_err() {
    let err = response.unwrap_err();
    println!(&quot;ERROR: {:?}&quot;, err);
};
</code></pre>
<!-- call_resp_error_code:example:end -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="logs"><a class="header" href="#logs">Logs</a></h1>
<p>Whenever you log a value within a contract method, the resulting log entry is added to the log receipt and the variable type is recorded in the contract's ABI. The SDK lets you parse those values into Rust types.</p>
<p>Consider the following contract method:</p>
<pre><code class="language-rust ignore">    fn produce_logs_variables() {
        let f: u64 = 64;
        let u: b256 = 0xef86afa9696cf0dc6385e2c407a6e159a1103cefb7e2ae0636fb33d3cb2a9e4a;
        let e: str[4] = __to_str_array(&quot;Fuel&quot;);
        let l: [u8; 3] = [1u8, 2u8, 3u8];

        log(f);
        log(u);
        log(e);
        log(l);
    }
</code></pre>
<p>You can access the logged values in Rust by calling <code>decode_logs_with_type::&lt;T&gt;</code> from a <code>FuelCallResponse</code>, where <code>T</code> is the type of the logged variables you want to retrieve. The result will be a <code>Vec&lt;T&gt;</code>:</p>
<pre><code class="language-rust ignore">    let contract_methods = contract_instance.methods();
    let response = contract_methods.produce_logs_variables().call().await?;

    let log_u64 = response.decode_logs_with_type::&lt;u64&gt;()?;
    let log_bits256 = response.decode_logs_with_type::&lt;Bits256&gt;()?;
    let log_string = response.decode_logs_with_type::&lt;SizedAsciiString&lt;4&gt;&gt;()?;
    let log_array = response.decode_logs_with_type::&lt;[u8; 3]&gt;()?;

    let expected_bits256 = Bits256([
        239, 134, 175, 169, 105, 108, 240, 220, 99, 133, 226, 196, 7, 166, 225, 89, 161, 16, 60,
        239, 183, 226, 174, 6, 54, 251, 51, 211, 203, 42, 158, 74,
    ]);

    assert_eq!(log_u64, vec![64]);
    assert_eq!(log_bits256, vec![expected_bits256]);
    assert_eq!(log_string, vec![&quot;Fuel&quot;]);
    assert_eq!(log_array, vec![[1, 2, 3]]);
</code></pre>
<p>You can use the <code>decode_logs()</code> function to retrieve a <code>LogResult</code> struct containing a <code>results</code> field that is a vector of <code>Result&lt;String&gt;</code> values representing the success or failure of decoding each log.</p>
<pre><code class="language-rust  ignore">    let contract_methods = contract_instance.methods();
    let response = contract_methods.produce_multiple_logs().call().await?;
    let logs = response.decode_logs();
</code></pre>
<p>Due to possible performance hits, it is not recommended to use <code>decode_logs()</code> outside of a debugging scenario.</p>
<blockquote>
<p><strong>Note:</strong> String slices cannot be logged directly. Use the <code>__to_str_array()</code> function to convert it to a <code>str[N]</code> first.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="output-variables"><a class="header" href="#output-variables">Output variables</a></h1>
<!-- This section should explain variable outputs  -->
<!-- variable_outputs:example:start -->
<p>Sometimes, the contract you call might transfer funds to a specific address, depending on its execution. The underlying transaction for such a contract call has to have the appropriate number of <a href="https://specs.fuel.network/master/tx-format/output.html#outputvariable">variable outputs</a> to succeed.</p>
<!-- variable_outputs:example:end -->
<p>Let's say you deployed a contract with the following method:</p>
<pre><code class="language-rust ignore">    fn transfer_coins_to_output(coins: u64, asset_id: AssetId, recipient: Address) {
        transfer_to_address(recipient, asset_id, coins);
    }
</code></pre>
<p>When calling <code>transfer_coins_to_output</code> with the SDK, you can specify the number of variable outputs by chaining <code>append_variable_outputs(amount)</code> to your call. Like this:</p>
<pre><code class="language-rust ignore">        let address = wallet.address();
        let asset_id = contract_id.asset_id(&amp;Bits256::zeroed());

        // withdraw some tokens to wallet
        let response = contract_methods
            .transfer_coins_to_output(1_000_000, asset_id, address)
            .append_variable_outputs(1)
            .call()
            .await?;
</code></pre>
<!-- This section should explain what the `append_variable_outputs` method does -->
<!-- append_variable_outputs:example:start -->
<p><code>append_variable_outputs</code> effectively appends a given amount of <code>Output::Variable</code>s to the transaction's list of outputs. This output type indicates that the amount and the owner may vary based on transaction execution.</p>
<!-- append_variable_outputs:example:end -->
<blockquote>
<p><strong>Note:</strong> that the Sway <code>lib-std</code> function <code>mint_to_address</code> calls <code>transfer_to_address</code> under the hood, so you need to call <code>append_variable_outputs</code> in the Rust SDK tests like you would for <code>transfer_to_address</code>.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="read-only-calls"><a class="header" href="#read-only-calls">Read-only calls</a></h1>
<!-- This section should explain read-only calls  -->
<!-- read_only:example:start -->
<p>Sometimes you want to call a contract method that doesn't change the state of the blockchain. For instance, a method that only reads a value from storage and returns it.</p>
<p>In this case, there's no need to generate an actual blockchain transaction; you only want to read a value quickly.</p>
<p>You can do this with the SDK. Instead of calling the method with <code>.call()</code>, use <code>.simulate()</code>:</p>
<!-- read_only:example:end -->
<pre><code class="language-rust ignore">        // you would mint 100 coins if the transaction wasn't simulated
        let counter = contract_methods.mint_coins(100).simulate().await?;
</code></pre>
<!-- This section should explain what happens if you try a read-only call on a method that changes state  -->
<!-- simulate:example:start -->
<p>Note that if you use <code>.simulate()</code> on a method that <em>does</em> change the state of the blockchain, it won't work properly; it will just <code>dry-run</code> it.</p>
<p>At the moment, it's up to you to know whether a contract method changes state or not, and use <code>.call()</code> or <code>.simulate()</code> accordingly.</p>
<!-- simulate:example:end -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="calling-other-contracts"><a class="header" href="#calling-other-contracts">Calling other contracts</a></h1>
<p>If your contract method is calling other contracts you will have to add the appropriate <code>Inputs</code> and <code>Outputs</code> to your transaction. For your convenience, the <code>ContractCallHandler</code> provides methods that prepare those inputs and outputs for you. You have two methods that you can use: <code>with_contracts(&amp;[&amp;contract_instance, ...])</code> and <code>with_contract_ids(&amp;[&amp;contract_id, ...])</code>.</p>
<p><code>with_contracts(&amp;[&amp;contract_instance, ...])</code> requires contract instances that were created using the <code>abigen</code> macro. When setting the external contracts with this method, logs and require revert errors originating from the external contract can be propagated and decoded by the calling contract.</p>
<pre><code class="language-rust ignore">    let response = contract_caller_instance
        .methods()
        .increment_from_contract(lib_contract_id, 42)
        .with_contracts(&amp;[&amp;lib_contract_instance])
        .call()
        .await?;
</code></pre>
<p>If however, you do not need do decode logs or you do not have a contract instance that was generated using the <code>abigen</code> macro you can use <code>with_contract_ids(&amp;[&amp;contract_id, ...])</code> and provide the required contract ids.</p>
<pre><code class="language-rust ignore">    let response = contract_caller_instance
        .methods()
        .increment_from_contract(lib_contract_id, 42)
        .with_contract_ids(&amp;[lib_contract_id.clone()])
        .call()
        .await?;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="multiple-contract-calls"><a class="header" href="#multiple-contract-calls">Multiple contract calls</a></h1>
<p>With <code>MultiContractCallHandler</code>, you can execute multiple contract calls within a single transaction. To achieve this, you first prepare all the contract calls that you want to bundle:</p>
<pre><code class="language-rust ignore">        let contract_methods = MyContract::new(contract_id, wallet.clone()).methods();

        let call_handler_1 = contract_methods.initialize_counter(42);
        let call_handler_2 = contract_methods.get_array([42; 2]);
</code></pre>
<p>You can also set call parameters, variable outputs, or external contracts for every contract call, as long as you don't execute it with <code>call()</code> or <code>simulate()</code>.</p>
<p>Next, you provide the prepared calls to your <code>MultiContractCallHandler</code> and optionally configure transaction policies:</p>
<pre><code class="language-rust ignore">        let mut multi_call_handler = MultiContractCallHandler::new(wallet.clone());

        multi_call_handler
            .add_call(call_handler_1)
            .add_call(call_handler_2);
</code></pre>
<blockquote>
<p><strong>Note:</strong> any transaction policies configured on separate contract calls are disregarded in favor of the parameters provided to <code>MultiContractCallHandler</code>.</p>
</blockquote>
<p>Furthermore, if you need to separate submission from value retrieval for any reason, you can do so as follows:</p>
<pre><code class="language-rust ignore">        let submitted_tx = multi_call_handler.submit().await?;
        let (counter, array): (u64, [u64; 2]) = submitted_tx.response().await?.value;
</code></pre>
<h2 id="output-values"><a class="header" href="#output-values">Output values</a></h2>
<p>To get the output values of the bundled calls, you need to provide explicit type annotations when saving the result of <code>call()</code> or <code>simulate()</code> to a variable:</p>
<pre><code class="language-rust ignore">        let (counter, array): (u64, [u64; 2]) = multi_call_handler.call().await?.value;
</code></pre>
<p>You can also interact with the <code>FuelCallResponse</code> by moving the type annotation to the invoked method:</p>
<pre><code class="language-rust ignore">        let response = multi_call_handler.call::&lt;(u64, [u64; 2])&gt;().await?;
</code></pre>
<blockquote>
<p><strong>Note:</strong> The <code>MultiContractCallHandler</code> supports only one contract call that returns a heap type. Because of the way heap types are handled, this contract call needs to be at the last position, i.e., added last with <code>add_call</code>. This is a temporary limitation that we hope to lift soon. In the meantime, if you have multiple calls handling heap types, split them across multiple regular, single calls.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="transaction-dependency-estimation"><a class="header" href="#transaction-dependency-estimation">Transaction dependency estimation</a></h1>
<p>Previously, we mentioned that a contract call might require you to manually specify external contracts, variable outputs, or output messages. The SDK can also attempt to estimate and set these dependencies for you at the cost of running multiple simulated calls in the background.</p>
<p>The following example uses a contract call that calls an external contract and later mints assets to a specified address. Calling it without including the dependencies will result in a revert:</p>
<pre><code class="language-rust ignore">        let address = wallet.address();
        let amount = 100;

        let response = contract_methods
            .mint_then_increment_from_contract(called_contract_id, amount, address)
            .call()
            .await;

        assert!(matches!(
            response,
            Err(Error::Transaction(Reason::Reverted { .. }))
        ));
</code></pre>
<p>As mentioned in previous chapters, you can specify the external contract with <code>.with_contracts()</code> and add an output variable with <code>append_variable_outputs()</code> to resolve this:</p>
<pre><code class="language-rust ignore">        let response = contract_methods
            .mint_then_increment_from_contract(called_contract_id, amount, address)
            .append_variable_outputs(1)
            .with_contract_ids(&amp;[called_contract_id.into()])
            .call()
            .await?;
</code></pre>
<p>But this requires you to know the contract ID of the external contract and the needed number of output variables. Alternatively, by chaining <code>.estimate_tx_dependencies()</code> instead, the dependencies will be estimated by the SDK and set automatically. The optional parameter is the maximum number of simulation attempts:</p>
<pre><code class="language-rust ignore">        let response = contract_methods
            .mint_then_increment_from_contract(called_contract_id, amount, address)
            .estimate_tx_dependencies(Some(2))
            .await?
            .call()
            .await?;
</code></pre>
<p>The minimal number of attempts corresponds to the number of external contracts and output variables needed and defaults to 10.</p>
<blockquote>
<p><strong>Note:</strong> <code>estimate_tx_dependencies()</code> can also be used when working with script calls or multi calls. <code>estimate_tx_dependencies()</code> does not currently resolve the dependencies needed for logging from an external contract. For more information, see <a href="calling-contracts/./logs.html">here</a>. If no resolution was found after exhausting all simulation attempts, the last received error will be propagated. The same will happen if an error is unrelated to transaction dependencies.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="estimating-contract-call-cost"><a class="header" href="#estimating-contract-call-cost">Estimating contract call cost</a></h1>
<p>With the function <code>estimate_transaction_cost(tolerance: Option&lt;f64&gt;, block_horizon: Option&lt;u32&gt;)</code> provided by <code>ContractCallHandler</code> and <code>ContractMultiCallHandler</code>, you can get a cost estimation for a specific call. The return type, <code>TransactionCost</code>, is a struct that contains relevant information for the estimation:</p>
<pre><code class="language-rust ignore">pub struct TransactionCost {
    pub gas_price: u64,
    pub gas_used: u64,
    pub metered_bytes_size: u64,
    pub total_fee: u64,
}
</code></pre>
<p>Below are examples that show how to get the estimated transaction cost from single and multi call transactions.</p>
<pre><code class="language-rust ignore">        let contract_instance = MyContract::new(contract_id, wallet);

        let tolerance = Some(0.0);
        let block_horizon = Some(1);
        let transaction_cost = contract_instance
            .methods()
            .initialize_counter(42) // Build the ABI call
            .estimate_transaction_cost(tolerance, block_horizon) // Get estimated transaction cost
            .await?;
</code></pre>
<pre><code class="language-rust ignore">        let mut multi_call_handler = MultiContractCallHandler::new(wallet.clone());

        let call_handler_1 = contract_methods.initialize_counter(42);
        let call_handler_2 = contract_methods.get_array([42; 2]);

        multi_call_handler
            .add_call(call_handler_1)
            .add_call(call_handler_2);

        let tolerance = Some(0.0);
        let block_horizon = Some(1);
        let transaction_cost = multi_call_handler
            .estimate_transaction_cost(tolerance, block_horizon) // Get estimated transaction cost
            .await?;
</code></pre>
<p>The transaction cost estimation can be used to set the gas limit for an actual call, or to show the user the estimated cost.</p>
<blockquote>
<p><strong>Note</strong> The same estimation interface is available for scripts.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="low-level-calls"><a class="header" href="#low-level-calls">Low-level calls</a></h1>
<!-- This section should explain what low-level calls are and how to do them -->
<p>With low-level calls, you can specify the parameters of your calls at runtime and make indirect calls through other contracts.</p>
<p>Your caller contract should call <code>std::low_level_call::call_with_function_selector</code>, providing:</p>
<ul>
<li>target contract ID</li>
<li>function selector encoded as <code>Bytes</code></li>
<li>calldata encoded as <code>Bytes</code></li>
<li>whether the calldata contains only a single value argument (e.g. a <code>u64</code>)</li>
<li><code>std::low_level_call::CallParams</code></li>
</ul>
<pre><code class="language-rust ignore">    fn call_low_level_call(
        target: ContractId,
        function_selector: Bytes,
        calldata: Bytes,
        single_value_type_arg: bool,
    ) {
        let call_params = CallParams {
            coins: 0,
            asset_id: BASE_ASSET_ID,
            gas: 10_000,
        };

        call_with_function_selector(
            target,
            function_selector,
            calldata,
            single_value_type_arg,
            call_params,
        );
    }
</code></pre>
<p>On the SDK side, you can construct an encoded function selector using the <code>fuels::core::fn_selector!</code> macro, and encoded calldata using the <code>fuels::core::calldata!</code> macro.</p>
<p>E.g. to call the following function on the target contract:</p>
<pre><code class="language-rust ignore">    #[storage(write)]
    fn set_value_multiple_complex(a: MyStruct, b: str[4]);
</code></pre>
<p>you would construct the function selector and the calldata as such, and provide them to the caller contract (like the one above):</p>
<pre><code class="language-rust ignore">        let function_selector =
            fn_selector!(set_value_multiple_complex(MyStruct, SizedAsciiString::&lt;4&gt;));
        let call_data = calldata!(
            MyStruct {
                a: true,
                b: [1, 2, 3],
            },
            SizedAsciiString::&lt;4&gt;::try_from(&quot;fuel&quot;)?
        )?;

        caller_contract_instance
            .methods()
            .call_low_level_call(
                target_contract_instance.id(),
                Bytes(function_selector),
                Bytes(call_data),
                false,
            )
            .estimate_tx_dependencies(None)
            .await?
            .call()
            .await?;
</code></pre>
<blockquote>
<p>Note: the <code>calldata!</code> macro uses the default <code>EncoderConfig</code> configuration under the hood.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="running-scripts"><a class="header" href="#running-scripts">Running scripts</a></h1>
<p>You can run a script using its JSON-ABI and the path to its binary file. You can run the scripts with arguments. For this, you have to use the <code>abigen!</code> macro seen <a href="./abigen/the-abigen-macro.html">previously</a>.</p>
<pre><code class="language-rust ignore">    // The abigen is used for the same purpose as with contracts (Rust bindings)
    abigen!(Script(
        name = &quot;MyScript&quot;,
        abi = &quot;packages/fuels/tests/scripts/arguments/out/debug/arguments-abi.json&quot;
    ));
    let wallet = launch_provider_and_get_wallet().await?;
    let bin_path = &quot;../fuels/tests/scripts/arguments/out/debug/arguments.bin&quot;;
    let script_instance = MyScript::new(wallet, bin_path);

    let bim = Bimbam { val: 90 };
    let bam = SugarySnack {
        twix: 100,
        mars: 1000,
    };

    let result = script_instance.main(bim, bam).call().await?;

    let expected = Bimbam { val: 2190 };
    assert_eq!(result.value, expected);
</code></pre>
<p>Furthermore, if you need to separate submission from value retrieval for any reason, you can do so as follows:</p>
<pre><code class="language-rust ignore">    let submitted_tx = script_instance.main(my_struct).submit().await?;
    let value = submitted_tx.response().await?.value;
</code></pre>
<h2 id="running-scripts-with-transaction-policies"><a class="header" href="#running-scripts-with-transaction-policies">Running scripts with transaction policies</a></h2>
<p>The method for passing transaction policies is the same as <a href="./calling-contracts/tx-policies.html">with contracts</a>. As a reminder, the workflow would look like this:</p>
<pre><code class="language-rust ignore">    let tx_policies = TxPolicies::default().with_script_gas_limit(1_000_000);
    let result = script_instance
        .main(a, b)
        .with_tx_policies(tx_policies)
        .call()
        .await?;
</code></pre>
<h2 id="logs-1"><a class="header" href="#logs-1">Logs</a></h2>
<p>Script calls provide the same logging functions, <code>decode_logs()</code> and <code>decode_logs_with_type&lt;T&gt;()</code>, as contract calls. As a reminder, the workflow looks like this:</p>
<pre><code class="language-rust ignore">    abigen!(Script(
        name = &quot;log_script&quot;,
        abi = &quot;packages/fuels/tests/logs/script_logs/out/debug/script_logs-abi.json&quot;
    ));

    let wallet = launch_provider_and_get_wallet().await?;
    let bin_path = &quot;../fuels/tests/logs/script_logs/out/debug/script_logs.bin&quot;;
    let instance = log_script::new(wallet.clone(), bin_path);

    let response = instance.main().call().await?;

    let logs = response.decode_logs();
    let log_u64 = response.decode_logs_with_type::&lt;u64&gt;()?;
</code></pre>
<h2 id="calling-contracts-from-scripts"><a class="header" href="#calling-contracts-from-scripts">Calling contracts from scripts</a></h2>
<p>Scripts use the same interfaces for setting external contracts as <a href="./calling-contracts/other-contracts.html">contract methods</a>.</p>
<p>Below is an example that uses <code>with_contracts(&amp;[&amp;contract_instance, ...])</code>.</p>
<pre><code class="language-rust ignore">    let response = script_instance
        .main(contract_id)
        .with_contracts(&amp;[&amp;contract_instance])
        .call()
        .await?;
</code></pre>
<p>And this is an example that uses <code>with_contract_ids(&amp;[&amp;contract_id, ...])</code>.</p>
<pre><code class="language-rust ignore">    let response = script_instance
        .main(contract_id)
        .with_contract_ids(&amp;[contract_id.into()])
        .call()
        .await?;
</code></pre>
<h2 id="configurable-constants-1"><a class="header" href="#configurable-constants-1">Configurable constants</a></h2>
<p>Same as contracts, you can define <code>configurable</code> constants in <code>scripts</code> which can be changed during the script execution. Here is an example how the constants are defined.</p>
<pre><code class="language-rust ignore">script;

#[allow(dead_code)]
enum EnumWithGeneric&lt;D&gt; {
    VariantOne: D,
    VariantTwo: (),
}

#[allow(dead_code)]
struct StructWithGeneric&lt;D&gt; {
    field_1: D,
    field_2: u64,
}

configurable {
    U8: u8 = 8u8,
    BOOL: bool = true,
    ARRAY: [u32; 3] = [253u32, 254u32, 255u32],
    STR_4: str[4] = __to_str_array(&quot;fuel&quot;),
    STRUCT: StructWithGeneric&lt;u8&gt; = StructWithGeneric {
        field_1: 8u8,
        field_2: 16,
    },
    ENUM: EnumWithGeneric&lt;bool&gt; = EnumWithGeneric::VariantOne(true),
}

fn main() -&gt; (u8, bool, [u32; 3], str[4], StructWithGeneric&lt;u8&gt;, EnumWithGeneric&lt;bool&gt;) {
    (U8, BOOL, ARRAY, STR_4, STRUCT, ENUM)
}
</code></pre>
<p>Each configurable constant will get a dedicated <code>with</code> method in the SDK. For example, the constant <code>STR_4</code> will get the <code>with_STR_4</code> method which accepts the same type defined in sway. Below is an example where we chain several <code>with</code> methods and execute the script with the new constants.</p>
<pre><code class="language-rust ignore">    abigen!(Script(name=&quot;MyScript&quot;, abi=&quot;packages/fuels/tests/scripts/script_configurables/out/debug/script_configurables-abi.json&quot;));

    let wallet = launch_provider_and_get_wallet().await?;
    let bin_path = &quot;../fuels/tests/scripts/script_configurables/out/debug/script_configurables.bin&quot;;
    let instance = MyScript::new(wallet, bin_path);

    let new_str: SizedAsciiString&lt;4&gt; = &quot;FUEL&quot;.try_into()?;
    let new_struct = StructWithGeneric {
        field_1: 16u8,
        field_2: 32,
    };
    let new_enum = EnumWithGeneric::VariantTwo;

    let configurables = MyScriptConfigurables::new(EncoderConfig {
        max_tokens: 5,
        ..Default::default()
    })
    .with_STR_4(new_str.clone())?
    .with_STRUCT(new_struct.clone())?
    .with_ENUM(new_enum.clone())?;

    let response = instance
        .with_configurables(configurables)
        .main()
        .call()
        .await?;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="predicates"><a class="header" href="#predicates">Predicates</a></h1>
<p>Predicates, in Sway, are programs that return a Boolean value and do not have any side effects (they are pure). A predicate address can own assets. The predicate address is generated from the compiled byte code and is the same as the <code>P2SH</code> address used in Bitcoin. Users can seamlessly send assets to the predicate address as they do for any other address. To spend the predicate funds, the user has to provide the original <code>byte code</code> of the predicate together with the <code>predicate data</code>. The <code>predicate data</code> will be used when executing the <code>byte code</code>, and the funds can be transferred if the predicate is validated successfully.</p>
<h2 id="instantiating-predicates"><a class="header" href="#instantiating-predicates">Instantiating predicates</a></h2>
<p>Let's consider the following predicate example:</p>
<pre><code class="language-rust ignore">predicate;

fn main(a: u32, b: u64) -&gt; bool {
    b == a.as_u64()
}
</code></pre>
<p>We will look at a complete example of using the SDK to send and receive funds from a predicate.</p>
<p>First, we set up the wallets and a node instance. The call to the <code>abigen!</code> macro will generate all the types specified in the predicate plus two custom structs:</p>
<ul>
<li>an encoder with an <code>encode_data</code>  function that will conveniently encode all the arguments of the main function for us.</li>
<li>a configurables struct which holds methods for setting all the configurables mentioned in the predicate</li>
</ul>
<blockquote>
<p>Note: The <code>abigen!</code> macro will append <code>Encoder</code> and <code>Configurables</code> to the predicate's <code>name</code> field. Fox example, <code>name=&quot;MyPredicate&quot;</code> will result in two structs called <code>MyPredicateEncoder</code> and <code>MyPredicateConfigurables</code>.</p>
</blockquote>
<pre><code class="language-rust ignore">        let asset_id = AssetId::default();
        let wallets_config = WalletsConfig::new_multiple_assets(
            2,
            vec![AssetConfig {
                id: asset_id,
                num_coins: 1,
                coin_amount: 1_000,
            }],
        );

        let wallets = &amp;launch_custom_provider_and_get_wallets(wallets_config, None, None).await?;

        let first_wallet = &amp;wallets[0];
        let second_wallet = &amp;wallets[1];

        abigen!(Predicate(name=&quot;MyPredicate&quot;, abi=&quot;packages/fuels/tests/predicates/basic_predicate/out/debug/basic_predicate-abi.json&quot;));
</code></pre>
<p>Once we've compiled our predicate with <code>forc build</code>, we can create a <code>Predicate</code> instance via <code>Predicate::load_from</code>. The resulting data from <code>encode_data</code> can then be set on the loaded predicate.</p>
<pre><code class="language-rust ignore">        let predicate_data = MyPredicateEncoder::default().encode_data(4096, 4096)?;
        let code_path =
            &quot;../../packages/fuels/tests/predicates/basic_predicate/out/debug/basic_predicate.bin&quot;;

        let predicate: Predicate = Predicate::load_from(code_path)?
            .with_provider(first_wallet.try_provider()?.clone())
            .with_data(predicate_data);
</code></pre>
<p>Next, we lock some assets in this predicate using the first wallet:</p>
<pre><code class="language-rust ignore">        // First wallet transfers amount to predicate.
        first_wallet
            .transfer(predicate.address(), 500, asset_id, TxPolicies::default())
            .await?;

        // Check predicate balance.
        let balance = predicate.get_asset_balance(&amp;AssetId::default()).await?;

        assert_eq!(balance, 500);
</code></pre>
<p>Then we can transfer assets owned by the predicate via the <a href="predicates/../accounts.html">Account</a> trait:</p>
<pre><code class="language-rust ignore">        let amount_to_unlock = 500;

        predicate
            .transfer(
                second_wallet.address(),
                amount_to_unlock,
                asset_id,
                TxPolicies::default(),
            )
            .await?;

        // Predicate balance is zero.
        let balance = predicate.get_asset_balance(&amp;AssetId::default()).await?;

        assert_eq!(balance, 0);

        // Second wallet balance is updated.
        let balance = second_wallet.get_asset_balance(&amp;AssetId::default()).await?;
        assert_eq!(balance, 1500);
</code></pre>
<h2 id="configurable-constants-2"><a class="header" href="#configurable-constants-2">Configurable constants</a></h2>
<p>Same as contracts and scripts, you can define configurable constants in <code>predicates</code>, which can be changed during the predicate execution. Here is an example of how the constants are defined.</p>
<pre><code class="language-rust ignore">#[allow(dead_code)]
enum EnumWithGeneric&lt;D&gt; {
    VariantOne: D,
    VariantTwo: (),
}

struct StructWithGeneric&lt;D&gt; {
    field_1: D,
    field_2: u64,
}

configurable {
    U8: u8 = 8u8,
    BOOL: bool = true,
    STRUCT: StructWithGeneric&lt;u8&gt; = StructWithGeneric {
        field_1: 8u8,
        field_2: 16,
    },
    ENUM: EnumWithGeneric&lt;bool&gt; = EnumWithGeneric::VariantOne(true),
}

fn main(
    u_8: u8,
    switch: bool,
    some_struct: StructWithGeneric&lt;u8&gt;,
    some_enum: EnumWithGeneric&lt;bool&gt;,
) -&gt; bool {
    u_8 == U8 &amp;&amp; switch == BOOL &amp;&amp; some_struct == STRUCT &amp;&amp; some_enum == ENUM
}
</code></pre>
<p>Each configurable constant will get a dedicated <code>with</code> method in the SDK. For example, the constant <code>U8</code> will get the <code>with_U8</code> method which accepts the same type defined in sway. Below is an example where we chain several <code>with</code> methods and update the predicate with the new constants.</p>
<pre><code class="language-rust ignore">    abigen!(Predicate(
        name = &quot;MyPredicate&quot;,
        abi = &quot;packages/fuels/tests/predicates/predicate_configurables/out/debug/predicate_configurables-abi.json&quot;
    ));

    let new_struct = StructWithGeneric {
        field_1: 32u8,
        field_2: 64,
    };
    let new_enum = EnumWithGeneric::VariantTwo;

    let configurables = MyPredicateConfigurables::default()
        .with_STRUCT(new_struct.clone())?
        .with_ENUM(new_enum.clone())?;

    let predicate_data =
        MyPredicateEncoder::default().encode_data(8u8, true, new_struct, new_enum)?;

    let mut predicate: Predicate = Predicate::load_from(
        &quot;tests/predicates/predicate_configurables/out/debug/predicate_configurables.bin&quot;,
    )?
    .with_data(predicate_data)
    .with_configurables(configurables);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="signatures-in-predicates-example"><a class="header" href="#signatures-in-predicates-example">Signatures in predicates example</a></h1>
<p>This is a more involved example where the predicate accepts three signatures and matches them to three predefined public keys. The <code>ec_recover_address</code> function is used to recover the public key from the signatures. If two of the three extracted public keys match the predefined public keys, the funds can be spent. Note that the signature order has to match the order of the predefined public keys.</p>
<pre><code class="language-rust ignore">predicate;

use std::{b512::B512, constants::ZERO_B256, ecr::ec_recover_address, inputs::input_predicate_data};

fn extract_public_key_and_match(signature: B512, expected_public_key: b256) -&gt; u64 {
    if let Result::Ok(pub_key_sig) = ec_recover_address(signature, ZERO_B256)
    {
        if pub_key_sig.value == expected_public_key {
            return 1;
        }
    }
    0
}

fn main(signatures: [B512; 3]) -&gt; bool {
    let public_keys = [
        0xd58573593432a30a800f97ad32f877425c223a9e427ab557aab5d5bb89156db0,
        0x14df7c7e4e662db31fe2763b1734a3d680e7b743516319a49baaa22b2032a857,
        0x3ff494fb136978c3125844625dad6baf6e87cdb1328c8a51f35bda5afe72425c,
    ];

    let mut matched_keys = 0;

    matched_keys = extract_public_key_and_match(signatures[0], public_keys[0]);
    matched_keys = matched_keys + extract_public_key_and_match(signatures[1], public_keys[1]);
    matched_keys = matched_keys + extract_public_key_and_match(signatures[2], public_keys[2]);

    matched_keys &gt; 1
}
</code></pre>
<p>Let's use the SDK to interact with the predicate. First, let's create three wallets with specific keys. Their hashed public keys are already hard-coded in the predicate. Then we create the receiver wallet, which we will use to spend the predicate funds.</p>
<pre><code class="language-rust ignore">        let secret_key1: SecretKey =
            &quot;0x862512a2363db2b3a375c0d4bbbd27172180d89f23f2e259bac850ab02619301&quot;.parse()?;

        let secret_key2: SecretKey =
            &quot;0x37fa81c84ccd547c30c176b118d5cb892bdb113e8e80141f266519422ef9eefd&quot;.parse()?;

        let secret_key3: SecretKey =
            &quot;0x976e5c3fa620092c718d852ca703b6da9e3075b9f2ecb8ed42d9f746bf26aafb&quot;.parse()?;

        let mut wallet = WalletUnlocked::new_from_private_key(secret_key1, None);
        let mut wallet2 = WalletUnlocked::new_from_private_key(secret_key2, None);
        let mut wallet3 = WalletUnlocked::new_from_private_key(secret_key3, None);
        let mut receiver = WalletUnlocked::new_random(None);
</code></pre>
<p>Next, let's add some coins, start a provider and connect it with the wallets.</p>
<pre><code class="language-rust ignore">        let asset_id = AssetId::default();
        let num_coins = 32;
        let amount = 64;
        let initial_balance = amount * num_coins;
        let all_coins = [&amp;wallet, &amp;wallet2, &amp;wallet3, &amp;receiver]
            .iter()
            .flat_map(|wallet| {
                setup_single_asset_coins(wallet.address(), asset_id, num_coins, amount)
            })
            .collect::&lt;Vec&lt;_&gt;&gt;();

        let provider = setup_test_provider(all_coins, vec![], None, None).await?;

        [&amp;mut wallet, &amp;mut wallet2, &amp;mut wallet3, &amp;mut receiver]
            .iter_mut()
            .for_each(|wallet| {
                wallet.set_provider(provider.clone());
            });
</code></pre>
<p>Now we can use the predicate abigen to create a predicate encoder instance for us. To spend the funds now locked in the predicate, we must provide two out of three signatures whose public keys match the ones we defined in the predicate. In this example, the signatures are generated from an array of zeros.</p>
<pre><code class="language-rust ignore">        abigen!(Predicate(
            name = &quot;MyPredicate&quot;,
            abi = &quot;packages/fuels/tests/predicates/signatures/out/debug/signatures-abi.json&quot;
        ));

        let predicate_data = MyPredicateEncoder::default().encode_data(signatures)?;
        let code_path = &quot;../../packages/fuels/tests/predicates/signatures/out/debug/signatures.bin&quot;;

        let predicate: Predicate = Predicate::load_from(code_path)?
            .with_provider(provider)
            .with_data(predicate_data);
</code></pre>
<p>Next, we transfer some assets from a wallet to the created predicate. We also confirm that the funds are indeed transferred.</p>
<pre><code class="language-rust ignore">        let amount_to_predicate = 512;

        wallet
            .transfer(
                predicate.address(),
                amount_to_predicate,
                asset_id,
                TxPolicies::default(),
            )
            .await?;

        let predicate_balance = predicate.get_asset_balance(&amp;asset_id).await?;
        assert_eq!(predicate_balance, amount_to_predicate);
</code></pre>
<p>We can use the <code>transfer</code> method from the <a href="predicates/../accounts.html">Account</a> trait to transfer the assets. If the predicate data is correct, the <code>receiver</code> wallet will get the funds, and we will verify that the amount is correct.</p>
<pre><code class="language-rust ignore">        predicate
            .transfer(
                receiver.address(),
                amount_to_predicate,
                asset_id,
                TxPolicies::default(),
            )
            .await?;

        let receiver_balance_after = receiver.get_asset_balance(&amp;asset_id).await?;
        assert_eq!(
            initial_balance + amount_to_predicate,
            receiver_balance_after
        );

        let predicate_balance = predicate.get_asset_balance(&amp;asset_id).await?;
        assert_eq!(predicate_balance, 0);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-transactions"><a class="header" href="#custom-transactions">Custom transactions</a></h1>
<p>Until now, we have used helpers to create transactions, send them with a provider, and parse the results. However, sometimes we must make custom transactions with specific inputs, outputs, witnesses, etc. In the next chapter, we will show how to use the Rust SDKs transaction builders to accomplish this.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="transaction-builders"><a class="header" href="#transaction-builders">Transaction Builders</a></h1>
<p>The Rust SDK simplifies the creation of <strong>Create</strong> and <strong>Script</strong> transactions through two handy builder structs <code>CreateTransactionBuilder</code>, <code>ScriptTransactionBuilder</code>, and the <code>TransactionBuilder</code> trait.</p>
<p>Calling <code>build(&amp;provider)</code> on a builder will result in the corresponding <code>CreateTransaction</code> or <code>ScriptTransaction</code> that can be submitted to the network.</p>
<h2 id="role-of-the-transaction-builders"><a class="header" href="#role-of-the-transaction-builders">Role of the transaction builders</a></h2>
<blockquote>
<p><strong>Note</strong> This section contains additional information about the inner workings of the builders. If you are just interested in how to use them, you can skip to the next section.</p>
</blockquote>
<p>The builders take on the heavy lifting behind the scenes, offering two standout advantages: handling predicate data offsets and managing witness indexing.</p>
<p>When your transaction involves predicates with dynamic data as inputs, like vectors, the dynamic data contains a pointer pointing to the beginning of the raw data. This pointer's validity hinges on the order of transaction inputs, and any shifting could render it invalid. However, the transaction builders conveniently postpone the resolution of these pointers until you finalize the build process.</p>
<p>Similarly, adding signatures for signed coins requires the signed coin input to hold an index corresponding to the signature in the witnesses array. These indexes can also become invalid if the witness order changes. The Rust SDK again defers the resolution of these indexes until the transaction is finalized. It handles the assignment of correct index witnesses behind the scenes, sparing you the hassle of dealing with indexing intricacies during input definition.</p>
<p>Another added benefit of the builder pattern is that it guards against changes once the transaction is finalized. The transactions resulting from a builder don't permit any changes to the struct that could cause the transaction ID to be modified. This eliminates the headache of calculating and storing a transaction ID for future use, only to accidentally modify the transaction later, resulting in a different transaction ID.</p>
<h2 id="creating-a-custom-transaction"><a class="header" href="#creating-a-custom-transaction">Creating a custom transaction</a></h2>
<p>Here is an example outlining some of the features of the transaction builders.</p>
<p>In this scenario, we have a predicate that holds some bridged asset with ID <strong>bridged_asset_id</strong>. It releases it's locked assets if the transaction sends <strong>ask_amount</strong> of the base asset to the <strong>receiver</strong> address:</p>
<pre><code class="language-rust ignore">        let ask_amount = 100;
        let locked_amount = 500;
        let bridged_asset_id = AssetId::from([1u8; 32]);
        let receiver = Bech32Address::from_str(
            &quot;fuel1p8qt95dysmzrn2rmewntg6n6rg3l8ztueqafg5s6jmd9cgautrdslwdqdw&quot;,
        )?;
</code></pre>
<p>Our goal is to create a transaction that will use our hot wallet to transfer the <strong>ask_amount</strong> to the <strong>receiver</strong> and then send the unlocked predicate assets to a second wallet that acts as our cold storage.</p>
<p>Let's start by instantiating a builder. Since we don't plan to deploy a contract, the <code>ScriptTransactionBuilder</code> is the appropriate choice:</p>
<pre><code class="language-rust ignore">        let tb = ScriptTransactionBuilder::default();
</code></pre>
<p>Next, we need to define transaction inputs of the base asset that sum up to <strong>ask_amount</strong>. We also need transaction outputs that will assign those assets to the predicate address and thereby unlock it. The methods <code>get_asset_inputs_for_amount</code> and <code>get_asset_outputs_for_amount</code> can help with that. We need to specify the asset ID, the target amount, and the target address:</p>
<pre><code class="language-rust ignore">        let base_inputs = hot_wallet
            .get_asset_inputs_for_amount(BASE_ASSET_ID, ask_amount)
            .await?;
        let base_outputs =
            hot_wallet.get_asset_outputs_for_amount(&amp;receiver, BASE_ASSET_ID, ask_amount);
</code></pre>
<p>Let's repeat the same process but this time for transferring the assets held by the predicate to our cold storage:</p>
<pre><code class="language-rust ignore">        let other_asset_inputs = predicate
            .get_asset_inputs_for_amount(bridged_asset_id, locked_amount)
            .await?;
        let other_asset_outputs =
            predicate.get_asset_outputs_for_amount(cold_wallet.address(), bridged_asset_id, 500);
</code></pre>
<p>We combine all of the inputs and outputs and set them on the builder:</p>
<pre><code class="language-rust ignore">        let inputs = base_inputs
            .into_iter()
            .chain(other_asset_inputs.into_iter())
            .collect();
        let outputs = base_outputs
            .into_iter()
            .chain(other_asset_outputs.into_iter())
            .collect();

        let mut tb = tb.with_inputs(inputs).with_outputs(outputs);
</code></pre>
<p>As we have used coins that require a signature, we have to add the signer to the transaction builder with:</p>
<pre><code class="language-rust ignore">        tb.add_signer(hot_wallet.clone())?;
</code></pre>
<blockquote>
<p><strong>Note</strong> The signature is not created until the transaction is finalized with <code>build(&amp;provider)</code></p>
</blockquote>
<p>We need to do one more thing before we stop thinking about transaction inputs. Executing the transaction also incurs a fee that is paid with the base asset. Our base asset inputs need to be large enough so that the total amount covers the transaction fee and any other operations we are doing. The <code>Account</code> trait lets us use <code>adjust_for_fee()</code> for adjusting the transaction inputs if needed to cover the fee. The second argument to <code>adjust_for_fee()</code> is the total amount of the base asset that we expect our transaction to spend regardless of fees. In our case, this is the <strong>ask_amount</strong> we are transferring to the predicate.</p>
<pre><code class="language-rust ignore">        hot_wallet.adjust_for_fee(&amp;mut tb, 100).await?;
</code></pre>
<blockquote>
<p><strong>Note</strong> It is recommended to add signers before calling <code>adjust_for_fee()</code> as the estimation will include the size of the witnesses.</p>
</blockquote>
<p>We can also define transaction policies. For example, we can limit the gas price by doing the following:</p>
<pre><code class="language-rust ignore">        let tx_policies = TxPolicies::default().with_tip(1);
        let tb = tb.with_tx_policies(tx_policies);
</code></pre>
<p>Our builder needs a signature from the hot wallet to unlock its coins before we call <code>build()</code> and submit the resulting transaction through the provider:</p>
<pre><code class="language-rust ignore">        let tx = tb.build(&amp;provider).await?;
        let tx_id = provider.send_transaction(tx).await?;
</code></pre>
<p>Finally, we verify the transaction succeeded and that the cold storage indeed holds the bridged asset now:</p>
<pre><code class="language-rust ignore">        let status = provider.tx_status(&amp;tx_id).await?;
        assert!(matches!(status, TxStatus::Success { .. }));

        let balance = cold_wallet.get_asset_balance(&amp;bridged_asset_id).await?;
        assert_eq!(balance, locked_amount);
</code></pre>
<h2 id="building-a-transaction-without-signatures"><a class="header" href="#building-a-transaction-without-signatures">Building a transaction without signatures</a></h2>
<p>If you need to build the transaction without signatures, which is useful when estimating transaction costs or simulations, you can use the <code>build_without_signatures(&amp;provider)</code> method and later sign the built transaction.</p>
<pre><code class="language-rust ignore">    let mut tx = tb.build_without_signatures(provider).await?;
    tx.sign_with(&amp;wallet, provider.chain_id()).await?;
</code></pre>
<blockquote>
<p><strong>Note</strong> In contrast to adding signers to a transaction builder, when signing a built transaction, you must ensure that the order of signatures matches the order of signed inputs. Multiple signed inputs with the same owner will have the same witness index.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-contract-and-script-calls"><a class="header" href="#custom-contract-and-script-calls">Custom contract and script calls</a></h1>
<p>When preparing a contract call via <code>ContractCallHandler</code> or a script call via <code>ScriptCallHandler</code>, the Rust SDK uses a transaction builder in the background. You can fetch this builder and customize it before submitting it to the network. After the transaction is executed successfully, you can use the corresponding <code>ContractCallHandler</code> or <code>ScriptCallHandler</code> to generate a <a href="custom-transactions/../calling-contracts/call-response.html">call response</a>. The call response can be used to decode return values and logs. Below are examples for both contract and script calls.</p>
<h2 id="custom-contract-call"><a class="header" href="#custom-contract-call">Custom contract call</a></h2>
<pre><code class="language-rust ignore">        let call_handler = contract_instance.methods().initialize_counter(counter);

        let mut tb = call_handler.transaction_builder().await?;

        // customize the builder...

        wallet.adjust_for_fee(&amp;mut tb, 0).await?;
        tb.add_signer(wallet.clone())?;

        let tx = tb.build(provider).await?;

        let tx_id = provider.send_transaction(tx).await?;
        let tx_status = provider.tx_status(&amp;tx_id).await?;

        let response = call_handler.get_response_from(tx_status)?;

        assert_eq!(counter, response.value);
</code></pre>
<h2 id="custom-script-call"><a class="header" href="#custom-script-call">Custom script call</a></h2>
<pre><code class="language-rust ignore">    let script_call_handler = script_instance.main(1, 2);

    let mut tb = script_call_handler.transaction_builder().await?;

    // customize the builder...

    wallet.adjust_for_fee(&amp;mut tb, 0).await?;
    tb.add_signer(wallet.clone())?;

    let tx = tb.build(provider).await?;

    let tx_id = provider.send_transaction(tx).await?;
    let tx_status = provider.tx_status(&amp;tx_id).await?;

    let response = script_call_handler.get_response_from(tx_status)?;

    assert_eq!(response.value, &quot;hello&quot;);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="types"><a class="header" href="#types">Types</a></h1>
<p>The FuelVM and Sway have many internal types. These types have equivalents in the SDK. This section discusses these types, how to use them, and how to convert them.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bytes32"><a class="header" href="#bytes32"><code>Bytes32</code></a></h1>
<p>In Sway and the FuelVM, <code>Bytes32</code> represents hashes. They hold a 256-bit (32-byte) value. <code>Bytes32</code> is a wrapper on a 32-sized slice of <code>u8</code>: <code>pub struct Bytes32([u8; 32]);</code>.</p>
<p>These are the main ways of creating a <code>Bytes32</code>:</p>
<pre><code class="language-rust ignore">        use std::str::FromStr;

        use fuels::types::Bytes32;

        // Zeroed Bytes32
        let b256 = Bytes32::zeroed();

        // Grab the inner `[u8; 32]` from
        // `Bytes32` by dereferencing (i.e. `*`) it.
        assert_eq!([0u8; 32], *b256);

        // From a `[u8; 32]`.
        let my_slice = [1u8; 32];
        let b256 = Bytes32::new(my_slice);
        assert_eq!([1u8; 32], *b256);

        // From a hex string.
        let hex_str = &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;;
        let b256 = Bytes32::from_str(hex_str)?;
        assert_eq!([0u8; 32], *b256);
</code></pre>
<p><code>Bytes32</code> also implements the <code>fmt</code> module's <code>Debug</code>, <code>Display</code>, <code>LowerHex</code> and <code>UpperHex</code> traits. For example, you can get the display and hex representations with:</p>
<pre><code class="language-rust ignore">        let b256_string = b256.to_string();
        let b256_hex_string = format!(&quot;{b256:#x}&quot;);
</code></pre>
<p>For a full list of implemented methods and traits, see the <a href="https://docs.rs/fuel-types/latest/fuel_types/struct.Bytes32.html">fuel-types documentation</a>.</p>
<blockquote>
<p><strong>Note:</strong> In Fuel, there's a special type called <code>b256</code>, which is similar to <code>Bytes32</code>; also used to represent hashes, and it holds a 256-bit value. In Rust, through the SDK, this is represented as <code>Bits256(value)</code> where <code>value</code> is a <code>[u8; 32]</code>. If your contract method takes a <code>b256</code> as input, all you need to do is pass a <code>Bits256([u8; 32])</code> when calling it from the SDK.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="address"><a class="header" href="#address"><code>Address</code></a></h1>
<p>Like <code>Bytes32</code>, <code>Address</code> is a wrapper on <code>[u8; 32]</code> with similar methods and implements the same traits (see <a href="https://docs.rs/fuel-types/latest/fuel_types/struct.Address.html">fuel-types documentation</a>).</p>
<p>These are the main ways of creating an <code>Address</code>:</p>
<pre><code class="language-rust ignore">        use std::str::FromStr;

        use fuels::types::Address;

        // Zeroed Bytes32
        let address = Address::zeroed();

        // Grab the inner `[u8; 32]` from
        // `Bytes32` by dereferencing (i.e. `*`) it.
        assert_eq!([0u8; 32], *address);

        // From a `[u8; 32]`.
        let my_slice = [1u8; 32];
        let address = Address::new(my_slice);
        assert_eq!([1u8; 32], *address);

        // From a string.
        let hex_str = &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;;
        let address = Address::from_str(hex_str)?;
        assert_eq!([0u8; 32], *address);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contractid"><a class="header" href="#contractid"><code>ContractId</code></a></h1>
<p>Like <code>Bytes32</code>, <code>ContractId</code> is a wrapper on <code>[u8; 32]</code> with similar methods and implements the same traits (see <a href="https://docs.rs/fuel-types/%7B%7Bversions.fuel-types%7D%7D/fuel_types/struct.ContractId.html">fuel-types documentation</a>).</p>
<p>These are the main ways of creating a <code>ContractId</code>:</p>
<pre><code class="language-rust ignore">        use std::str::FromStr;

        use fuels::types::ContractId;

        // Zeroed Bytes32
        let contract_id = ContractId::zeroed();

        // Grab the inner `[u8; 32]` from
        // `Bytes32` by dereferencing (i.e. `*`) it.
        assert_eq!([0u8; 32], *contract_id);

        // From a `[u8; 32]`.
        let my_slice = [1u8; 32];
        let contract_id = ContractId::new(my_slice);
        assert_eq!([1u8; 32], *contract_id);

        // From a string.
        let hex_str = &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;;
        let contract_id = ContractId::from_str(hex_str)?;
        assert_eq!([0u8; 32], *contract_id);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="assetid"><a class="header" href="#assetid"><code>AssetId</code></a></h1>
<p>Like <code>Bytes32</code>, <code>AssetId</code> is a wrapper on <code>[u8; 32]</code> with similar methods and implements the same traits (see <a href="https://docs.rs/fuel-types/%7B%7Bversions.fuel-types%7D%7D/fuel_types/struct.AssetId.html">fuel-types documentation</a>).</p>
<p>These are the main ways of creating an <code>AssetId</code>:</p>
<pre><code class="language-rust ignore">        use std::str::FromStr;

        use fuels::types::AssetId;

        // Zeroed Bytes32
        let asset_id = AssetId::zeroed();

        // Grab the inner `[u8; 32]` from
        // `Bytes32` by dereferencing (i.e. `*`) it.
        assert_eq!([0u8; 32], *asset_id);

        // From a `[u8; 32]`.
        let my_slice = [1u8; 32];
        let asset_id = AssetId::new(my_slice);
        assert_eq!([1u8; 32], *asset_id);

        // From a string.
        let hex_str = &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;;
        let asset_id = AssetId::from_str(hex_str)?;
        assert_eq!([0u8; 32], *asset_id);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bech32"><a class="header" href="#bech32"><code>Bech32</code></a></h1>
<p><code>Bech32Address</code> and <code>Bech32ContractId</code> enable the use of addresses and contract IDs in the <code>bech32</code> format. They can easily be converted to their counterparts <code>Address</code> and <code>ContractId</code>.</p>
<p>Here are the main ways of creating a <code>Bech32Address</code>, but note that the same applies to <code>Bech32ContractId</code>:</p>
<pre><code class="language-rust ignore">        use fuels::types::{bech32::Bech32Address, Address, Bytes32};

        // New from HRP string and a hash
        let hrp = &quot;fuel&quot;;
        let my_slice = [1u8; 32];
        let _bech32_address = Bech32Address::new(hrp, my_slice);

        // Note that you can also pass a hash stored as Bytes32 to new:
        let my_hash = Bytes32::new([1u8; 32]);
        let _bech32_address = Bech32Address::new(hrp, my_hash);

        // From a string.
        let address = &quot;fuel1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqsx2mt2&quot;;
        let bech32_address = Bech32Address::from_str(address)?;
        assert_eq!([0u8; 32], *bech32_address.hash());

        // From Address
        let plain_address = Address::new([0u8; 32]);
        let bech32_address = Bech32Address::from(plain_address);
        assert_eq!([0u8; 32], *bech32_address.hash());

        // Convert to Address
        let _plain_address: Address = bech32_address.into();

</code></pre>
<blockquote>
<p><strong>Note:</strong> when creating a <code>Bech32Address</code> from <code>Address</code> or <code>Bech32ContractId</code> from <code>ContractId</code> the <code>HRP</code> (Human-Readable Part) is set to <strong>&quot;fuel&quot;</strong> per default.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="structs-and-enums"><a class="header" href="#structs-and-enums">Structs and enums</a></h1>
<!-- This section should explain how to get the custom types from a Sway program -->
<!-- custom_types:example:start -->
<p>The structs and enums you define in your Sway code have equivalents automatically generated by the SDK's <code>abigen!</code> macro.</p>
<!-- custom_types:example:end -->
<p>For instance, if in your Sway code you have a struct called <code>CounterConfig</code> that looks like this:</p>
<pre><code class="language-rust ignore">struct CounterConfig {
  dummy: bool,
  initial_value: u64,
}
</code></pre>
<p>After using the <code>abigen!</code> macro, <code>CounterConfig</code> will be accessible in your Rust file! Here's an example:</p>
<pre><code class="language-rust ignore">    abigen!(Contract(name=&quot;MyContract&quot;,
                     abi=&quot;packages/fuels/tests/types/contracts/complex_types_contract/out/debug/complex_types_contract-abi.json&quot;));

    // Here we can use `CounterConfig`, a struct originally
    // defined in the contract.
    let counter_config = CounterConfig {
        dummy: true,
        initial_value: 42,
    };
</code></pre>
<p>You can freely use your custom types (structs or enums) within this scope. That also means passing custom types to functions and receiving custom types from function calls.</p>
<h2 id="generics"><a class="header" href="#generics">Generics</a></h2>
<p>The Fuel Rust SDK supports both generic enums and generic structs. If you're already familiar with Rust, it's your typical <code>struct MyStruct&lt;T&gt;</code> type of generics support.</p>
<p>For instance, your Sway contract could look like this:</p>
<pre><code class="language-Rust">contract;

use std::hash::sha256;

struct SimpleGeneric&lt;T&gt; {
    single_generic_param: T,
}

abi MyContract {
  fn struct_w_generic(arg1: SimpleGeneric&lt;u64&gt;) -&gt; SimpleGeneric&lt;u64&gt;;
}

impl MyContract for Contract {
    fn struct_w_generic(arg1: SimpleGeneric&lt;u64&gt;) -&gt; SimpleGeneric&lt;u64&gt; {
        let expected = SimpleGeneric {
            single_generic_param: 123u64,
        };

        assert(arg1.single_generic_param == expected.single_generic_param);

        expected
    }
}
</code></pre>
<p>Your Rust code would look like this:</p>
<pre><code class="language-rust ignore">        // simple struct with a single generic param
        let arg1 = SimpleGeneric {
            single_generic_param: 123u64,
        };

        let result = contract_methods
            .struct_w_generic(arg1.clone())
            .call()
            .await?
            .value;

        assert_eq!(result, arg1);
</code></pre>
<h3 id="unused-generic-type-parameters"><a class="header" href="#unused-generic-type-parameters">Unused generic type parameters</a></h3>
<p>Sway supports unused generic type parameters when declaring structs/enums:</p>
<pre><code class="language-Rust">struct SomeStruct&lt;T, K&gt; {
  field: u64
}

enum SomeEnum&lt;T, K&gt; {
  One: u64
}

</code></pre>
<p>If you tried the same in Rust you'd get complaints that <code>T</code> and <code>K</code> must be used or removed. When generating Rust bindings for such types we make use of the <a href="https://doc.rust-lang.org/std/marker/struct.PhantomData.html#unused-type-parameters"><code>PhantomData</code></a> type. The generated bindings for the above example would look something like this:</p>
<pre><code class="language-Rust">struct SomeStruct&lt;T, K&gt; {
   pub field: u64,
   pub _unused_generic_0: PhantomData&lt;T&gt;
   pub _unused_generic_1: PhantomData&lt;K&gt;
}

enum SomeEnum&lt;T, K&gt; {
  One(u64),
  IgnoreMe(PhantomData&lt;T&gt;, PhantomData&lt;K&gt;)
}
</code></pre>
<p>To lessen the impact to developer experience you may use <code>SomeStruct::new</code> to initialize the above structure without bothering with the <code>PhantomData</code>s:</p>
<pre><code class="language-rust ignore">        assert_eq!(
            &lt;MyStruct&lt;u16, u32&gt;&gt;::new(15),
            MyStruct {
                field: 15,
                _unused_generic_0: std::marker::PhantomData,
                _unused_generic_1: std::marker::PhantomData
            }
        );
</code></pre>
<p>If your struct doesn't have any fields we'll also derive <code>Default</code>. As for enums all <code>PhantomData</code>s are placed inside a new variant called <code>IgnoreMe</code> which you'll need to ignore in your matches:</p>
<pre><code class="language-rust ignore">        match my_enum {
            MyEnum::One(_value) =&gt; {}
            MyEnum::IgnoreMe(..) =&gt; panic!(&quot;Will never receive this variant&quot;),
        }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="string"><a class="header" href="#string"><code>String</code></a></h1>
<p>The Rust SDK represents Fuel's <code>String</code>s as <code>SizedAsciiString&lt;LEN&gt;</code>, where the generic parameter <code>LEN</code> is the length of a given string. This abstraction is necessary because all strings in Fuel and Sway are statically-sized, i.e., you must know the size of the string beforehand.</p>
<p>Here's how you can create a simple string using <code>SizedAsciiString</code>:</p>
<pre><code class="language-rust ignore">        let ascii_data = &quot;abc&quot;.to_string();

        SizedAsciiString::&lt;3&gt;::new(ascii_data)
            .expect(&quot;should have succeeded since we gave ascii data of correct length!&quot;);
</code></pre>
<p>To make working with <code>SizedAsciiString</code>s easier, you can use <code>try_into()</code> to convert from Rust's <code>String</code> to <code>SizedAsciiString</code>, and you can use <code>into()</code> to convert from <code>SizedAsciiString</code> to Rust's <code>String</code>. Here are a few examples:</p>
<pre><code class="language-rust ignore">    #[test]
    fn can_be_constructed_from_str_ref() {
        let _: SizedAsciiString&lt;3&gt; = &quot;abc&quot;.try_into().expect(&quot;should have succeeded&quot;);
    }

    #[test]
    fn can_be_constructed_from_string() {
        let _: SizedAsciiString&lt;3&gt; = &quot;abc&quot;.to_string().try_into().expect(&quot;should have succeeded&quot;);
    }

    #[test]
    fn can_be_converted_into_string() {
        let sized_str = SizedAsciiString::&lt;3&gt;::new(&quot;abc&quot;.to_string()).unwrap();

        let str: String = sized_str.into();

        assert_eq!(str, &quot;abc&quot;);
    }
</code></pre>
<p>If your contract's method takes and returns, for instance, a Sway's <code>str[23]</code>. When using the SDK, this method will take and return a <code>SizedAsciiString&lt;23&gt;</code>, and you can pass a string to it like this:</p>
<pre><code class="language-rust ignore">    let call_handler = contract_instance.methods().takes_string(
        &quot;This is a full sentence&quot;
            .try_into()
            .expect(&quot;failed to convert string into SizedAsciiString&quot;),
    );
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bits256"><a class="header" href="#bits256"><code>Bits256</code></a></h1>
<p>In Fuel, a type called <code>b256</code> represents hashes and holds a 256-bit value. The Rust SDK represents <code>b256</code> as <code>Bits256(value)</code> where <code>value</code> is a <code>[u8; 32]</code>. If your contract method takes a <code>b256</code> as input, you must pass a <code>Bits256([u8; 32])</code> when calling it from the SDK.</p>
<p>Here's an example:</p>
<pre><code class="language-rust ignore">    let arg: [u8; 32] = hasher.finalize().into();

    let call_handler = contract_instance.methods().takes_b256(Bits256(arg));
</code></pre>
<p>If you have a hexadecimal value as a string and wish to convert it to <code>Bits256</code>, you may do so with <code>from_hex_str</code>:</p>
<pre><code class="language-rust ignore">        let hex_str = &quot;0101010101010101010101010101010101010101010101010101010101010101&quot;;

        let bits256 = Bits256::from_hex_str(hex_str)?;

        assert_eq!(bits256.0, [1u8; 32]);

        // With the `0x0` prefix
        let hex_str = &quot;0x0101010101010101010101010101010101010101010101010101010101010101&quot;;

        let bits256 = Bits256::from_hex_str(hex_str)?;

        assert_eq!(bits256.0, [1u8; 32]);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bytes"><a class="header" href="#bytes"><code>Bytes</code></a></h1>
<p>In Fuel, a type called <code>Bytes</code> represents a collection of tightly-packed bytes. The Rust SDK represents <code>Bytes</code> as <code>Bytes(Vec&lt;u8&gt;)</code>. Here's an example of using <code>Bytes</code> in a contract call:</p>
<pre><code class="language-rust ignore">        let bytes = Bytes(vec![40, 41, 42]);

        contract_methods.accept_bytes(bytes).call().await?;
</code></pre>
<p>If you have a hexadecimal value as a string and wish to convert it to <code>Bytes</code>, you may do so with <code>from_hex_str</code>:</p>
<pre><code class="language-rust ignore">        let hex_str = &quot;0101010101010101010101010101010101010101010101010101010101010101&quot;;

        let bytes = Bytes::from_hex_str(hex_str)?;

        assert_eq!(bytes.0, vec![1u8; 32]);

        // With the `0x0` prefix
        let hex_str = &quot;0x0101010101010101010101010101010101010101010101010101010101010101&quot;;

        let bytes = Bytes::from_hex_str(hex_str)?;

        assert_eq!(bytes.0, vec![1u8; 32]);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="b512"><a class="header" href="#b512"><code>B512</code></a></h1>
<p>In the Rust SDK, the <code>B512</code> definition matches the Sway standard library type with the same name and will be converted accordingly when interacting with contracts:</p>
<pre><code class="language-rust ignore">pub struct B512 {
    pub bytes: [Bits256; 2],
}
</code></pre>
<p>Here's an example:</p>
<pre><code class="language-rust ignore">    let hi_bits = Bits256::from_hex_str(
        &quot;0xbd0c9b8792876713afa8bff383eebf31c43437823ed761cc3600d0016de5110c&quot;,
    )?;
    let lo_bits = Bits256::from_hex_str(
        &quot;0x44ac566bd156b4fc71a4a4cb2655d3dd360c695edb17dc3b64d611e122fea23d&quot;,
    )?;
    let b512 = B512::from((hi_bits, lo_bits));
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="evmaddress"><a class="header" href="#evmaddress"><code>EvmAddress</code></a></h1>
<p>In the Rust SDK, Ethereum Virtual Machine (EVM) addresses can be represented with the <code>EvmAddress</code> type. Its definition matches with the Sway standard library type with the same name and will be converted accordingly when interacting with contracts:</p>
<pre><code class="language-rust ignore">pub struct EvmAddress {
    // An evm address is only 20 bytes, the first 12 bytes should be set to 0
    value: Bits256,
}
</code></pre>
<p>Here's an example:</p>
<pre><code class="language-rust ignore">    let b256 = Bits256(hasher.finalize().into());
    let arg = EvmAddress::from(b256);

    let call_handler = contract_instance.methods().takes_evm_address(arg);
</code></pre>
<blockquote>
<p><strong>Note:</strong> when creating an <code>EvmAddress</code> from <code>Bits256</code>, the first 12 bytes will be cleared because an EVM address is only 20 bytes long.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vectors"><a class="header" href="#vectors">Vectors</a></h1>
<h2 id="passing-in-vectors"><a class="header" href="#passing-in-vectors">Passing in vectors</a></h2>
<p>You can pass a Rust <code>std::vec::Vec</code> into your contract method transparently. The following code calls a Sway contract method which accepts a <code>Vec&lt;SomeStruct&lt;u32&gt;&gt;</code>.</p>
<pre><code class="language-rust ignore">        let arg = vec![SomeStruct { a: 0 }, SomeStruct { a: 1 }];
        methods.struct_in_vec(arg.clone()).call().await?;
</code></pre>
<p>You can use a vector just like you would use any other type -- e.g. a <code>[Vec&lt;u32&gt;; 2]</code> or a <code>SomeStruct&lt;Vec&lt;Bits256&gt;&gt;</code> etc.</p>
<h2 id="returning-vectors"><a class="header" href="#returning-vectors">Returning vectors</a></h2>
<p>Returning vectors from contract methods is supported transparently, with the caveat that you cannot have them nested inside another type. This limitation is temporary.</p>
<pre><code class="language-rust ignore">    let response = contract_methods.u8_in_vec(10).call().await?;
    assert_eq!(response.value, (0..10).collect::&lt;Vec&lt;_&gt;&gt;());
</code></pre>
<blockquote>
<p><strong>Note: you can still interact with contracts containing methods that return vectors nested inside another type, just not interact with the methods themselves</strong></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="converting-types"><a class="header" href="#converting-types">Converting Types</a></h1>
<p>Below you can find examples for common type conversions:</p>
<ul>
<li><a href="types/conversion.html#convert-between-native-types">Convert Between Native Types</a></li>
<li><a href="types/conversion.html#convert-to-bytes32">Convert to <code>Bytes32</code></a></li>
<li><a href="types/conversion.html#convert-to-address">Convert to <code>Address</code></a></li>
<li><a href="types/conversion.html#convert-to-contractid">Convert to <code>ContractId</code></a></li>
<li><a href="types/conversion.html#convert-to-identity">Convert to <code>Identity</code></a></li>
<li><a href="types/conversion.html#convert-to-assetid">Convert to <code>AssetId</code></a></li>
<li><a href="types/conversion.html#convert-to-bech32">Convert to <code>Bech32</code></a></li>
<li><a href="types/conversion.html#convert-to-str">Convert to <code>str</code></a></li>
<li><a href="types/conversion.html#convert-to-bits256">Convert to <code>Bits256</code></a></li>
<li><a href="types/conversion.html#convert-to-bytes">Convert to <code>Bytes</code></a></li>
<li><a href="types/conversion.html#convert-to-b512">Convert to <code>B512</code></a></li>
<li><a href="types/conversion.html#convert-to-evmaddress">Convert to <code>EvmAddress</code></a></li>
</ul>
<h2 id="convert-between-native-types"><a class="header" href="#convert-between-native-types">Convert Between Native Types</a></h2>
<p>You might want to convert between the native types (<code>Bytes32</code>, <code>Address</code>, <code>ContractId</code>, and <code>AssetId</code>). Because these types are wrappers on <code>[u8; 32]</code>, converting is a matter of dereferencing one and instantiating the other using the dereferenced value. Here's an example:</p>
<pre><code class="language-rust ignore">        use fuels::types::{AssetId, ContractId};

        let contract_id = ContractId::new([1u8; 32]);

        let asset_id: AssetId = AssetId::new(*contract_id);

        assert_eq!([1u8; 32], *asset_id);
</code></pre>
<h2 id="convert-to-bytes32"><a class="header" href="#convert-to-bytes32">Convert to <code>Bytes32</code></a></h2>
<p>Convert a <code>[u8; 32]</code> array to <code>Bytes32</code>:</p>
<pre><code class="language-rust ignore">        let my_slice = [1u8; 32];
        let b256 = Bytes32::new(my_slice);
</code></pre>
<p>Convert a hex string to <code>Bytes32</code>:</p>
<pre><code class="language-rust ignore">        let hex_str = &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;;
        let b256 = Bytes32::from_str(hex_str)?;
</code></pre>
<h2 id="convert-to-address"><a class="header" href="#convert-to-address">Convert to <code>Address</code></a></h2>
<p>Convert a <code>[u8; 32]</code> array to an <code>Address</code>:</p>
<pre><code class="language-rust ignore">        let my_slice = [1u8; 32];
        let address = Address::new(my_slice);
</code></pre>
<p>Convert a <code>Bech32</code> address to an <code>Address</code>:</p>
<pre><code class="language-rust ignore">        let _plain_address: Address = bech32_address.into();
</code></pre>
<p>Convert a wallet to an <code>Address</code>:</p>
<pre><code class="language-rust ignore">        let wallet_unlocked = WalletUnlocked::new_random(None);
        let address: Address = wallet_unlocked.address().into();
</code></pre>
<p>Convert a hex string to an <code>Address</code>:</p>
<pre><code class="language-rust ignore">        let hex_str = &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;;
        let address = Address::from_str(hex_str)?;
</code></pre>
<h2 id="convert-to-contractid"><a class="header" href="#convert-to-contractid">Convert to <code>ContractId</code></a></h2>
<p>Convert a <code>[u8; 32]</code> array to to <code>ContractId</code>:</p>
<pre><code class="language-rust ignore">        let my_slice = [1u8; 32];
        let contract_id = ContractId::new(my_slice);
</code></pre>
<p>Convert a hex string to a <code>ContractId</code>:</p>
<pre><code class="language-rust ignore">        let hex_str = &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;;
        let contract_id = ContractId::from_str(hex_str)?;
</code></pre>
<p>Convert a contract instance to a <code>ContractId</code>:</p>
<pre><code class="language-rust ignore">    let contract_id: ContractId = contract_instance.id().into();
</code></pre>
<h2 id="convert-to-identity"><a class="header" href="#convert-to-identity">Convert to <code>Identity</code></a></h2>
<p>Convert an <code>Address</code> to an <code>Identity</code>:</p>
<pre><code class="language-rust ignore">        let _identity_from_address = Identity::Address(address);
</code></pre>
<p>Convert a <code>ContractId</code> to an <code>Identity</code>:</p>
<pre><code class="language-rust ignore">        let _identity_from_contract_id = Identity::ContractId(contract_id);
</code></pre>
<h2 id="convert-to-assetid"><a class="header" href="#convert-to-assetid">Convert to <code>AssetId</code></a></h2>
<p>Convert a <code>[u8; 32]</code> array to an <code>AssetId</code>:</p>
<pre><code class="language-rust ignore">        let my_slice = [1u8; 32];
        let asset_id = AssetId::new(my_slice);
</code></pre>
<p>Convert a hex string to an <code>AssetId</code>:</p>
<pre><code class="language-rust ignore">        let hex_str = &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;;
        let asset_id = AssetId::from_str(hex_str)?;
</code></pre>
<h2 id="convert-to-bech32"><a class="header" href="#convert-to-bech32">Convert to <code>Bech32</code></a></h2>
<p>Convert a <code>[u8; 32]</code> array to a <code>Bech32</code> address:</p>
<pre><code class="language-rust ignore">        let hrp = &quot;fuel&quot;;
        let my_slice = [1u8; 32];
        let _bech32_address = Bech32Address::new(hrp, my_slice);
</code></pre>
<p>Convert <code>Bytes32</code> to a <code>Bech32</code> address:</p>
<pre><code class="language-rust ignore">        let my_hash = Bytes32::new([1u8; 32]);
        let _bech32_address = Bech32Address::new(hrp, my_hash);
</code></pre>
<p>Convert a string to a <code>Bech32</code> address:</p>
<pre><code class="language-rust ignore">        let address = &quot;fuel1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqsx2mt2&quot;;
        let bech32_address = Bech32Address::from_str(address)?;
</code></pre>
<p>Convert an <code>Address</code> to a <code>Bech32</code> address:</p>
<pre><code class="language-rust ignore">        let plain_address = Address::new([0u8; 32]);
        let bech32_address = Bech32Address::from(plain_address);
</code></pre>
<h2 id="convert-to-str"><a class="header" href="#convert-to-str">Convert to <code>str</code></a></h2>
<p>Convert a <code>ContractId</code> to a <code>str</code>:</p>
<pre><code class="language-rust ignore">        let _str_from_contract_id: &amp;str = contract_id.to_string().as_str();
</code></pre>
<p>Convert an <code>Address</code> to a <code>str</code>:</p>
<pre><code class="language-rust ignore">        let _str_from_address: &amp;str = address.to_string().as_str();
</code></pre>
<p>Convert an <code>AssetId</code> to a <code>str</code>:</p>
<pre><code class="language-rust ignore">        let _str_from_asset_id: &amp;str = asset_id.to_string().as_str();
</code></pre>
<p>Convert <code>Bytes32</code> to a <code>str</code>:</p>
<pre><code class="language-rust ignore">        let _str_from_bytes32: &amp;str = b256.to_string().as_str();
</code></pre>
<h2 id="convert-to-bits256"><a class="header" href="#convert-to-bits256">Convert to <code>Bits256</code></a></h2>
<p>Convert a hex string to <code>Bits256</code>:</p>
<pre><code class="language-rust ignore">        let hex_str = &quot;0x0101010101010101010101010101010101010101010101010101010101010101&quot;;

        let bits256 = Bits256::from_hex_str(hex_str)?;
</code></pre>
<p>Convert a <code>ContractId</code> to <code>Bits256</code>:</p>
<pre><code class="language-rust ignore">        let _contract_id_to_bits_256 = Bits256(contract_id.into());
</code></pre>
<p>Convert an <code>Address</code> to <code>Bits256</code>:</p>
<pre><code class="language-rust ignore">        let bits_256 = Bits256(address.into());
</code></pre>
<p>Convert an <code>AssetId</code> to <code>Bits256</code>:</p>
<pre><code class="language-rust ignore">        let _asset_id_to_bits_256 = Bits256(asset_id.into());
</code></pre>
<h2 id="convert-to-bytes"><a class="header" href="#convert-to-bytes">Convert to <code>Bytes</code></a></h2>
<p>Convert a string to <code>Bytes</code>:</p>
<pre><code class="language-rust ignore">        let hex_str = &quot;0x0101010101010101010101010101010101010101010101010101010101010101&quot;;

        let bytes = Bytes::from_hex_str(hex_str)?;
</code></pre>
<h2 id="convert-to-b512"><a class="header" href="#convert-to-b512">Convert to <code>B512</code></a></h2>
<p>Convert two hex strings to <code>B512</code>:</p>
<pre><code class="language-rust ignore">    let hi_bits = Bits256::from_hex_str(
        &quot;0xbd0c9b8792876713afa8bff383eebf31c43437823ed761cc3600d0016de5110c&quot;,
    )?;
    let lo_bits = Bits256::from_hex_str(
        &quot;0x44ac566bd156b4fc71a4a4cb2655d3dd360c695edb17dc3b64d611e122fea23d&quot;,
    )?;
    let b512 = B512::from((hi_bits, lo_bits));
</code></pre>
<h2 id="convert-to-evmaddress"><a class="header" href="#convert-to-evmaddress">Convert to <code>EvmAddress</code></a></h2>
<p>Convert a <code>Bits256</code> address to an <code>EvmAddress</code>:</p>
<pre><code class="language-rust ignore">        let _evm_address = EvmAddress::from(bits_256);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="codec"><a class="header" href="#codec">Codec</a></h1>
<p>Encoding and decoding are done as per <a href="https://specs.fuel.network/master/abi/argument-encoding.html">the fuel spec</a>. To this end, <code>fuels</code> makes use of the <a href="https://docs.rs/fuels/latest/fuels/core/codec/struct.ABIEncoder.html"><code>ABIEncoder</code></a> and the <a href="https://docs.rs/fuels/latest/fuels/core/codec/struct.ABIDecoder.html"><code>ABIDecoder</code></a>.</p>
<h2 id="prerequisites-for-decodingencoding"><a class="header" href="#prerequisites-for-decodingencoding">Prerequisites for decoding/encoding</a></h2>
<p>To encode a type, you must first convert it into a <a href="https://docs.rs/fuels/latest/fuels/types/enum.Token.html"><code>Token</code></a>. This is commonly done by implementing the <a href="https://docs.rs/fuels/latest/fuels/core/traits/trait.Tokenizable.html"><code>Tokenizable</code></a> trait.</p>
<p>To decode, you also need to provide a <a href="https://docs.rs/fuels/latest/fuels/types/param_types/enum.ParamType.html"><code>ParamType</code></a> describing the schema of the type in question. This is commonly done by implementing the <a href="https://docs.rs/fuels/latest/fuels/core/traits/trait.Parameterize.html">Parameterize</a> trait.</p>
<p>All types generated by the <a href="codec/../abigen/index.html"><code>abigen!</code></a> macro implement both the <a href="https://docs.rs/fuels/latest/fuels/core/traits/trait.Tokenizable.html"><code>Tokenizable</code></a> and <a href="https://docs.rs/fuels/latest/fuels/core/traits/trait.Parameterize.html"><code>Parameterize</code></a> traits.</p>
<p><code>fuels</code> also contains implementations for:</p>
<ul>
<li><a href="https://docs.rs/fuels/latest/fuels/core/traits/trait.Tokenizable.html"><code>Tokenizable</code></a> for the <code>fuels</code>-owned types listed <a href="https://docs.rs/fuels/latest/fuels/core/traits/trait.Tokenizable.html#implementors">here</a> as well as <a href="https://docs.rs/fuels/latest/fuels/core/traits/trait.Tokenizable.html#foreign-impls">for some foreign types</a> (such as <code>u8</code>, <code>u16</code>, <code>std::vec::Vec&lt;T: Tokenizable&gt;</code>, etc.).</li>
<li><a href="https://docs.rs/fuels/latest/fuels/core/traits/trait.Parameterize.html"><code>Parameterize</code></a> for the <code>fuels</code>-owned types listed <a href="https://docs.rs/fuels/latest/fuels/core/traits/trait.Parameterize.html#implementors">here</a> as well as <a href="https://docs.rs/fuels/latest/fuels/core/traits/trait.Parameterize.html#foreign-impls">for some foreign types</a> (such as <code>u8</code>, <code>u16</code>, <code>std::vec::Vec&lt;T: Parameterize&gt;</code>, etc.).</li>
</ul>
<h2 id="deriving-the-traits"><a class="header" href="#deriving-the-traits">Deriving the traits</a></h2>
<p>Both <a href="https://docs.rs/fuels/latest/fuels/core/traits/trait.Tokenizable.html"><code>Tokenizable</code></a> and <a href="https://docs.rs/fuels/latest/fuels/core/traits/trait.Parameterize.html"><code>Parameterize</code></a> can be derived for <code>struct</code>s and <code>enum</code>s if all inner types implement the derived traits:</p>
<pre><code class="language-rust ignore">        use fuels::macros::{Parameterize, Tokenizable};

        #[derive(Parameterize, Tokenizable)]
        struct MyStruct {
            field_a: u8,
        }

        #[derive(Parameterize, Tokenizable)]
        enum SomeEnum {
            A(MyStruct),
            B(Vec&lt;u64&gt;),
        }
</code></pre>
<blockquote>
<p>Note:
Deriving <a href="https://docs.rs/fuels/latest/fuels/core/traits/trait.Tokenizable.html"><code>Tokenizable</code></a> on <code>enum</code>s requires that all variants also implement <a href="https://docs.rs/fuels/latest/fuels/core/traits/trait.Parameterize.html"><code>Parameterize</code></a>.</p>
</blockquote>
<h3 id="tweaking-the-derivation"><a class="header" href="#tweaking-the-derivation">Tweaking the derivation</a></h3>
<h4 id="changing-the-location-of-imports"><a class="header" href="#changing-the-location-of-imports">Changing the location of imports</a></h4>
<p>The derived code expects that the <code>fuels</code> package is accessible through <code>::fuels</code>. If this is not the case then the derivation macro needs to be given the locations of <code>fuels::types</code> and <code>fuels::core</code>.</p>
<pre><code class="language-rust ignore">            #[derive(Parameterize, Tokenizable)]
            #[FuelsCorePath = &quot;fuels_core_elsewhere&quot;]
            #[FuelsTypesPath = &quot;fuels_types_elsewhere&quot;]
            pub struct SomeStruct {
                field_a: u64,
            }
</code></pre>
<h4 id="generating-no-std-code"><a class="header" href="#generating-no-std-code">Generating no-std code</a></h4>
<p>If you want <code>no-std</code> generated code:</p>
<pre><code class="language-rust ignore">            use fuels::macros::{Parameterize, Tokenizable};
            #[derive(Parameterize, Tokenizable)]
            #[NoStd]
            pub struct SomeStruct {
                field_a: u64,
            }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="encoding"><a class="header" href="#encoding">Encoding</a></h1>
<p>Be sure to read the <a href="codec/./index.html#prerequisites-for-decodingencoding">prerequisites</a> to encoding.</p>
<p>Encoding is done via the <a href="https://docs.rs/fuels/latest/fuels/core/codec/struct.ABIEncoder.html"><code>ABIEncoder</code></a>:</p>
<pre><code class="language-rust ignore">        use fuels::{
            core::{codec::ABIEncoder, traits::Tokenizable},
            macros::Tokenizable,
            types::unresolved_bytes::UnresolvedBytes,
        };

        #[derive(Tokenizable)]
        struct MyStruct {
            field: u64,
        }

        let instance = MyStruct { field: 101 };
        let encoded: UnresolvedBytes = ABIEncoder::default().encode(&amp;[instance.into_token()])?;
        let load_memory_address: u64 = 0x100;
        let _: Vec&lt;u8&gt; = encoded.resolve(load_memory_address);
</code></pre>
<p>Note that the return type of <code>encode</code> is <code>UnresolvedBytes</code>. The encoding cannot be finished until we know at which memory address this data is to be loaded. If you don't use heap types (<code>::std::vec::Vec</code>, <code>::fuels::types::Bytes</code>, <code>::std::string::String</code>), then you can safely <code>.resolve(0)</code> to get the encoded bytes.</p>
<p>There is also a shortcut-macro that can encode multiple types which implement <a href="https://docs.rs/fuels/latest/fuels/core/traits/trait.Tokenizable.html"><code>Tokenizable</code></a>:</p>
<pre><code class="language-rust ignore">        use fuels::{core::codec::calldata, macros::Tokenizable};

        #[derive(Tokenizable)]
        struct MyStruct {
            field: u64,
        }
        let _: Vec&lt;u8&gt; = calldata!(MyStruct { field: 101 }, MyStruct { field: 102 })?;
</code></pre>
<blockquote>
<p>Note:
The above example will call <code>.resolve(0)</code>. Don't use it if you're encoding heap types.</p>
</blockquote>
<h2 id="configuring-the-encoder"><a class="header" href="#configuring-the-encoder">Configuring the encoder</a></h2>
<p>The encoder can be configured to limit its resource expenditure:</p>
<pre><code class="language-rust ignore">        use fuels::core::codec::ABIEncoder;

        ABIEncoder::new(EncoderConfig {
            max_depth: 5,
            max_tokens: 100,
            max_total_enum_width: 10_000,
        });
</code></pre>
<p>The default values for the <code>EncoderConfig</code> are:</p>
<pre><code class="language-rust ignore">impl Default for EncoderConfig {
    fn default() -&gt; Self {
        Self {
            max_depth: 45,
            max_tokens: 10_000,
            max_total_enum_width: 10_000,
        }
    }
}
</code></pre>
<h2 id="configuring-the-encoder-for-contractscript-calls"><a class="header" href="#configuring-the-encoder-for-contractscript-calls">Configuring the encoder for contract/script calls</a></h2>
<p>You can also configure the encoder used to encode the arguments of the contract method:</p>
<pre><code class="language-rust ignore">        let _ = contract_instance
            .with_encoder_config(EncoderConfig {
                max_depth: 10,
                max_tokens: 2_000,
                max_total_enum_width: 10_000,
            })
            .methods()
            .initialize_counter(42)
            .call()
            .await?;
</code></pre>
<p>The same method is available for script calls.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="decoding"><a class="header" href="#decoding">Decoding</a></h1>
<p>Be sure to read the <a href="codec/./index.html#prerequisites-for-decodingencoding">prerequisites</a> to decoding.</p>
<p>Decoding is done via the <a href="https://docs.rs/fuels/latest/fuels/core/codec/struct.ABIDecoder.html"><code>ABIDecoder</code></a>:</p>
<pre><code class="language-rust ignore">        use fuels::{
            core::{
                codec::ABIDecoder,
                traits::{Parameterize, Tokenizable},
            },
            macros::{Parameterize, Tokenizable},
            types::Token,
        };

        #[derive(Parameterize, Tokenizable)]
        struct MyStruct {
            field: u64,
        }

        let bytes: &amp;[u8] = &amp;[0, 0, 0, 0, 0, 0, 0, 101];

        let token: Token = ABIDecoder::default().decode(&amp;MyStruct::param_type(), bytes)?;

        let _: MyStruct = MyStruct::from_token(token)?;
</code></pre>
<p>First into a <a href="https://docs.rs/fuels/latest/fuels/types/enum.Token.html"><code>Token</code></a>, then via the <a href="https://docs.rs/fuels/latest/fuels/core/traits/trait.Tokenizable.html"><code>Tokenizable</code></a> trait, into the desired type.</p>
<p>If the type came from <a href="codec/../abigen/index.html"><code>abigen!</code></a> (or uses the <a href="https://docs.rs/fuels/latest/fuels/macros/derive.TryFrom.html"><code>::fuels::macros::TryFrom</code></a> derivation) then you can also use <code>try_into</code> to convert bytes into a type that implements both <a href="https://docs.rs/fuels/latest/fuels/core/traits/trait.Parameterize.html"><code>Parameterize</code></a> and <a href="https://docs.rs/fuels/latest/fuels/core/traits/trait.Tokenizable.html"><code>Tokenizable</code></a>:</p>
<pre><code class="language-rust ignore">        use fuels::macros::{Parameterize, Tokenizable, TryFrom};

        #[derive(Parameterize, Tokenizable, TryFrom)]
        struct MyStruct {
            field: u64,
        }

        let bytes: &amp;[u8] = &amp;[0, 0, 0, 0, 0, 0, 0, 101];

        let _: MyStruct = bytes.try_into()?;
</code></pre>
<p>Under the hood, <a href="https://docs.rs/fuels/latest/fuels/core/codec/fn.try_from_bytes.html"><code>try_from_bytes</code></a> is being called, which does what the preceding example did.</p>
<h2 id="configuring-the-decoder"><a class="header" href="#configuring-the-decoder">Configuring the decoder</a></h2>
<p>The decoder can be configured to limit its resource expenditure:</p>
<pre><code class="language-rust ignore">
        use fuels::core::codec::ABIDecoder;

        ABIDecoder::new(DecoderConfig {
            max_depth: 5,
            max_tokens: 100,
        });
</code></pre>
<!-- TODO: Add a link once a release is made -->
<!-- https://docs.rs/fuels/latest/fuels/core/codec/struct.DecoderConfig.html -->
<p>For an explanation of each configuration value visit the <code>DecoderConfig</code>.</p>
<!-- TODO: add a link once a release is made -->
<!-- https://docs.rs/fuels/latest/fuels/core/codec/struct.DecoderConfig.html -->
<p>The default values for the <code>DecoderConfig</code> are:</p>
<pre><code class="language-rust ignore">impl Default for DecoderConfig {
    fn default() -&gt; Self {
        Self {
            max_depth: 45,
            max_tokens: 10_000,
        }
    }
}
</code></pre>
<h2 id="configuring-the-decoder-for-contractscript-calls"><a class="header" href="#configuring-the-decoder-for-contractscript-calls">Configuring the decoder for contract/script calls</a></h2>
<p>You can also configure the decoder used to decode the return value of the contract method:</p>
<pre><code class="language-rust ignore">        let _ = contract_instance
            .methods()
            .initialize_counter(42)
            .with_decoder_config(DecoderConfig {
                max_depth: 10,
                max_tokens: 2_000,
            })
            .call()
            .await?;
</code></pre>
<p>The same method is available for script calls.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="api-reference"><a class="header" href="#api-reference">API Reference</a></h1>
<p>For a more in-depth look at the APIs provided by the Fuel Rust SDK, head over to the <a href="https://docs.rs/fuels/latest/fuels/">official documentation</a>. In the actual Rust docs, you can see the most up-to-date information about the API, which is synced with the code as it changes.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fuels-rs-testing"><a class="header" href="#fuels-rs-testing"><code>fuels-rs</code> Testing</a></h1>
<blockquote>
<p><strong>note</strong> This section is still a work in progress.</p>
</blockquote>
<ul>
<li><a href="testing/./basics.html">Testing Basics</a></li>
<li><a href="testing/./the-setup-program-test-macro.html"><code>setup_program_test!</code> Macro</a></li>
<li><a href="testing/./chains.html">Tweaking the Blockchain</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing-basics"><a class="header" href="#testing-basics">Testing Basics</a></h1>
<p>If you're new to Rust, you'll want to review these important tools to help you build tests.</p>
<h2 id="the-assert-macro"><a class="header" href="#the-assert-macro">The <code>assert!</code> macro</a></h2>
<!-- This section should explain the `assert!` macro -->
<!-- assert:example:start -->
<p>You can use the <code>assert!</code> macro to assert certain conditions in your test. This macro invokes <code>panic!()</code> and fails the test if the expression inside evaluates to <code>false</code>.</p>
<!-- assert:example:end -->
<!-- This section should show an example of the `assert!` macro -->
<!-- assert_code:example:start -->
<pre><code class="language-rust  ignore">assert!(value == 5);
</code></pre>
<!-- assert_code:example:end -->
<h2 id="the-assert_eq-macro"><a class="header" href="#the-assert_eq-macro">The <code>assert_eq!</code> macro</a></h2>
<!-- This section should show an example of the `assert_eq!` macro -->
<!-- assert_eq:example:start -->
<p>The <code>assert_eq!</code> macro works a lot like the <code>assert</code> macro, however instead it accepts two values, and panics if those values are not equal.</p>
<!-- assert_eq:example:end -->
<!-- This section should show an example of the `assert_eq!` macro -->
<!-- assert_eq_code:example:start -->
<pre><code class="language-rust  ignore">assert_eq!(balance, 100);
</code></pre>
<!-- assert_eq_code:example:end -->
<h2 id="the-assert_ne-macro"><a class="header" href="#the-assert_ne-macro">The <code>assert_ne!</code> macro</a></h2>
<!-- This section should show an example of the `assert_ne!` macro -->
<!-- assert_ne:example:start -->
<p>The <code>assert_ne!</code> macro works just like the <code>assert_eq!</code> macro, but it will panic if the two values are equal.</p>
<!-- assert_ne:example:end -->
<!-- This section should show an example of the `assert_ne!` macro -->
<!-- assert_ne_code:example:start -->
<pre><code class="language-rust  ignore">assert_ne!(address, 0);
</code></pre>
<!-- assert_ne_code:example:end -->
<h2 id="the-println-macro"><a class="header" href="#the-println-macro">The <code>println!</code> macro</a></h2>
<!-- This section should explain how the `println!` macro can be used in tests -->
<!--print_ln:example:start -->
<p>You can use the <code>println!</code> macro to print values to the console.</p>
<!--print_ln:example:end -->
<!-- This section should show an example of the `println!` macro -->
<!--print_ln_code:example:start -->
<pre><code class="language-rust  ignore">println!(&quot;WALLET 1 ADDRESS {}&quot;, wallet_1.address());
println!(&quot;WALLET 1 ADDRESS {:?}&quot;, wallet_1.address());
</code></pre>
<!--print_ln_code:example:end -->
<!-- This section should explain how `{}` and `{:?}` are used in the `println!` macro -->
<!--print_ln_2:example:start -->
<p>Using <code>{}</code> will print the value, and using <code>{:?}</code> will print the value plus its type.</p>
<p>Using <code>{:?}</code> will also allow you to print values that do not have the <code>Display</code> trait implemented but do have the <code>Debug</code> trait. Alternatively you can use the <code>dbg!</code> macro to print these types of variables.</p>
<!--print_ln_2:example:end -->
<!-- This section should show an example of the `println!` and `dbg` macros -->
<!--print_ln_dbg_code:example:start -->
<pre><code class="language-rust  ignore">println!(&quot;WALLET 1 PROVIDER {:?}&quot;, wallet_1.provider().unwrap());
dbg!(&quot;WALLET 1 PROVIDER {}&quot;, wallet_1.provider().unwrap());
</code></pre>
<!--print_ln_dbg_code:example:end -->
<!-- This section should explain how implement custom fmt -->
<!--fmt:example:start -->
<p>To print more complex types that don't have it already, you can implement your own formatted display method with the <code>fmt</code> module from the Rust standard library.</p>
<!--fmt:example:end -->
<!-- This section should show a code example of how implement custom fmt -->
<!--fmt_code:example:start -->
<pre><code class="language-rust  ignore">use std::fmt;

struct Point {
    x: u64,
    y: u64,
}

// add print functionality with the fmt module 
impl fmt::Display for Point {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;value of x: {}, value of y: {}&quot;, self.x, self.y)
    }
}

let p = Point {x: 1, y: 2};
println!(&quot;POINT: {}&quot;, p);
</code></pre>
<!--fmt_code:example:end -->
<h2 id="run-commands"><a class="header" href="#run-commands">Run Commands</a></h2>
<p>You can run your tests to see if they pass or fail with</p>
<pre><code class="language-shell">cargo test
</code></pre>
<!-- This section should when outputs are hidden and what the `nocapture` flag does -->
<!--outputs:example:start -->
<p>Outputs will be hidden if the test passes. If you want to see outputs printed from your tests regardless of whether they pass or fail, use the <code>nocapture</code> flag.</p>
<!--outputs:example:end -->
<pre><code class="language-shell">cargo test -- --nocapture
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-setup_program_test-macro"><a class="header" href="#the-setup_program_test-macro">The setup_program_test! macro</a></h1>
<p>When deploying contracts with the <code>abigen!</code> macro, as shown in the previous sections, the user can:</p>
<ul>
<li>change the default configuration parameters</li>
<li>launch several providers</li>
<li>create multiple wallets</li>
<li>create specific assets, etc.</li>
</ul>
<p>However, it is often the case that we want to quickly set up a test with default values and work directly with contract or script instances. The <code>setup_program_test!</code> can do exactly that.</p>
<hr />
<p>Used to reduce boilerplate in integration tests. Accepts input in the form
of <code>COMMAND(ARG...)...</code></p>
<p><code>COMMAND</code> is either <code>Wallets</code>, <code>Abigen</code>, <code>LoadScript</code> or <code>Deploy</code>.</p>
<p><code>ARG</code> is either a:</p>
<ul>
<li>name-value (e.g. <code>name=&quot;MyContract&quot;</code>), or,</li>
<li>a literal (e.g. <code>&quot;some_str_literal&quot;</code>, <code>true</code>, <code>5</code>, ...)</li>
<li>a sub-command (e.g. <code>Abigen(Contract(name=&quot;MyContract&quot;, project=&quot;some_project&quot;))</code>)</li>
</ul>
<p>Available <code>COMMAND</code>s:</p>
<h2 id="wallets"><a class="header" href="#wallets">Wallets</a></h2>
<p>Example: <code>Wallets(&quot;a_wallet&quot;, &quot;another_wallet&quot;...)</code></p>
<p>Description: Launches a local provider and generates wallets with names taken from the provided <code>ARG</code>s.</p>
<p>Cardinality: 0 or 1.</p>
<h2 id="abigen-1"><a class="header" href="#abigen-1">Abigen</a></h2>
<p>Example:</p>
<pre><code class="language-rust ignore">Abigen(
    Contract(
        name = &quot;MyContract&quot;,
        project = &quot;some_folder&quot;
    ),
    Script(
        name = &quot;MyScript&quot;,
        project = &quot;some_folder&quot;
    ),
    Predicate(
        name = &quot;MyPredicate&quot;,
        project = &quot;some_folder&quot;
    ),
)
</code></pre>
<p>Description: Generates the program bindings under the name <code>name</code>. <code>project</code>
should point to root of the <code>forc</code> project.</p>
<p>Cardinality: 0 or N.</p>
<h2 id="deploy"><a class="header" href="#deploy">Deploy</a></h2>
<p>Example: <code>Deploy(name=&quot;instance_name&quot;, contract=&quot;MyContract&quot;, wallet=&quot;a_wallet&quot;)</code></p>
<p>Description: Deploys the <code>contract</code> (with salt) using <code>wallet</code>. Will create a contract instance accessible via <code>name</code>. Due to salt usage, the same contract can be deployed multiple times. Requires that an <code>Abigen</code> command be present with <code>name</code> equal to <code>contract</code>. <code>wallet</code> can either be one of the wallets in the <code>Wallets</code> <code>COMMAND</code> or the name of a wallet you've previously generated yourself.</p>
<p>Cardinality: 0 or N.</p>
<h2 id="loadscript"><a class="header" href="#loadscript"><code>LoadScript</code></a></h2>
<p>Example: <code>LoadScript(name = &quot;script_instance&quot;, script = &quot;MyScript&quot;, wallet = &quot;wallet&quot;)</code></p>
<p>Description: Creates a script instance of <code>script</code> under <code>name</code> using <code>wallet</code>.</p>
<p>Cardinality: 0 or N.</p>
<hr />
<p>The setup code that you have seen in previous sections gets reduced to:</p>
<pre><code class="language-rust ignore">        setup_program_test!(
            Wallets(&quot;wallet&quot;),
            Abigen(Contract(
                name = &quot;TestContract&quot;,
                project = &quot;packages/fuels/tests/contracts/contract_test&quot;
            )),
            Deploy(
                name = &quot;contract_instance&quot;,
                contract = &quot;TestContract&quot;,
                wallet = &quot;wallet&quot;
            ),
        );

        let response = contract_instance
            .methods()
            .initialize_counter(42)
            .call()
            .await?;

        assert_eq!(42, response.value);
</code></pre>
<blockquote>
<p><strong>Note</strong> The same contract can be deployed several times as the macro deploys the contracts with salt. You can also deploy different contracts to the same provider by referencing the same wallet in the <code>Deploy</code> command.</p>
</blockquote>
<pre><code class="language-rust ignore">    setup_program_test!(
        Wallets(&quot;wallet&quot;),
        Abigen(
            Contract(
                name = &quot;LibContract&quot;,
                project = &quot;packages/fuels/tests/contracts/lib_contract&quot;
            ),
            Contract(
                name = &quot;LibContractCaller&quot;,
                project = &quot;packages/fuels/tests/contracts/lib_contract_caller&quot;
            ),
        ),
        Deploy(
            name = &quot;lib_contract_instance&quot;,
            contract = &quot;LibContract&quot;,
            wallet = &quot;wallet&quot;
        ),
        Deploy(
            name = &quot;contract_caller_instance&quot;,
            contract = &quot;LibContractCaller&quot;,
            wallet = &quot;wallet&quot;
        ),
        Deploy(
            name = &quot;contract_caller_instance2&quot;,
            contract = &quot;LibContractCaller&quot;,
            wallet = &quot;wallet&quot;
        ),
    );
    let lib_contract_id = lib_contract_instance.contract_id();

    let contract_caller_id = contract_caller_instance.contract_id();

    let contract_caller_id2 = contract_caller_instance2.contract_id();

    // Because we deploy with salt, we can deploy the same contract multiple times
    assert_ne!(contract_caller_id, contract_caller_id2);

    // The first contract can be called because they were deployed on the same provider
    let response = contract_caller_instance
        .methods()
        .increment_from_contract(lib_contract_id, 42)
        .with_contracts(&amp;[&amp;lib_contract_instance])
        .call()
        .await?;

    assert_eq!(43, response.value);

    let response = contract_caller_instance2
        .methods()
        .increment_from_contract(lib_contract_id, 42)
        .with_contracts(&amp;[&amp;lib_contract_instance])
        .call()
        .await?;

    assert_eq!(43, response.value);
</code></pre>
<p>In this example, three contracts are deployed on the same provider using the <code>wallet</code> generated by the <code>Wallets</code> command. The second and third macros use the same contract but have different IDs because of the deployment with salt. Both of them can call the first contract by using their ID.</p>
<p>In addition, you can manually create the <code>wallet</code> variable and then use it inside the macro. This is useful if you want to create custom wallets or providers but still want to use the macro to reduce boilerplate code. Below is an example of this approach.</p>
<pre><code class="language-rust ignore">    let config = WalletsConfig::new(Some(2), Some(1), Some(DEFAULT_COIN_AMOUNT));

    let mut wallets = launch_custom_provider_and_get_wallets(config, None, None).await?;
    let wallet = wallets.pop().unwrap();
    let wallet_2 = wallets.pop().unwrap();

    setup_program_test!(
        Abigen(Contract(
            name = &quot;TestContract&quot;,
            project = &quot;packages/fuels/tests/contracts/contract_test&quot;
        )),
        Deploy(
            name = &quot;contract_instance&quot;,
            contract = &quot;TestContract&quot;,
            wallet = &quot;wallet&quot;
        ),
    );
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="increasing-the-block-height"><a class="header" href="#increasing-the-block-height">Increasing the block height</a></h1>
<p>You can use <code>produce_blocks</code> to help achieve an arbitrary block height; this is useful when you want to do any testing regarding transaction maturity.</p>
<blockquote>
<p><strong>Note</strong>: For the <code>produce_blocks</code> API to work, it is imperative to have <code>manual_blocks_enabled = true</code> in the config for the running node. See example below.</p>
</blockquote>
<pre><code class="language-rust ignore">    let wallets =
        launch_custom_provider_and_get_wallets(WalletsConfig::default(), None, None).await?;
    let wallet = &amp;wallets[0];
    let provider = wallet.try_provider()?;

    assert_eq!(provider.latest_block_height().await?, 0u32);

    provider.produce_blocks(3, None).await?;

    assert_eq!(provider.latest_block_height().await?, 3u32);
</code></pre>
<p>You can also set a custom block time as the second, optional argument. Here is an example:</p>
<pre><code class="language-rust ignore">    let block_time = 20u32; // seconds
    let config = Config {
        // This is how you specify the time between blocks
        block_production: Trigger::Interval {
            block_time: std::time::Duration::from_secs(block_time.into()),
        },
        ..Config::default()
    };
    let wallets =
        launch_custom_provider_and_get_wallets(WalletsConfig::default(), Some(config), None)
            .await?;
    let wallet = &amp;wallets[0];
    let provider = wallet.try_provider()?;

    assert_eq!(provider.latest_block_height().await?, 0u32);
    let origin_block_time = provider.latest_block_time().await?.unwrap();
    let blocks_to_produce = 3;

    provider.produce_blocks(blocks_to_produce, None).await?;
    assert_eq!(provider.latest_block_height().await?, blocks_to_produce);
    let expected_latest_block_time = origin_block_time
        .checked_add_signed(Duration::try_seconds((blocks_to_produce * block_time) as i64).unwrap())
        .unwrap();
    assert_eq!(
        provider.latest_block_time().await?.unwrap(),
        expected_latest_block_time
    );
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cookbook"><a class="header" href="#cookbook">Cookbook</a></h1>
<p>This section covers more advanced use cases that can be satisfied by combining various features of the Rust SDK. As such, it assumes that you have already made yourself familiar with the previous chapters of this book.</p>
<blockquote>
<p><strong>Note</strong> This section is still a work in progress and more recipes may be added in the future.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-chain"><a class="header" href="#custom-chain">Custom chain</a></h1>
<p>This example demonstrates how to start a short-lived Fuel node with custom consensus parameters for the underlying chain.</p>
<p>First, we have to import <code>ConsensusParameters</code> and <code>ChainConfig</code>:</p>
<pre><code class="language-rust ignore">        use fuels::{
            prelude::*,
            tx::{ConsensusParameters, FeeParameters, TxParameters},
        };
</code></pre>
<p>Next, we can define some values for the consensus parameters:</p>
<pre><code class="language-rust ignore">        let tx_params = TxParameters::default()
            .with_max_gas_per_tx(1_000)
            .with_max_inputs(2);
        let fee_params = FeeParameters::default().with_gas_price_factor(10);

        let consensus_parameters = ConsensusParameters {
            tx_params,
            fee_params,
            ..Default::default()
        };

        let chain_config = ChainConfig {
            consensus_parameters,
            ..ChainConfig::default()
        };
</code></pre>
<p>Before we can start a node, we probably also want to define some genesis coins and assign them to an address:</p>
<pre><code class="language-rust ignore">        let wallet = WalletUnlocked::new_random(None);
        let coins = setup_single_asset_coins(
            wallet.address(),
            Default::default(),
            DEFAULT_NUM_COINS,
            DEFAULT_COIN_AMOUNT,
        );
</code></pre>
<p>Finally, we call <code>setup_test_provider()</code>, which starts a node with the given configurations and returns a
provider attached to that node:</p>
<pre><code class="language-rust ignore">        let node_config = Config::default();
        let _provider =
            setup_test_provider(coins, vec![], Some(node_config), Some(chain_config)).await?;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deposit-and-withdraw"><a class="header" href="#deposit-and-withdraw">Deposit and withdraw</a></h1>
<p>Consider the following contract:</p>
<pre><code class="language-rust ignore">contract;

use std::{
    asset::{
        mint_to_address,
        transfer_to_address,
    },
    call_frames::{
        contract_id,
        msg_asset_id,
    },
    constants::ZERO_B256,
    context::msg_amount,
};

abi LiquidityPool {
    #[payable]
    fn deposit(recipient: Address);
    #[payable]
    fn withdraw(recipient: Address);
}

const BASE_TOKEN: AssetId = AssetId::from(0x9ae5b658754e096e4d681c548daf46354495a437cc61492599e33fc64dcdc30c);

impl LiquidityPool for Contract {
    #[payable]
    fn deposit(recipient: Address) {
        assert(BASE_TOKEN == msg_asset_id());
        assert(0 &lt; msg_amount());

        // Mint two times the amount.
        let amount_to_mint = msg_amount() * 2;

        // Mint some LP token based upon the amount of the base token.
        mint_to_address(recipient, ZERO_B256, amount_to_mint);
    }

    #[payable]
    fn withdraw(recipient: Address) {
        assert(0 &lt; msg_amount());

        // Amount to withdraw.
        let amount_to_transfer = msg_amount() / 2;

        // Transfer base token to recipient.
        transfer_to_address(recipient, BASE_TOKEN, amount_to_transfer);
    }
}
</code></pre>
<p>As its name suggests, it represents a simplified example of a liquidity pool contract. The method <code>deposit()</code> expects you to supply an arbitrary amount of the <code>BASE_TOKEN</code>. As a result, it mints double the amount of the liquidity asset to the calling address. Analogously, if you call <code>withdraw()</code> supplying it with the liquidity asset, it will transfer half that amount of the <code>BASE_TOKEN</code> back to the calling address except for deducting it from the contract balance instead of minting it.</p>
<p>The first step towards interacting with any contract in the Rust SDK is calling the <code>abigen!</code> macro to generate type-safe Rust bindings for the contract methods:</p>
<pre><code class="language-rust ignore">        abigen!(Contract(
            name = &quot;MyContract&quot;,
            abi = &quot;packages/fuels/tests/contracts/liquidity_pool/out/debug/liquidity_pool-abi.json&quot;
        ));
</code></pre>
<p>Next, we set up a wallet with custom-defined assets. We give our wallet some of the contracts <code>BASE_TOKEN</code> and the default asset (required for contract deployment):</p>
<pre><code class="language-rust ignore">        let base_asset_id: AssetId =
            &quot;0x9ae5b658754e096e4d681c548daf46354495a437cc61492599e33fc64dcdc30c&quot;.parse()?;

        let asset_ids = [AssetId::default(), base_asset_id];
        let asset_configs = asset_ids
            .map(|id| AssetConfig {
                id,
                num_coins: 1,
                coin_amount: 1_000_000,
            })
            .into();

        let wallet_config = WalletsConfig::new_multiple_assets(1, asset_configs);
        let wallets = launch_custom_provider_and_get_wallets(wallet_config, None, None).await?;
        let wallet = &amp;wallets[0];
</code></pre>
<p>Having launched a provider and created the wallet, we can deploy our contract and create an instance of its methods:</p>
<pre><code class="language-rust ignore">        let contract_id = Contract::load_from(
            &quot;../../packages/fuels/tests/contracts/liquidity_pool/out/debug/liquidity_pool.bin&quot;,
            LoadConfiguration::default(),
        )?
        .deploy(wallet, TxPolicies::default())
        .await?;

        let contract_methods = MyContract::new(contract_id.clone(), wallet.clone()).methods();
</code></pre>
<p>With the preparations out of the way, we can finally deposit to the liquidity pool by calling <code>deposit()</code> via the contract instance. Since we have to transfer assets to the contract, we create the appropriate <code>CallParameters</code> and chain them to the method call. To receive the minted liquidity pool asset, we have to append a variable output to our contract call.</p>
<pre><code class="language-rust ignore">        let deposit_amount = 1_000_000;
        let call_params = CallParameters::default()
            .with_amount(deposit_amount)
            .with_asset_id(base_asset_id);

        contract_methods
            .deposit(wallet.address())
            .call_params(call_params)?
            .append_variable_outputs(1)
            .call()
            .await?;
</code></pre>
<p>As a final demonstration, let's use all our liquidity asset balance to withdraw from the pool and confirm we retrieved the initial amount. For this, we get our liquidity asset balance and supply it to the <code>withdraw()</code> call via <code>CallParameters</code>.</p>
<pre><code class="language-rust ignore">        let lp_asset_id = contract_id.asset_id(&amp;Bits256::zeroed());
        let lp_token_balance = wallet.get_asset_balance(&amp;lp_asset_id).await?;

        let call_params = CallParameters::default()
            .with_amount(lp_token_balance)
            .with_asset_id(lp_asset_id);

        contract_methods
            .withdraw(wallet.address())
            .call_params(call_params)?
            .append_variable_outputs(1)
            .call()
            .await?;

        let base_balance = wallet.get_asset_balance(&amp;base_asset_id).await?;
        assert_eq!(base_balance, deposit_amount);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="transfer-all-assets"><a class="header" href="#transfer-all-assets">Transfer all assets</a></h1>
<p>The <code>transfer()</code> method lets you transfer a single asset, but what if you needed to move all of your assets to a different wallet? You could repeatably call <code>transfer()</code>, initiating a transaction each time, or you bundle all the transfers into a single transaction. This chapter guides you through crafting your custom transaction for transferring all assets owned by a wallet.</p>
<p>Lets quickly go over the setup:</p>
<pre><code class="language-rust ignore">        let mut wallet_1 = WalletUnlocked::new_random(None);
        let mut wallet_2 = WalletUnlocked::new_random(None);

        const NUM_ASSETS: u64 = 5;
        const AMOUNT: u64 = 100_000;
        const NUM_COINS: u64 = 1;
        let (coins, _) =
            setup_multiple_assets_coins(wallet_1.address(), NUM_ASSETS, NUM_COINS, AMOUNT);

        let provider = setup_test_provider(coins, vec![], None, None).await?;

        wallet_1.set_provider(provider.clone());
        wallet_2.set_provider(provider.clone());
</code></pre>
<p>We prepare two wallets with randomized addresses. Next, we want one of our wallets to have some random assets, so we set them up with <code>setup_multiple_assets_coins()</code>. Having created the coins, we can start a provider and assign it to the previously created wallets.</p>
<p>Transactions require us to define input and output coins. Let's assume we do not know the assets owned by <code>wallet_1</code>. We retrieve its balances, i.e. tuples consisting of a string representing the asset ID and the respective amount. This lets us use the helpers <code>get_asset_inputs_for_amount()</code>, <code>get_asset_outputs_for_amount()</code> to create the appropriate inputs and outputs.</p>
<p>For the sake of simplicity, we avoid transferring the base asset so we don't have to worry about transaction fees:</p>
<pre><code class="language-rust ignore">        let balances = wallet_1.get_balances().await?;

        let mut inputs = vec![];
        let mut outputs = vec![];
        for (id_string, amount) in balances {
            let id = AssetId::from_str(&amp;id_string)?;

            // leave the base asset to cover transaction fees
            if id == BASE_ASSET_ID {
                continue;
            }

            let input = wallet_1.get_asset_inputs_for_amount(id, amount).await?;
            inputs.extend(input);

            let output = wallet_1.get_asset_outputs_for_amount(wallet_2.address(), id, amount);
            outputs.extend(output);
        }
</code></pre>
<p>All that is left is to build the transaction via <code>ScriptTransactionBuilder</code>, have <code>wallet_1</code> sign it, and we can send it. We confirm this by checking the number of balances present in the receiving wallet and their amount:</p>
<pre><code class="language-rust ignore">        let mut tb =
            ScriptTransactionBuilder::prepare_transfer(inputs, outputs, TxPolicies::default());
        tb.add_signer(wallet_1.clone())?;

        let tx = tb.build(&amp;provider).await?;

        provider.send_transaction_and_await_commit(tx).await?;

        let balances = wallet_2.get_balances().await?;

        assert_eq!(balances.len(), (NUM_ASSETS - 1) as usize);
        for (_, balance) in balances {
            assert_eq!(balance, AMOUNT);
        }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="debugging"><a class="header" href="#debugging">Debugging</a></h1>
<blockquote>
<p><strong>note</strong> This section is still a work in progress.</p>
</blockquote>
<ul>
<li><a href="debugging/./function-selector.html">The Function Selector</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="function-selector"><a class="header" href="#function-selector">Function selector</a></h1>
<p>Whenever you call a contract method the SDK will generate a function selector according to the fuel specs which will be
used by the node to identify which method we wish to execute.</p>
<p>If, for whatever reason, you wish to generate the function selector yourself you can do so:</p>
<pre><code class="language-rust ignore">        // fn some_fn_name(arg1: Vec&lt;str[3]&gt;, arg2: u8)
        let fn_name = &quot;some_fn_name&quot;;
        let inputs = [Vec::&lt;SizedAsciiString&lt;3&gt;&gt;::param_type(), u8::param_type()];

        let selector = resolve_fn_selector(fn_name, &amp;inputs);

        assert_eq!(selector, [0, 0, 0, 0, 7, 161, 3, 203]);
</code></pre>
<h2 id="if-you-dont-have-the-paramtype"><a class="header" href="#if-you-dont-have-the-paramtype">If you don't have the <code>ParamType</code></a></h2>
<p>If you won't or can't run the <code>abigen!</code> macro and all you have is the JSON ABI of you contract, you can still get the function
selector, but you have to jump through an extra hoop to get the <code>ParamTypes</code>:</p>
<pre><code class="language-rust ignore">        let abi: ProgramABI = serde_json::from_str(&amp;abi_file_contents)?;

        let type_lookup = abi
            .types
            .into_iter()
            .map(|a_type| (a_type.type_id, a_type))
            .collect::&lt;HashMap&lt;_, _&gt;&gt;();

        let a_fun = abi
            .functions
            .into_iter()
            .find(|fun| fun.name == &quot;array_of_structs&quot;)
            .unwrap();

        let inputs = a_fun
            .inputs
            .into_iter()
            .map(|type_appl| ParamType::try_from_type_application(&amp;type_appl, &amp;type_lookup))
            .collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?;

        let selector = resolve_fn_selector(&amp;a_fun.name, &amp;inputs);

        assert_eq!(selector, [0, 0, 0, 0, 39, 152, 108, 146,]);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="glossary"><a class="header" href="#glossary">Glossary</a></h1>
<h2 id="contract"><a class="header" href="#contract">Contract</a></h2>
<!-- This section should define a contract -->
<!-- rs_contract:example:start -->
<p>A contract, in the SDK, is an abstraction that represents a connection to a specific smart contract deployed on the Fuel Network. This contract instance can be used as a regular Rust object, with methods attached to it that reflect those in its smart contract equivalent.</p>
<!-- rs_contract:example:end -->
<h2 id="provider"><a class="header" href="#provider">Provider</a></h2>
<!-- This section should define a provider -->
<!-- rs_provider:example:start -->
<p>A Provider is a struct that provides an abstraction for a connection to a Fuel node. It provides read-only access to the node. You can use this provider as-is or through the wallet.</p>
<!-- rs_provider:example:end -->
<h2 id="wallet-and-signer"><a class="header" href="#wallet-and-signer">Wallet and signer</a></h2>
<!-- This section should define a wallet and signer -->
<!-- rs_wallet_signer:example:start -->
<p>A <code>Wallet</code> is a struct with direct or indirect access to a private key. You can use a <code>Wallet</code> to sign messages and transactions to authorize the network to charge your account to perform operations. The terms wallet and signer in the SDK are often used interchangeably, but, technically, a <code>Signer</code> is simply a Rust trait to enable the signing of transactions and messages; the <code>Wallet</code> implements the <code>Signer</code> trait.</p>
<!-- rs_wallet_signer:example:end -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="contributing-to-the-fuel-rust-sdk"><a class="header" href="#contributing-to-the-fuel-rust-sdk">Contributing to the Fuel Rust SDK</a></h1>
<p>Thanks for your interest in contributing to the Fuel Rust SDK!</p>
<p>This document outlines the process for installing dependencies, setting up for development, and conventions for contributing.`</p>
<p>If you run into any difficulties getting started, you can always ask questions on our <a href="https://forum.fuel.network/">Discourse</a>.</p>
<h2 id="finding-something-to-work-on"><a class="header" href="#finding-something-to-work-on">Finding something to work on</a></h2>
<p>You may contribute to the project in many ways, some of which involve coding knowledge and some which do not. A few examples include:</p>
<ul>
<li>Reporting bugs</li>
<li>Adding new features or bug fixes for which there is already an open issue</li>
<li>Making feature requests</li>
</ul>
<p>Check out our <a href="https://github.com/FuelLabs/fuels-rs/labels/help%20wanted">Help Wanted</a> or <a href="https://github.com/FuelLabs/fuels-rs/labels/good%20first%20issue">Good First Issues</a> to find a suitable task.</p>
<p>If you are planning something big, for example, changes related to multiple components or changes to current behaviors, make sure to <a href="https://github.com/FuelLabs/fuels-rs/issues/new">open an issue</a> to discuss with us before starting on the implementation.</p>
<h2 id="contribution-flow"><a class="header" href="#contribution-flow">Contribution flow</a></h2>
<p>This is a rough outline of what a contributor's workflow looks like:</p>
<ul>
<li>Make sure what you want to contribute is already tracked as an issue.
<ul>
<li>We may discuss the problem and solution in the issue.</li>
</ul>
</li>
<li>Create a Git branch from where you want to base your work. This is usually master.</li>
<li>Write code, add test cases, and commit your work.</li>
<li>Run tests and make sure all tests pass.</li>
<li>Add the breaking label to your PR if the PR contains any breaking changes.</li>
<li>Push your changes to a branch in your fork of the repository and submit a pull request.
<ul>
<li>Make sure to mention the issue created in step 1 in the commit message.</li>
</ul>
</li>
<li>Your PR will be reviewed, and some changes may be requested.
<ul>
<li>Your PR must be re-reviewed and approved once you've made changes.</li>
<li>Use GitHub's 'update branch' button if the PR becomes outdated.</li>
<li>If there are conflicts, you can merge and resolve them locally. Then push to your PR branch. Any changes to the branch will require a re-review.</li>
</ul>
</li>
<li>Our CI system (Github Actions) automatically tests all authorized pull requests.</li>
<li>Use GitHub to merge the PR once approved.</li>
</ul>
<p>Thanks for your contributions!</p>
<h2 id="linking-issues"><a class="header" href="#linking-issues">Linking issues</a></h2>
<p>Pull requests should be linked to at least one issue in the same repo.</p>
<p>If the pull request resolves the relevant issues, and you want GitHub to close these issues automatically after it merged into the default branch, you can use the syntax (<code>KEYWORD #ISSUE-NUMBER</code>) like this:</p>
<pre><code class="language-sh">close #123
</code></pre>
<p>If the pull request links an issue but does not close it, you can use the keyword <code>ref</code> like this:</p>
<pre><code class="language-sh">ref #456
</code></pre>
<p>Multiple issues should use full syntax for each issue and be separated by a comma, like:</p>
<pre><code class="language-sh">close #123, ref #456
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="integration-tests-structure-in-fuels-rs"><a class="header" href="#integration-tests-structure-in-fuels-rs">Integration tests structure in <code>fuels-rs</code></a></h1>
<p>The integration tests of <code>fuels-rs</code> cover almost all aspects of the SDK and have grown significantly as more functionality was added. To make the tests and associated <code>Sway</code> projects more manageable they were split into several categories. A category consist of a <code>.rs</code> file for the tests and, if needed, a separate directory for the <code>Sway</code> projects.</p>
<p>Currently have the following structure:</p>
<pre><code class="language-shell">  .
    bindings/
    contracts/
    logs/
    predicates/
    storage/
    types/
    bindings.rs
    contracts.rs
    from_token.rs
    logs.rs
    predicates.rs
    providers.rs
    scripts.rs
    storage.rs
    types.rs
    wallets.rs
</code></pre>
<p>Even though test organization is subjective, please consider these guidelines before adding a new category:</p>
<ul>
<li>Add a new category when creating a new section in the <code>Fuels Rust SDK</code> book - e.g. <code>Types</code></li>
<li>Add a new category if there are more than 3 test and more than 100 lines of code and they form a group of tests - e.g. <code>storage.rs</code></li>
</ul>
<p>Otherwise, we recommend putting the integration test inside the existing categories above.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fuels-rs-rust-workspaces"><a class="header" href="#fuels-rs-rust-workspaces"><code>fuels-rs</code> Rust Workspaces</a></h1>
<p>This section gives you a little overview of the role and function of every workspace in the <code>fuels-rs</code> repository.</p>
<ul>
<li><a href="cli/./fuels-abi-cli.html"><code>fuels-abi-cli</code></a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fuels-abi-cli"><a class="header" href="#fuels-abi-cli"><code>fuels-abi-cli</code></a></h1>
<p>Simple CLI program to encode Sway function calls and decode their output. The ABI being encoded and decoded is specified <a href="https://specs.fuel.network/master/abi/index.html">here</a>.</p>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<pre><code class="language-plaintext">sway-abi-cli 0.1.0
FuelVM ABI coder

USAGE:
    sway-abi-cli &lt;SUBCOMMAND&gt;

FLAGS:
    -h, --help       Prints help information
    -V, --version    Prints version information

SUBCOMMANDS:
    codegen   Output Rust types file
    decode    Decode ABI call result
    encode    Encode ABI call
    help      Prints this message or the help of the given subcommand(s)
</code></pre>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<p>You can choose to encode only the given params or you can go a step further and have a full JSON ABI file and encode the whole input to a certain function call defined in the JSON file.</p>
<h3 id="encoding-params-only"><a class="header" href="#encoding-params-only">Encoding params only</a></h3>
<pre><code class="language-console">$ cargo run -- encode params -v bool true
0000000000000001
</code></pre>
<pre><code class="language-console">$ cargo run -- encode params -v bool true -v u32 42 -v u32 100
0000000000000001000000000000002a0000000000000064
</code></pre>
<p>Note that for every parameter you want to encode, you must pass a <code>-v</code> flag followed by the type, and then the value: <code>-v &lt;type_1&gt; &lt;value_1&gt; -v &lt;type_2&gt; &lt;value_2&gt; -v &lt;type_n&gt; &lt;value_n&gt;</code></p>
<h3 id="encoding-function-call"><a class="header" href="#encoding-function-call">Encoding function call</a></h3>
<p><code>example/simple.json</code>:</p>
<pre><code class="language-json">[
  {
    &quot;type&quot;:&quot;function&quot;,
    &quot;inputs&quot;:[
      {
        &quot;name&quot;:&quot;arg&quot;,
        &quot;type&quot;:&quot;u32&quot;
      }
    ],
    &quot;name&quot;:&quot;takes_u32_returns_bool&quot;,
    &quot;outputs&quot;:[
      {
        &quot;name&quot;:&quot;&quot;,
        &quot;type&quot;:&quot;bool&quot;
      }
    ]
  }
]
</code></pre>
<pre><code class="language-console">$ cargo run -- encode function examples/simple.json takes_u32_returns_bool -p 4
000000006355e6ee0000000000000004
</code></pre>
<p><code>example/array.json</code></p>
<pre><code class="language-json">[
  {
    &quot;type&quot;:&quot;function&quot;,
    &quot;inputs&quot;:[
      {
        &quot;name&quot;:&quot;arg&quot;,
        &quot;type&quot;:&quot;u16[3]&quot;
      }
    ],
    &quot;name&quot;:&quot;takes_array&quot;,
    &quot;outputs&quot;:[
      {
        &quot;name&quot;:&quot;&quot;,
        &quot;type&quot;:&quot;u16[2]&quot;
      }
    ]
  }
]
</code></pre>
<pre><code class="language-console">$ cargo run -- encode function examples/array.json takes_array -p '[1,2]'
00000000f0b8786400000000000000010000000000000002
</code></pre>
<p>Note that the first word (8 bytes) of the output is reserved for the function selector, which is captured in the last 4 bytes, which is simply the 256hash of the function signature.</p>
<p>Example with nested struct:</p>
<pre><code class="language-json">[
  {
    &quot;type&quot;:&quot;contract&quot;,
    &quot;inputs&quot;:[
      {
        &quot;name&quot;:&quot;MyNestedStruct&quot;,
        &quot;type&quot;:&quot;struct&quot;,
        &quot;components&quot;:[
          {
            &quot;name&quot;:&quot;x&quot;,
            &quot;type&quot;:&quot;u16&quot;
          },
          {
            &quot;name&quot;:&quot;y&quot;,
            &quot;type&quot;:&quot;struct&quot;,
            &quot;components&quot;:[
              {
                &quot;name&quot;:&quot;a&quot;,
                &quot;type&quot;:&quot;bool&quot;
              },
              {
                &quot;name&quot;:&quot;b&quot;,
                &quot;type&quot;:&quot;u8[2]&quot;
              }
            ]
          }
        ]
      }
    ],
    &quot;name&quot;:&quot;takes_nested_struct&quot;,
    &quot;outputs&quot;:[

    ]
  }
]
</code></pre>
<pre><code class="language-console">$ cargo run -- encode function examples/nested_struct.json takes_nested_struct -p '(10, (true, [1,2]))'
00000000e8a04d9c000000000000000a000000000000000100000000000000010000000000000002
</code></pre>
<h3 id="decoding-params-only"><a class="header" href="#decoding-params-only">Decoding params only</a></h3>
<p>Similar to encoding parameters only:</p>
<pre><code class="language-console">$ cargo run -- decode params -t bool -t u32 -t u32 0000000000000001000000000000002a0000000000000064
Bool(true)
U32(42)
U32(100)
</code></pre>
<h3 id="decoding-function-output"><a class="header" href="#decoding-function-output">Decoding function output</a></h3>
<pre><code class="language-console">$ cargo run -- decode function examples/simple.json takes_u32_returns_bool 0000000000000001
Bool(true)
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
